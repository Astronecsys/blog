{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/2022/09/2022杭电杯超级联赛01.md","hash":"09c566dd38fe274f35261fbd0a00228e66e33f2c","modified":1698560699874},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛02.md","hash":"9084181470f6e9e43de6438cc7abe347a47ce744","modified":1698560736091},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛03.md","hash":"55d30e63568ac6916a0b49a80f915d42af2b8ce1","modified":1698560189755},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛04.md","hash":"e33aab64cc93f14173cb002785371d3ee0898974","modified":1698560650138},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛05.md","hash":"cf016815df0187ebbbfade8ea979c3756927303a","modified":1698560581414},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛06.md","hash":"8941c0e5dc58bc9f6c3bb353c467c2d5ef72f129","modified":1698561574538},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛07.md","hash":"360acf148c4f0176ef2953783b8650f0f06c60ed","modified":1698560516490},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛08.md","hash":"e18d0ced6ba28843156613a6009f8240ac33fa3f","modified":1698560683580},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛09.md","hash":"11ac3ccd900c0e5edc1905981fd63a34612ad9f6","modified":1698560636378},{"_id":"source/_posts/2022/09/2022杭电杯超级联赛10.md","hash":"29cf465dff4e23c602ea3688259917ff54c11c88","modified":1698560465211},{"_id":"source/_posts/2022/09/2022牛客多校训练营02.md","hash":"4efdfbc02c64187a72b7e6110c456038f297e649","modified":1698563651984},{"_id":"source/_posts/2022/09/2022牛客多校训练营01.md","hash":"140ad9a34c0af19f930a6f7a846b7af8d2ce1cfc","modified":1698561371237},{"_id":"source/_posts/2022/09/2022牛客多校训练营03.md","hash":"f15cc9e93251dfd546bf933c9c423050458fdc94","modified":1698561735911},{"_id":"source/_posts/2022/09/2022牛客多校训练营04.md","hash":"1c01498bb4f11380622ef5ea975c3f0c9ea9fe7b","modified":1698561480296},{"_id":"source/_posts/2022/09/2022牛客多校训练营05.md","hash":"fb2b2b495b895f0ce2066292189869f6126c88cc","modified":1698561383080},{"_id":"source/_posts/2022/09/2022牛客多校训练营06.md","hash":"428c249a98b120eef22cdf25eb6eb1f8de18808e","modified":1698561352827},{"_id":"source/_posts/2022/09/2022牛客多校训练营07.md","hash":"627f825e59f9c70d2800dcc644cf857a89c1ab02","modified":1698561080304},{"_id":"source/_posts/2022/09/2022牛客多校训练营08.md","hash":"f58b0f5ff565cd1f07b1a9baf9d370413624b05d","modified":1698561097322},{"_id":"source/_posts/2022/09/2022牛客多校训练营09.md","hash":"bef29335e953803ae71ad2643d3c81cf3a211e56","modified":1698560856390},{"_id":"source/_posts/2022/09/2022牛客多校训练营10.md","hash":"575b49f80e0b59e64e9de3be8d8607a95d62ebb9","modified":1698561302371},{"_id":"source/_posts/2022/09/2022牛客多校训练营X1.md","hash":"a9dc34387381e3fd67f486e1b087ce6b64304545","modified":1698561463410},{"_id":"source/_posts/2022/11/再见了-青马易战.md","hash":"db0044cc45e3dbe9c581a519660c777788aee696","modified":1732084537218},{"_id":"source/_posts/2023/01/2023牛客寒假算法基础集训营1.md","hash":"1e8d288abdbdce098b9cac64606703cf937cb480","modified":1698534248336},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展.md","hash":"063a85aea4f51f6da60bc6ff910b94501be14f87","modified":1732085161353},{"_id":"source/_posts/2022/11/再见了-青马易战/Untitled 1.png","hash":"f86d821bf0a8dc4c881f971fa0385994e8507dfe","modified":1698534248335},{"_id":"source/_posts/2022/11/再见了-青马易战/Untitled.png","hash":"396990ab28582c536553e404f21463095dfc3c4b","modified":1698534248336},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 10.png","hash":"f345e52cc359c4e3de405e0fc526cc615e57268c","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 11.png","hash":"d4fb93eba00a31d4df2e1fe62834ff760f6b6f9f","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 12.png","hash":"78021cb6099750b08ecf651a0478ede9f89296a1","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 13.png","hash":"dc975df71dc2f29cdbd97e1212c29b64e3c1868f","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 15.png","hash":"a554e74cf05cd99c3364af980d7cdba1d5b49eee","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 17.png","hash":"e03893e6ff7fb8e27ad964b68e27391c69774862","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 18.png","hash":"58020c3461acd6e53a4dc985bec2540bbc7b0dac","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 25.png","hash":"7f5de53c169830e8bd8128fa73777f123563b3e2","modified":1732042462000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 3.png","hash":"adccce2fe44e178869dbc17a8bac2e0f3b8ce1a7","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 4.png","hash":"469853d6739ab8b8c26f1eb18f11f7a18d28e8fd","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 6.png","hash":"454417692f02bebe7835e87f6e23223341a013af","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 5.png","hash":"10d84a8e79f509d0d622726fa5410125568c1dd4","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 7.png","hash":"d58bf7f3034f138df3a42272b3290aa8a7f5c7ef","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 8.png","hash":"e639da44db0e4bb4bece1d4aaef8d828209bfe70","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 14.png","hash":"57cf591a48a5e37b0aa9269ac4b59af895b89e99","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 16.png","hash":"449651c03b3151f0d5d3b5ffbd9e4274699fd133","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 2.png","hash":"299c90e14e6892f92186a0fc883b6225ada5fd40","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 19.png","hash":"333568f77966559fb885e82f8973ca8e9265aaa6","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 21.png","hash":"3d33d43a197b086eefb2519ed2edda81c4404fb9","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 23.png","hash":"1d3e5c6244c4ac36894cf94d5f5ab03f10df9a9c","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 22.png","hash":"5837ccb3a48bd20d4d52fdc33e4ddf028e67e89d","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 24.png","hash":"c167b1609573bb56c5d742ec50b8f59b94fa9b59","modified":1732042462000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 26.png","hash":"c9ae020df71ceade729329ec101b7b988199e66a","modified":1732042462000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 9.png","hash":"2fc43188eea683742fcbcd49b0ba3e023c5bb218","modified":1732042460000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image.png","hash":"a93493b351f2becadc5bb7623c1e56338b17a68e","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 1.png","hash":"137249679d4c805ef9d3bcfb502eacd5d72dde99","modified":1732042458000},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 20.png","hash":"a5a55034714bc0e55279c050af2619c88d6115f6","modified":1732042460000},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1662519297402},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1662519297404},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1662519297406},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1662519297408},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1662519297410},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1662519297411},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1662519297405},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1662519297407},{"_id":"themes/next/_config.yml","hash":"3d72fd860de906cd5f2eb6f036cafe3e07dbdc26","modified":1732074624784},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1662519297414},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1662519297452},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1662519297594},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1662519297417},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1662519297419},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1662519297420},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1662519297423},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1662519297422},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1662519297426},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1662519297425},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1662519297429},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1662519297428},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1662519297454},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1662519297455},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1662519297457},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1662519297458},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1662519297459},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1662519297461},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1662519297465},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1662519297466},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1662519297462},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1662519297463},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1662519297468},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1662519297469},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1662519297471},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1662519297472},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1662519297473},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1662519297474},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1662519297475},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1662519297477},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1662519297479},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1662519297478},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1662519297481},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1662519297484},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1662519297482},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1662519297589},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1662519297587},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1662519297592},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1662519297590},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1662519297591},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1662519297593},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1662519297626},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1662519297431},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1662519297434},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1662519297433},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1662519297436},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1662519297438},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1662519297440},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1662519297443},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1662519297442},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1662519297444},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1662519297447},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1662519297450},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1662519297448},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1662519297451},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1662519297486},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1662519297487},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1662519297488},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1662519297490},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1662519297492},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1662519297510},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1662519297505},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1662519297527},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1662519297564},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1662519297551},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1662519297570},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1662519297571},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1662519297529},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1662519297530},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1662519297534},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1662519297541},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1662519297543},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1662519297597},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1662519297613},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1662519297616},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1662519297617},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1662519297614},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1662519297618},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1662519297622},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1662519297621},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1662519297623},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1662519297624},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1662519297628},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1662519297629},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1662519297630},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1662519297632},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1662519297633},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1662519297634},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1662519297636},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1662519297638},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1662519297637},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1662519297639},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1662519297641},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1662519297743},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1662519297777},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1662519297778},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1662519297779},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1662519297781},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1662519297783},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1662519297784},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1662519297787},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1662519297788},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1662519297790},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1662519297789},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1662519297791},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1662519297793},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1662519297795},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1662519297794},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1662519297797},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1662519297800},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1662519297799},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1662519297801},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1662519297803},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1662519297808},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1662519297810},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1662519297494},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1662519297497},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1662519297495},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1662519297500},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1662519297499},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1662519297501},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1662519297503},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1662519297507},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1662519297513},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1662519297508},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1662519297516},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1662519297515},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1662519297517},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1662519297519},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1662519297521},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1662519297523},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1662519297522},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1662519297525},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1662519297546},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1662519297547},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1662519297549},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1662519297550},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1662519297557},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1662519297558},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1662519297560},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1662519297563},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1662519297562},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1662519297561},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1662519297553},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1662519297554},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1662519297566},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1662519297568},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1662519297567},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1662519297573},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1662519297574},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1662519297575},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1662519297578},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1662519297579},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1662519297581},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1662519297582},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1662519297586},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1662519297583},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1662519297533},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1662519297585},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1662519297536},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1662519297537},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1662519297538},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1662519297540},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1662519297598},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1662519297603},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1662519297600},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1662519297609},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1662519297606},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1662519297604},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1662519297599},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1662519297608},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1662519297605},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1662519297610},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1662519297612},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1662519297771},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1662519297772},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1662519297773},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1662519297776},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1662519297774},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1662519297805},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1662519297806},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1662519297822},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1662519297823},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1662519297644},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1662519297646},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1662519297647},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1662519297687},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1662519297707},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1662519297706},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1662519297720},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1662519297721},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1662519297722},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1662519297729},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1662519297730},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1662519297733},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1662519297732},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1662519297742},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1662519297746},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1662519297748},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1662519297749},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1662519297750},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1662519297751},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1662519297752},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1662519297754},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1662519297755},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1662519297757},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1662519297758},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1662519297759},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1662519297760},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1662519297763},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1662519297765},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1662519297768},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1662519297764},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1662519297767},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1662519297813},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1662519297769},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1662519297817},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1662519297656},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1662519297660},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1662519297665},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1662519297669},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1662519297672},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1662519297674},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1662519297676},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1662519297679},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1662519297677},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1662519297682},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1662519297680},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1662519297684},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1662519297685},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1662519297649},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1662519297650},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1662519297651},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1662519297654},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1662519297653},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1662519297689},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1662519297690},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1662519297691},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1662519297693},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1662519297694},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1662519297696},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1662519297699},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1662519297698},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1662519297700},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1662519297701},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1662519297703},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1662519297704},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1662519297705},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1662519297709},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1662519297710},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1662519297710},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1662519297711},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1662519297714},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1662519297715},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1662519297713},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1662519297716},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1662519297718},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1662519297717},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1662519297724},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1662519297725},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1662519297728},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1662519297727},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1662519297736},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1662519297735},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1662519297737},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1662519297738},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1662519297739},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1662519297740},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1662519297741},{"_id":"themes/next/source/images/avatar.png","hash":"1c0b91f145fe4b8c51a33d641c2d28a452357a16","modified":1662519287407},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1662519297816},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1662519297819},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/index.html","hash":"98b63aa48b85387fa54199132362fec56eeb6212","modified":1732085380306},{"_id":"public/2023/01/16/2023牛客寒假算法基础集训营1/index.html","hash":"1e6bf757548ebda15e790d05996604b7d3717ded","modified":1732084987333},{"_id":"public/2022/11/08/再见了-青马易战/index.html","hash":"e1e1f72f97d0538483b9b9f0dc73025aab1588bc","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛01/index.html","hash":"21c0c0d95721091c947bf42ada556bcd2ee866b2","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛02/index.html","hash":"0f327e2f35d6bea4a13e5068dbec41615f5be623","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛03/index.html","hash":"5a7be90d16436165aa654c7b99addf6aeca1df3b","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛04/index.html","hash":"77dfd86200a3b258fcb3d19d0eca49052830eba6","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛05/index.html","hash":"4749687dba55a813b41d9a26956d7c1d14963246","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛06/index.html","hash":"efe0a6f518d93169dff62b29ee351078378e2b13","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛07/index.html","hash":"c5570a61154052b1d3f80f244a4437ab403d8c91","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛08/index.html","hash":"bc63f10bf2d9b355e492ca59799952cbda94a088","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛09/index.html","hash":"36bdca8981b6a2bf9d0b448ca9c2ca0825408f53","modified":1732084987333},{"_id":"public/2022/09/01/2022杭电杯超级联赛10/index.html","hash":"017b512c4f5f07af9a82e66070ae00e3c776071f","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营02/index.html","hash":"7357ade5a89d422c39a8ad0968e958d6dffbe7f3","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营01/index.html","hash":"3fc369a8106147d5747c5d9546e9bfe34f7e3cd8","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营03/index.html","hash":"1371ffda76e1cfeea0f355167dcccf3fea701562","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营04/index.html","hash":"b6149b872b0a3adb77d2a8b38a9419eb593c5520","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营05/index.html","hash":"299d8be49907ea1bab13953084e313ca2d8ece9a","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营06/index.html","hash":"c3ec0536e993acd0304138ce8dd6dca5c3e57cf9","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营07/index.html","hash":"b3242271dafc9102e01b8565bce757b72893d726","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营08/index.html","hash":"b15e34b1e733df768bfb08b7581336e2124c0339","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营09/index.html","hash":"9ef4951901e0451dbf0daf9eecd31fecfb9a82a4","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营10/index.html","hash":"61ac26d96cd0a70244d3fcd2b2ca5353aa553f75","modified":1732084987333},{"_id":"public/2022/09/01/2022牛客多校训练营X1/index.html","hash":"b04f15d463ad4986e546900514bd79132e128e79","modified":1732084987333},{"_id":"public/archives/index.html","hash":"3baae1382333212013a17d043c202a059f8717d2","modified":1732084987333},{"_id":"public/archives/page/2/index.html","hash":"9710a41e5e346f59692909b395261026a2378e3e","modified":1732084987333},{"_id":"public/archives/page/3/index.html","hash":"01669342a007b9c1f37aa352de8030b56f9b8a85","modified":1732084987333},{"_id":"public/archives/2022/index.html","hash":"bf51385265a27669675331e5ea4972e9a75dd225","modified":1732084987333},{"_id":"public/archives/2022/page/2/index.html","hash":"813c0cd9d8ca525ce024cb6650a15af2bdd5069a","modified":1732084987333},{"_id":"public/archives/2022/page/3/index.html","hash":"0534f1e3f7978cebb675a8a22879312f0879bdb8","modified":1732084987333},{"_id":"public/archives/2022/09/index.html","hash":"ab9e07b89fea18e540d2748c0ef8bc691c9f05b8","modified":1732084987333},{"_id":"public/archives/2022/09/page/2/index.html","hash":"7c6dad2fa53335574ebbe8e1b8f943930818d09f","modified":1732084987333},{"_id":"public/archives/2022/09/page/3/index.html","hash":"a0a89093cecd3a7572b20ac4ce34785ed2975e85","modified":1732084987333},{"_id":"public/archives/2022/11/index.html","hash":"1c127256843b96477b44e0caa59b6392eb1f239f","modified":1732084987333},{"_id":"public/archives/2023/index.html","hash":"7bbbf7e430223ba5ec1b4f10967dcb267f919cd8","modified":1732084987333},{"_id":"public/archives/2023/01/index.html","hash":"1b783403e9ebec56eca5b2f94db13613720847cd","modified":1732084987333},{"_id":"public/index.html","hash":"2a8f2707a48120a560fddc8598b9a39e40405506","modified":1732085380306},{"_id":"public/archives/2024/index.html","hash":"f257eb360ba826b464dcb42aab3f08ed919cca72","modified":1732084987333},{"_id":"public/archives/2024/11/index.html","hash":"597806fb7d56b9df64b056ba815a27485d314f83","modified":1732084987333},{"_id":"public/page/2/index.html","hash":"1d2529d9289a691da718e96fdbbc086d57c904dd","modified":1732084987333},{"_id":"public/page/3/index.html","hash":"9c8a107b9b4cea792b8675730489315b70d1059e","modified":1732084987333},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1732084987333},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1732084987333},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1732084987333},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1732084987333},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1732084987333},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1732084987333},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1732084987333},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1732084987333},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1732084987333},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1732084987333},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1732084987333},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1732084987333},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1732084987333},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1732084987333},{"_id":"public/2022/11/08/再见了-青马易战/Untitled 1.png","hash":"f86d821bf0a8dc4c881f971fa0385994e8507dfe","modified":1732084987333},{"_id":"public/2022/11/08/再见了-青马易战/Untitled.png","hash":"396990ab28582c536553e404f21463095dfc3c4b","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 10.png","hash":"f345e52cc359c4e3de405e0fc526cc615e57268c","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 11.png","hash":"d4fb93eba00a31d4df2e1fe62834ff760f6b6f9f","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 12.png","hash":"78021cb6099750b08ecf651a0478ede9f89296a1","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 13.png","hash":"dc975df71dc2f29cdbd97e1212c29b64e3c1868f","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 15.png","hash":"a554e74cf05cd99c3364af980d7cdba1d5b49eee","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 17.png","hash":"e03893e6ff7fb8e27ad964b68e27391c69774862","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 18.png","hash":"58020c3461acd6e53a4dc985bec2540bbc7b0dac","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 25.png","hash":"7f5de53c169830e8bd8128fa73777f123563b3e2","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 3.png","hash":"adccce2fe44e178869dbc17a8bac2e0f3b8ce1a7","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 4.png","hash":"469853d6739ab8b8c26f1eb18f11f7a18d28e8fd","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 5.png","hash":"10d84a8e79f509d0d622726fa5410125568c1dd4","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 6.png","hash":"454417692f02bebe7835e87f6e23223341a013af","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 7.png","hash":"d58bf7f3034f138df3a42272b3290aa8a7f5c7ef","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 8.png","hash":"e639da44db0e4bb4bece1d4aaef8d828209bfe70","modified":1732084987333},{"_id":"public/images/avatar.png","hash":"1c0b91f145fe4b8c51a33d641c2d28a452357a16","modified":1732084987333},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1732084987333},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 14.png","hash":"57cf591a48a5e37b0aa9269ac4b59af895b89e99","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 16.png","hash":"449651c03b3151f0d5d3b5ffbd9e4274699fd133","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 19.png","hash":"333568f77966559fb885e82f8973ca8e9265aaa6","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 2.png","hash":"299c90e14e6892f92186a0fc883b6225ada5fd40","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 21.png","hash":"3d33d43a197b086eefb2519ed2edda81c4404fb9","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 22.png","hash":"5837ccb3a48bd20d4d52fdc33e4ddf028e67e89d","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 23.png","hash":"1d3e5c6244c4ac36894cf94d5f5ab03f10df9a9c","modified":1732084987333},{"_id":"public/css/main.css","hash":"33ab76556a4d573be37210ccc103239c63944dbe","modified":1732084987333},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1732084987333},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1732084987333},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1732084987333},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1732084987333},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1732084987333},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1732084987333},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1732084987333},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1732084987333},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1732084987333},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1732084987333},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1732084987333},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 24.png","hash":"c167b1609573bb56c5d742ec50b8f59b94fa9b59","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 26.png","hash":"c9ae020df71ceade729329ec101b7b988199e66a","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 9.png","hash":"2fc43188eea683742fcbcd49b0ba3e023c5bb218","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image.png","hash":"a93493b351f2becadc5bb7623c1e56338b17a68e","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 1.png","hash":"137249679d4c805ef9d3bcfb502eacd5d72dde99","modified":1732084987333},{"_id":"public/2024/11/19/Space SHMUP 拆解和拓展/image 20.png","hash":"a5a55034714bc0e55279c050af2619c88d6115f6","modified":1732084987333}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"2022杭电杯超级联赛01","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1011-Random\n\n来源: 杭电杯超级联赛1\n算法: 概率论, 逆元\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1044&pid=1011\n补完: Yes\n完成时间: August 24, 2022\n\n## 题解\n\n给随机数$[0,1]$, 则期望为$1/2$, 给$n$次, 减去$m$次, 问最后所得值.直接计算即可. \n\n若$n<=m$即删的次数比抽的次数多, 直接归零, \n\n非则$ans= (n-m)*1/2$.同余除法用逆元处理. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 1000000007;\n\nll Mul(ll a, ll b){\n    return (a * b) % P;\n}\nll Pow(ll a, ll n){\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = Mul(a, ans);\n        a = Mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\nll Div(ll a, ll b){\n    b = Pow(b, P - 2);\n    return Mul(a, b);\n}\n\nvoid solve() {\n    ll n, m;\n    cin>>n>>m;\n    if(n<=m)printf(\"0\\n\");\n    else printf(\"%lld\\n\",Div((n-m),2));\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;// 无多组数据注释这一行\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# 1012-Alice and Bob\n\n来源: 杭电杯超级联赛1\n算法: 博弈论\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1044&pid=1012\n补完: Yes\n完成时间: August 4, 2022\n\n[题目链接](https://acm.hdu.edu.cn/contest/problem?cid=1044&pid=1012)\n\n## 题意简述\n\nAlice和Bob玩游戏。黑板上有介于$0\\sim n$之间的数字，给出每个数字的个数。任何时候，有数字$0$存在，Alice获胜。否则Alice可以把数字分成两组，然后Bob可以选择一组擦除，另一组所有数字$-1$。擦除所有的数字后，Bob获胜。\n\n双方都使用最优的策略，问谁会获胜。\n\n## 题目分析\n\n首先，一开始有$0$，Alice获胜。\n\n那么如果有$1$，Alice会尽量保护它不被Bob擦除，这样一轮之后$1$变成$0$了，Alice获胜。而同理Bob必须要擦除$1$。\n\n那么如果有$2$个以及以上的数字$1$，Alice就能胜利，把它们分在两组里，Bob无论擦哪组，都有剩下的$1$变成$0$。\n\n如果没有$1$和$0$，最小的数字从$2$开始，Alice要胜利的话需要多少个$2$呢？\n\n$2$经过一轮变成$1$，再一轮变成$0$，如果分配$2$不均衡，Bob擦除比较多的那组就能防止Alice希望的$2$变成$0$，所以Alice应该尽量平分$2$。\n\n需要$2个1$存在，就需要这一轮有$4$个以及以上的$2$存在，平均分到两堆之后，最少会有$2个2$被剩下，然后变成$2个1$，从而变成$0$。\n\n以此类推，我们会需要$8个3，16个4….2^i个i$。\n\n——\n\n这是在比i小的数字都不存在的情况下的状况。如果存在呢？\n\n譬如存在$4个3$和$8个4$的情况下，Alice均分它们一次，变成了$2个2$和$4个3$，再一次，$1个1和2个2$，再把$1和2$分开，就满足了胜利条件。\n\n或者Alice把$3和4$分开，为了防止下一轮出现$4个2$，Bob必须删除$4个3$，但$8个4$变成$8个3$，同样达到了Alice的胜利条件。\n\n总之，比较小的数字在分裂过程中拖了几轮，就让比较大的数字“降了几阶”。\n\n就像$8个4$变成$8个3$一样。\n\n或者换言之，小的数字可以成倍替代大的数字。这个情景里$4个3$相当于$8个4$。\n\n所以从小的数字开始，判断i是否有$2^i$个，有则Alice宣告胜利，否则它的点数贡献到后面。\n\n详细的写法不做展开~~（因为累乘炸long long光荣地写挂了）~~\n\n————\n\n已知累乘真的会写炸，不管是记录指数还是直接硬乘~~（也许高精度是可以救的但是谁没事干写高精度啊）~~\n\n那我们只能，拿来除了！\n\n上面例子，既可以认为是$4个3$相当于$8个4$，当然也可以认为$8个4$相当于$4个3$嘛。\n\n也就是$num_x$个$x$相当于$num_x/2$个$x-1$。\n\n并且这样除到最后可以直接通到$0$的位置，判断起来比对着$2^i$个$i$舒服多了。\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n    int world[100005];\n    int n;\n    cin>>n;\n    int flag=0;\n    for(int i=0;i<=n;i++){\n        cin>>world[i];\n    }\n    for(int i=n;i>=0;i--){\n        world[i-1]+=world[i]/2;\n    }\n    if(world[0]==0)printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛01.md","raw":"---\ntitle: 2022杭电杯超级联赛01\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1011-Random\n\n来源: 杭电杯超级联赛1\n算法: 概率论, 逆元\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1044&pid=1011\n补完: Yes\n完成时间: August 24, 2022\n\n## 题解\n\n给随机数$[0,1]$, 则期望为$1/2$, 给$n$次, 减去$m$次, 问最后所得值.直接计算即可. \n\n若$n<=m$即删的次数比抽的次数多, 直接归零, \n\n非则$ans= (n-m)*1/2$.同余除法用逆元处理. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 1000000007;\n\nll Mul(ll a, ll b){\n    return (a * b) % P;\n}\nll Pow(ll a, ll n){\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = Mul(a, ans);\n        a = Mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\nll Div(ll a, ll b){\n    b = Pow(b, P - 2);\n    return Mul(a, b);\n}\n\nvoid solve() {\n    ll n, m;\n    cin>>n>>m;\n    if(n<=m)printf(\"0\\n\");\n    else printf(\"%lld\\n\",Div((n-m),2));\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;// 无多组数据注释这一行\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# 1012-Alice and Bob\n\n来源: 杭电杯超级联赛1\n算法: 博弈论\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1044&pid=1012\n补完: Yes\n完成时间: August 4, 2022\n\n[题目链接](https://acm.hdu.edu.cn/contest/problem?cid=1044&pid=1012)\n\n## 题意简述\n\nAlice和Bob玩游戏。黑板上有介于$0\\sim n$之间的数字，给出每个数字的个数。任何时候，有数字$0$存在，Alice获胜。否则Alice可以把数字分成两组，然后Bob可以选择一组擦除，另一组所有数字$-1$。擦除所有的数字后，Bob获胜。\n\n双方都使用最优的策略，问谁会获胜。\n\n## 题目分析\n\n首先，一开始有$0$，Alice获胜。\n\n那么如果有$1$，Alice会尽量保护它不被Bob擦除，这样一轮之后$1$变成$0$了，Alice获胜。而同理Bob必须要擦除$1$。\n\n那么如果有$2$个以及以上的数字$1$，Alice就能胜利，把它们分在两组里，Bob无论擦哪组，都有剩下的$1$变成$0$。\n\n如果没有$1$和$0$，最小的数字从$2$开始，Alice要胜利的话需要多少个$2$呢？\n\n$2$经过一轮变成$1$，再一轮变成$0$，如果分配$2$不均衡，Bob擦除比较多的那组就能防止Alice希望的$2$变成$0$，所以Alice应该尽量平分$2$。\n\n需要$2个1$存在，就需要这一轮有$4$个以及以上的$2$存在，平均分到两堆之后，最少会有$2个2$被剩下，然后变成$2个1$，从而变成$0$。\n\n以此类推，我们会需要$8个3，16个4….2^i个i$。\n\n——\n\n这是在比i小的数字都不存在的情况下的状况。如果存在呢？\n\n譬如存在$4个3$和$8个4$的情况下，Alice均分它们一次，变成了$2个2$和$4个3$，再一次，$1个1和2个2$，再把$1和2$分开，就满足了胜利条件。\n\n或者Alice把$3和4$分开，为了防止下一轮出现$4个2$，Bob必须删除$4个3$，但$8个4$变成$8个3$，同样达到了Alice的胜利条件。\n\n总之，比较小的数字在分裂过程中拖了几轮，就让比较大的数字“降了几阶”。\n\n就像$8个4$变成$8个3$一样。\n\n或者换言之，小的数字可以成倍替代大的数字。这个情景里$4个3$相当于$8个4$。\n\n所以从小的数字开始，判断i是否有$2^i$个，有则Alice宣告胜利，否则它的点数贡献到后面。\n\n详细的写法不做展开~~（因为累乘炸long long光荣地写挂了）~~\n\n————\n\n已知累乘真的会写炸，不管是记录指数还是直接硬乘~~（也许高精度是可以救的但是谁没事干写高精度啊）~~\n\n那我们只能，拿来除了！\n\n上面例子，既可以认为是$4个3$相当于$8个4$，当然也可以认为$8个4$相当于$4个3$嘛。\n\n也就是$num_x$个$x$相当于$num_x/2$个$x-1$。\n\n并且这样除到最后可以直接通到$0$的位置，判断起来比对着$2^i$个$i$舒服多了。\n\n## 完整代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n    int world[100005];\n    int n;\n    cin>>n;\n    int flag=0;\n    for(int i=0;i<=n;i++){\n        cin>>world[i];\n    }\n    for(int i=n;i>=0;i--){\n        world[i-1]+=world[i]/2;\n    }\n    if(world[0]==0)printf(\"Bob\\n\");\n    else printf(\"Alice\\n\");\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","slug":"2022杭电杯超级联赛01","published":1,"updated":"2023-10-29T06:24:59.874Z","comments":1,"layout":"post","photos":[],"_id":"cm3piheww0000n0um9yjg1yd9","content":"<h1 id=\"random\">1011-Random</h1>\r\n<p>来源: 杭电杯超级联赛1 算法: 概率论, 逆元 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1044&amp;pid=1011 补完: Yes\r\n完成时间: August 24, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给随机数<span class=\"math inline\">\\([0,1]\\)</span>, 则期望为<span\r\nclass=\"math inline\">\\(1/2\\)</span>, 给<span\r\nclass=\"math inline\">\\(n\\)</span>次, 减去<span\r\nclass=\"math inline\">\\(m\\)</span>次, 问最后所得值.直接计算即可.</p>\r\n<p>若<span class=\"math inline\">\\(n&lt;=m\\)</span>即删的次数比抽的次数多,\r\n直接归零,</p>\r\n<p>非则<span class=\"math inline\">\\(ans=\r\n(n-m)*1/2\\)</span>.同余除法用逆元处理.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Pow</span><span class=\"params\">(ll a, ll n)</span></span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">Mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">Mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Div</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    b = <span class=\"built_in\">Pow</span>(b, P - <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Mul</span>(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll n, m;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=m)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>,<span class=\"built_in\">Div</span>((n-m),<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;<span class=\"comment\">// 无多组数据注释这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"alice-and-bob\">1012-Alice and Bob</h1>\r\n<p>来源: 杭电杯超级联赛1 算法: 博弈论 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1044&amp;pid=1012 补完: Yes\r\n完成时间: August 4, 2022</p>\r\n<p><a\r\nhref=\"https://acm.hdu.edu.cn/contest/problem?cid=1044&amp;pid=1012\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>Alice和Bob玩游戏。黑板上有介于<span class=\"math inline\">\\(0\\sim\r\nn\\)</span>之间的数字，给出每个数字的个数。任何时候，有数字<span\r\nclass=\"math inline\">\\(0\\)</span>存在，Alice获胜。否则Alice可以把数字分成两组，然后Bob可以选择一组擦除，另一组所有数字<span\r\nclass=\"math inline\">\\(-1\\)</span>。擦除所有的数字后，Bob获胜。</p>\r\n<p>双方都使用最优的策略，问谁会获胜。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>首先，一开始有<span class=\"math inline\">\\(0\\)</span>，Alice获胜。</p>\r\n<p>那么如果有<span\r\nclass=\"math inline\">\\(1\\)</span>，Alice会尽量保护它不被Bob擦除，这样一轮之后<span\r\nclass=\"math inline\">\\(1\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>了，Alice获胜。而同理Bob必须要擦除<span\r\nclass=\"math inline\">\\(1\\)</span>。</p>\r\n<p>那么如果有<span class=\"math inline\">\\(2\\)</span>个以及以上的数字<span\r\nclass=\"math inline\">\\(1\\)</span>，Alice就能胜利，把它们分在两组里，Bob无论擦哪组，都有剩下的<span\r\nclass=\"math inline\">\\(1\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>。</p>\r\n<p>如果没有<span class=\"math inline\">\\(1\\)</span>和<span\r\nclass=\"math inline\">\\(0\\)</span>，最小的数字从<span\r\nclass=\"math inline\">\\(2\\)</span>开始，Alice要胜利的话需要多少个<span\r\nclass=\"math inline\">\\(2\\)</span>呢？</p>\r\n<p><span class=\"math inline\">\\(2\\)</span>经过一轮变成<span\r\nclass=\"math inline\">\\(1\\)</span>，再一轮变成<span\r\nclass=\"math inline\">\\(0\\)</span>，如果分配<span\r\nclass=\"math inline\">\\(2\\)</span>不均衡，Bob擦除比较多的那组就能防止Alice希望的<span\r\nclass=\"math inline\">\\(2\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>，所以Alice应该尽量平分<span\r\nclass=\"math inline\">\\(2\\)</span>。</p>\r\n<p>需要<span\r\nclass=\"math inline\">\\(2个1\\)</span>存在，就需要这一轮有<span\r\nclass=\"math inline\">\\(4\\)</span>个以及以上的<span\r\nclass=\"math inline\">\\(2\\)</span>存在，平均分到两堆之后，最少会有<span\r\nclass=\"math inline\">\\(2个2\\)</span>被剩下，然后变成<span\r\nclass=\"math inline\">\\(2个1\\)</span>，从而变成<span\r\nclass=\"math inline\">\\(0\\)</span>。</p>\r\n<p>以此类推，我们会需要<span\r\nclass=\"math inline\">\\(8个3，16个4….2^i个i\\)</span>。</p>\r\n<p>——</p>\r\n<p>这是在比i小的数字都不存在的情况下的状况。如果存在呢？</p>\r\n<p>譬如存在<span class=\"math inline\">\\(4个3\\)</span>和<span\r\nclass=\"math inline\">\\(8个4\\)</span>的情况下，Alice均分它们一次，变成了<span\r\nclass=\"math inline\">\\(2个2\\)</span>和<span\r\nclass=\"math inline\">\\(4个3\\)</span>，再一次，<span\r\nclass=\"math inline\">\\(1个1和2个2\\)</span>，再把<span\r\nclass=\"math inline\">\\(1和2\\)</span>分开，就满足了胜利条件。</p>\r\n<p>或者Alice把<span\r\nclass=\"math inline\">\\(3和4\\)</span>分开，为了防止下一轮出现<span\r\nclass=\"math inline\">\\(4个2\\)</span>，Bob必须删除<span\r\nclass=\"math inline\">\\(4个3\\)</span>，但<span\r\nclass=\"math inline\">\\(8个4\\)</span>变成<span\r\nclass=\"math inline\">\\(8个3\\)</span>，同样达到了Alice的胜利条件。</p>\r\n<p>总之，比较小的数字在分裂过程中拖了几轮，就让比较大的数字“降了几阶”。</p>\r\n<p>就像<span class=\"math inline\">\\(8个4\\)</span>变成<span\r\nclass=\"math inline\">\\(8个3\\)</span>一样。</p>\r\n<p>或者换言之，小的数字可以成倍替代大的数字。这个情景里<span\r\nclass=\"math inline\">\\(4个3\\)</span>相当于<span\r\nclass=\"math inline\">\\(8个4\\)</span>。</p>\r\n<p>所以从小的数字开始，判断i是否有<span\r\nclass=\"math inline\">\\(2^i\\)</span>个，有则Alice宣告胜利，否则它的点数贡献到后面。</p>\r\n<p>详细的写法不做展开<del>（因为累乘炸long long光荣地写挂了）</del></p>\r\n<p>————</p>\r\n<p>已知累乘真的会写炸，不管是记录指数还是直接硬乘<del>（也许高精度是可以救的但是谁没事干写高精度啊）</del></p>\r\n<p>那我们只能，拿来除了！</p>\r\n<p>上面例子，既可以认为是<span\r\nclass=\"math inline\">\\(4个3\\)</span>相当于<span\r\nclass=\"math inline\">\\(8个4\\)</span>，当然也可以认为<span\r\nclass=\"math inline\">\\(8个4\\)</span>相当于<span\r\nclass=\"math inline\">\\(4个3\\)</span>嘛。</p>\r\n<p>也就是<span class=\"math inline\">\\(num_x\\)</span>个<span\r\nclass=\"math inline\">\\(x\\)</span>相当于<span\r\nclass=\"math inline\">\\(num_x/2\\)</span>个<span\r\nclass=\"math inline\">\\(x-1\\)</span>。</p>\r\n<p>并且这样除到最后可以直接通到<span\r\nclass=\"math inline\">\\(0\\)</span>的位置，判断起来比对着<span\r\nclass=\"math inline\">\\(2^i\\)</span>个<span\r\nclass=\"math inline\">\\(i\\)</span>舒服多了。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> world[<span class=\"number\">100005</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;world[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        world[i<span class=\"number\">-1</span>]+=world[i]/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(world[<span class=\"number\">0</span>]==<span class=\"number\">0</span>)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Bob\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Alice\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"random\">1011-Random</h1>\r\n<p>来源: 杭电杯超级联赛1 算法: 概率论, 逆元 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1044&amp;pid=1011 补完: Yes\r\n完成时间: August 24, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给随机数<span class=\"math inline\">\\([0,1]\\)</span>, 则期望为<span\r\nclass=\"math inline\">\\(1/2\\)</span>, 给<span\r\nclass=\"math inline\">\\(n\\)</span>次, 减去<span\r\nclass=\"math inline\">\\(m\\)</span>次, 问最后所得值.直接计算即可.</p>\r\n<p>若<span class=\"math inline\">\\(n&lt;=m\\)</span>即删的次数比抽的次数多,\r\n直接归零,</p>\r\n<p>非则<span class=\"math inline\">\\(ans=\r\n(n-m)*1/2\\)</span>.同余除法用逆元处理.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Pow</span><span class=\"params\">(ll a, ll n)</span></span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">Mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">Mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Div</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    b = <span class=\"built_in\">Pow</span>(b, P - <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Mul</span>(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll n, m;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=m)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>,<span class=\"built_in\">Div</span>((n-m),<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;<span class=\"comment\">// 无多组数据注释这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"alice-and-bob\">1012-Alice and Bob</h1>\r\n<p>来源: 杭电杯超级联赛1 算法: 博弈论 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1044&amp;pid=1012 补完: Yes\r\n完成时间: August 4, 2022</p>\r\n<p><a\r\nhref=\"https://acm.hdu.edu.cn/contest/problem?cid=1044&amp;pid=1012\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>Alice和Bob玩游戏。黑板上有介于<span class=\"math inline\">\\(0\\sim\r\nn\\)</span>之间的数字，给出每个数字的个数。任何时候，有数字<span\r\nclass=\"math inline\">\\(0\\)</span>存在，Alice获胜。否则Alice可以把数字分成两组，然后Bob可以选择一组擦除，另一组所有数字<span\r\nclass=\"math inline\">\\(-1\\)</span>。擦除所有的数字后，Bob获胜。</p>\r\n<p>双方都使用最优的策略，问谁会获胜。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>首先，一开始有<span class=\"math inline\">\\(0\\)</span>，Alice获胜。</p>\r\n<p>那么如果有<span\r\nclass=\"math inline\">\\(1\\)</span>，Alice会尽量保护它不被Bob擦除，这样一轮之后<span\r\nclass=\"math inline\">\\(1\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>了，Alice获胜。而同理Bob必须要擦除<span\r\nclass=\"math inline\">\\(1\\)</span>。</p>\r\n<p>那么如果有<span class=\"math inline\">\\(2\\)</span>个以及以上的数字<span\r\nclass=\"math inline\">\\(1\\)</span>，Alice就能胜利，把它们分在两组里，Bob无论擦哪组，都有剩下的<span\r\nclass=\"math inline\">\\(1\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>。</p>\r\n<p>如果没有<span class=\"math inline\">\\(1\\)</span>和<span\r\nclass=\"math inline\">\\(0\\)</span>，最小的数字从<span\r\nclass=\"math inline\">\\(2\\)</span>开始，Alice要胜利的话需要多少个<span\r\nclass=\"math inline\">\\(2\\)</span>呢？</p>\r\n<p><span class=\"math inline\">\\(2\\)</span>经过一轮变成<span\r\nclass=\"math inline\">\\(1\\)</span>，再一轮变成<span\r\nclass=\"math inline\">\\(0\\)</span>，如果分配<span\r\nclass=\"math inline\">\\(2\\)</span>不均衡，Bob擦除比较多的那组就能防止Alice希望的<span\r\nclass=\"math inline\">\\(2\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>，所以Alice应该尽量平分<span\r\nclass=\"math inline\">\\(2\\)</span>。</p>\r\n<p>需要<span\r\nclass=\"math inline\">\\(2个1\\)</span>存在，就需要这一轮有<span\r\nclass=\"math inline\">\\(4\\)</span>个以及以上的<span\r\nclass=\"math inline\">\\(2\\)</span>存在，平均分到两堆之后，最少会有<span\r\nclass=\"math inline\">\\(2个2\\)</span>被剩下，然后变成<span\r\nclass=\"math inline\">\\(2个1\\)</span>，从而变成<span\r\nclass=\"math inline\">\\(0\\)</span>。</p>\r\n<p>以此类推，我们会需要<span\r\nclass=\"math inline\">\\(8个3，16个4….2^i个i\\)</span>。</p>\r\n<p>——</p>\r\n<p>这是在比i小的数字都不存在的情况下的状况。如果存在呢？</p>\r\n<p>譬如存在<span class=\"math inline\">\\(4个3\\)</span>和<span\r\nclass=\"math inline\">\\(8个4\\)</span>的情况下，Alice均分它们一次，变成了<span\r\nclass=\"math inline\">\\(2个2\\)</span>和<span\r\nclass=\"math inline\">\\(4个3\\)</span>，再一次，<span\r\nclass=\"math inline\">\\(1个1和2个2\\)</span>，再把<span\r\nclass=\"math inline\">\\(1和2\\)</span>分开，就满足了胜利条件。</p>\r\n<p>或者Alice把<span\r\nclass=\"math inline\">\\(3和4\\)</span>分开，为了防止下一轮出现<span\r\nclass=\"math inline\">\\(4个2\\)</span>，Bob必须删除<span\r\nclass=\"math inline\">\\(4个3\\)</span>，但<span\r\nclass=\"math inline\">\\(8个4\\)</span>变成<span\r\nclass=\"math inline\">\\(8个3\\)</span>，同样达到了Alice的胜利条件。</p>\r\n<p>总之，比较小的数字在分裂过程中拖了几轮，就让比较大的数字“降了几阶”。</p>\r\n<p>就像<span class=\"math inline\">\\(8个4\\)</span>变成<span\r\nclass=\"math inline\">\\(8个3\\)</span>一样。</p>\r\n<p>或者换言之，小的数字可以成倍替代大的数字。这个情景里<span\r\nclass=\"math inline\">\\(4个3\\)</span>相当于<span\r\nclass=\"math inline\">\\(8个4\\)</span>。</p>\r\n<p>所以从小的数字开始，判断i是否有<span\r\nclass=\"math inline\">\\(2^i\\)</span>个，有则Alice宣告胜利，否则它的点数贡献到后面。</p>\r\n<p>详细的写法不做展开<del>（因为累乘炸long long光荣地写挂了）</del></p>\r\n<p>————</p>\r\n<p>已知累乘真的会写炸，不管是记录指数还是直接硬乘<del>（也许高精度是可以救的但是谁没事干写高精度啊）</del></p>\r\n<p>那我们只能，拿来除了！</p>\r\n<p>上面例子，既可以认为是<span\r\nclass=\"math inline\">\\(4个3\\)</span>相当于<span\r\nclass=\"math inline\">\\(8个4\\)</span>，当然也可以认为<span\r\nclass=\"math inline\">\\(8个4\\)</span>相当于<span\r\nclass=\"math inline\">\\(4个3\\)</span>嘛。</p>\r\n<p>也就是<span class=\"math inline\">\\(num_x\\)</span>个<span\r\nclass=\"math inline\">\\(x\\)</span>相当于<span\r\nclass=\"math inline\">\\(num_x/2\\)</span>个<span\r\nclass=\"math inline\">\\(x-1\\)</span>。</p>\r\n<p>并且这样除到最后可以直接通到<span\r\nclass=\"math inline\">\\(0\\)</span>的位置，判断起来比对着<span\r\nclass=\"math inline\">\\(2^i\\)</span>个<span\r\nclass=\"math inline\">\\(i\\)</span>舒服多了。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> world[<span class=\"number\">100005</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;world[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        world[i<span class=\"number\">-1</span>]+=world[i]/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(world[<span class=\"number\">0</span>]==<span class=\"number\">0</span>)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Bob\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Alice\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛02","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1002-C++ to Python\n\n来源: 杭电杯超级联赛2\n算法: 字符串, 语法\n补完: Yes\n完成时间: July 31, 2022\n\n## 题解\n\n去除字母下划线冒号, 保留数字逗号和括号即可\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nvoid solve(){\n    string a;\n    cin>>a;\n    int len=a.length();\n    for(int i=0;i<len;i++)\n        if(!isalpha(a[i])&&(a[i]!='_')&&(a[i]!=':'))\n            printf(\"%c\",a[i]);\n    printf(\"\\n\");\n}\nint main(){\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# 1007-Snatch Groceries\n\n来源: 杭电杯超级联赛2\n算法: 贪心\n补完: Yes\n完成时间: August 24, 2022\n\n## 题解\n\n很鸡的抢票服务器给大家提供服务, 每个人有抢到票的置信区间, 若有人同时抢票服务器就寄了, 问有多少人能抢到票. \n\n区间排序后挨个取答案, 发现时间冲突了就退出循环.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\n\n// 区间\nstruct Interval{\n    int start;\n    int finish;\n    bool operator<(const Interval other) const {\n        return start<other.start||(start==other.start&&finish<other.finish);\n    }\n};\n\nint dep(vector<Interval> intervals){\n    intervals.push_back({(int)1e9+10,(int)1e9+10});\n    sort(intervals.begin(),intervals.end());\n    int temp = 0;\n    for (int i = 0; i < n; ++i) {\n        if (intervals[i].finish<intervals[i+1].start) {\n            ++temp;\n        }\n        else {\n            break;\n        }\n    }\n    return temp;\n}\n\nvoid solve() {\n    cin>>n;\n    vector<Interval> time;\n    int start, finish;\n    for (int i = 1; i <= n; ++i) {\n        cin>>start>>finish;\n        time.push_back({start,finish});\n    }\n    cout<<dep(time)<<endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# 1012-Luxury cruise ship\n\n来源: 杭电杯超级联赛2\n算法: 动态规划\n题目链接: https://acm.hdu.edu.cn/showproblem.php?pid=7161\n补完: Yes\n完成时间: August 26, 2022\n\n## 题解\n\n每天可以存$7/31/365$个硬币, 直到攒够$N$个硬币可以买游艇, 问最少要多少天恰好攒够. \n\n每天攒得越多越则天数可以越少, 但是$7/31/365$三者互质, 不能相互取代. 但当$N>7*31*365$时, 就可以考虑优先攒$7*31$个$365$. 剩余的部分用完全背包处理.\n\n设$dp[i]$为攒$i$个硬币所花最少天数, 有:\n\n$$\ndp[i] = \\min(dp[i],dp[i-7/31/365]+1)\n$$\n\n初始有\n\n$$\ndp[0]= 0\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAXN = 7*31*365;\nint c[3] = {7,31,365};\nint dp[MAXN+5];\n\nvoid init() {\n    for (int i = 0; i <= MAXN; ++i) {\n        dp[i] = 1e18;\n    }\n    dp[0] = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = c[i]; j <= MAXN; ++j) {\n            dp[j] = min(dp[j],dp[j-c[i]]+1);\n        }\n    }\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    int ans = 0;\n    if (n>=MAXN) {\n        ans += n/MAXN*7*31;\n        n %= MAXN;\n    }\n    if (dp[n]!=1e18) {\n        cout<<ans + dp[n]<<endl;\n    }\n    else {\n        cout<<\"-1\"<<endl;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    init();\n    int T = 1;\n    cin>>T;// 无多组数据注释这一行\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛02.md","raw":"---\ntitle: 2022杭电杯超级联赛02\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1002-C++ to Python\n\n来源: 杭电杯超级联赛2\n算法: 字符串, 语法\n补完: Yes\n完成时间: July 31, 2022\n\n## 题解\n\n去除字母下划线冒号, 保留数字逗号和括号即可\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nvoid solve(){\n    string a;\n    cin>>a;\n    int len=a.length();\n    for(int i=0;i<len;i++)\n        if(!isalpha(a[i])&&(a[i]!='_')&&(a[i]!=':'))\n            printf(\"%c\",a[i]);\n    printf(\"\\n\");\n}\nint main(){\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# 1007-Snatch Groceries\n\n来源: 杭电杯超级联赛2\n算法: 贪心\n补完: Yes\n完成时间: August 24, 2022\n\n## 题解\n\n很鸡的抢票服务器给大家提供服务, 每个人有抢到票的置信区间, 若有人同时抢票服务器就寄了, 问有多少人能抢到票. \n\n区间排序后挨个取答案, 发现时间冲突了就退出循环.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n;\n\n// 区间\nstruct Interval{\n    int start;\n    int finish;\n    bool operator<(const Interval other) const {\n        return start<other.start||(start==other.start&&finish<other.finish);\n    }\n};\n\nint dep(vector<Interval> intervals){\n    intervals.push_back({(int)1e9+10,(int)1e9+10});\n    sort(intervals.begin(),intervals.end());\n    int temp = 0;\n    for (int i = 0; i < n; ++i) {\n        if (intervals[i].finish<intervals[i+1].start) {\n            ++temp;\n        }\n        else {\n            break;\n        }\n    }\n    return temp;\n}\n\nvoid solve() {\n    cin>>n;\n    vector<Interval> time;\n    int start, finish;\n    for (int i = 1; i <= n; ++i) {\n        cin>>start>>finish;\n        time.push_back({start,finish});\n    }\n    cout<<dep(time)<<endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# 1012-Luxury cruise ship\n\n来源: 杭电杯超级联赛2\n算法: 动态规划\n题目链接: https://acm.hdu.edu.cn/showproblem.php?pid=7161\n补完: Yes\n完成时间: August 26, 2022\n\n## 题解\n\n每天可以存$7/31/365$个硬币, 直到攒够$N$个硬币可以买游艇, 问最少要多少天恰好攒够. \n\n每天攒得越多越则天数可以越少, 但是$7/31/365$三者互质, 不能相互取代. 但当$N>7*31*365$时, 就可以考虑优先攒$7*31$个$365$. 剩余的部分用完全背包处理.\n\n设$dp[i]$为攒$i$个硬币所花最少天数, 有:\n\n$$\ndp[i] = \\min(dp[i],dp[i-7/31/365]+1)\n$$\n\n初始有\n\n$$\ndp[0]= 0\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int MAXN = 7*31*365;\nint c[3] = {7,31,365};\nint dp[MAXN+5];\n\nvoid init() {\n    for (int i = 0; i <= MAXN; ++i) {\n        dp[i] = 1e18;\n    }\n    dp[0] = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = c[i]; j <= MAXN; ++j) {\n            dp[j] = min(dp[j],dp[j-c[i]]+1);\n        }\n    }\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    int ans = 0;\n    if (n>=MAXN) {\n        ans += n/MAXN*7*31;\n        n %= MAXN;\n    }\n    if (dp[n]!=1e18) {\n        cout<<ans + dp[n]<<endl;\n    }\n    else {\n        cout<<\"-1\"<<endl;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    init();\n    int T = 1;\n    cin>>T;// 无多组数据注释这一行\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022杭电杯超级联赛02","published":1,"updated":"2023-10-29T06:25:36.091Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex10001n0um09u74s8q","content":"<h1 id=\"c-to-python\">1002-C++ to Python</h1>\r\n<p>来源: 杭电杯超级联赛2 算法: 字符串, 语法 补完: Yes 完成时间: July 31,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>去除字母下划线冒号, 保留数字逗号和括号即可</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    <span class=\"type\">int</span> len=a.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"built_in\">isalpha</span>(a[i])&amp;&amp;(a[i]!=<span class=\"string\">&#x27;_&#x27;</span>)&amp;&amp;(a[i]!=<span class=\"string\">&#x27;:&#x27;</span>))</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,a[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"snatch-groceries\">1007-Snatch Groceries</h1>\r\n<p>来源: 杭电杯超级联赛2 算法: 贪心 补完: Yes 完成时间: August 24,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>很鸡的抢票服务器给大家提供服务, 每个人有抢到票的置信区间,\r\n若有人同时抢票服务器就寄了, 问有多少人能抢到票.</p>\r\n<p>区间排序后挨个取答案, 发现时间冲突了就退出循环.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 区间</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Interval</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> finish;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Interval other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start&lt;other.start||(start==other.start&amp;&amp;finish&lt;other.finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dep</span><span class=\"params\">(vector&lt;Interval&gt; intervals)</span></span>&#123;</span><br><span class=\"line\">    intervals.<span class=\"built_in\">push_back</span>(&#123;(<span class=\"type\">int</span>)<span class=\"number\">1e9</span><span class=\"number\">+10</span>,(<span class=\"type\">int</span>)<span class=\"number\">1e9</span><span class=\"number\">+10</span>&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(),intervals.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intervals[i].finish&lt;intervals[i<span class=\"number\">+1</span>].start) &#123;</span><br><span class=\"line\">            ++temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;Interval&gt; time;</span><br><span class=\"line\">    <span class=\"type\">int</span> start, finish;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;start&gt;&gt;finish;</span><br><span class=\"line\">        time.<span class=\"built_in\">push_back</span>(&#123;start,finish&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">dep</span>(time)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"luxury-cruise-ship\">1012-Luxury cruise ship</h1>\r\n<p>来源: 杭电杯超级联赛2 算法: 动态规划 题目链接:\r\nhttps://acm.hdu.edu.cn/showproblem.php?pid=7161 补完: Yes 完成时间:\r\nAugust 26, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>每天可以存<span class=\"math inline\">\\(7/31/365\\)</span>个硬币,\r\n直到攒够<span class=\"math inline\">\\(N\\)</span>个硬币可以买游艇,\r\n问最少要多少天恰好攒够.</p>\r\n<p>每天攒得越多越则天数可以越少, 但是<span\r\nclass=\"math inline\">\\(7/31/365\\)</span>三者互质, 不能相互取代. 但当<span\r\nclass=\"math inline\">\\(N&gt;7*31*365\\)</span>时, 就可以考虑优先攒<span\r\nclass=\"math inline\">\\(7*31\\)</span>个<span\r\nclass=\"math inline\">\\(365\\)</span>. 剩余的部分用完全背包处理.</p>\r\n<p>设<span class=\"math inline\">\\(dp[i]\\)</span>为攒<span\r\nclass=\"math inline\">\\(i\\)</span>个硬币所花最少天数, 有:</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i] = \\min(dp[i],dp[i-7/31/365]+1)\r\n\\]</span></p>\r\n<p>初始有</p>\r\n<p><span class=\"math display\">\\[\r\ndp[0]= 0\r\n\\]</span></p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">7</span>*<span class=\"number\">31</span>*<span class=\"number\">365</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">3</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">31</span>,<span class=\"number\">365</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dp[MAXN<span class=\"number\">+5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAXN; ++i) &#123;</span><br><span class=\"line\">        dp[i] = <span class=\"number\">1e18</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = c[i]; j &lt;= MAXN; ++j) &#123;</span><br><span class=\"line\">            dp[j] = <span class=\"built_in\">min</span>(dp[j],dp[j-c[i]]<span class=\"number\">+1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n&gt;=MAXN) &#123;</span><br><span class=\"line\">        ans += n/MAXN*<span class=\"number\">7</span>*<span class=\"number\">31</span>;</span><br><span class=\"line\">        n %= MAXN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[n]!=<span class=\"number\">1e18</span>) &#123;</span><br><span class=\"line\">        cout&lt;&lt;ans + dp[n]&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;<span class=\"comment\">// 无多组数据注释这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"c-to-python\">1002-C++ to Python</h1>\r\n<p>来源: 杭电杯超级联赛2 算法: 字符串, 语法 补完: Yes 完成时间: July 31,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>去除字母下划线冒号, 保留数字逗号和括号即可</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    <span class=\"type\">int</span> len=a.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"built_in\">isalpha</span>(a[i])&amp;&amp;(a[i]!=<span class=\"string\">&#x27;_&#x27;</span>)&amp;&amp;(a[i]!=<span class=\"string\">&#x27;:&#x27;</span>))</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,a[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"snatch-groceries\">1007-Snatch Groceries</h1>\r\n<p>来源: 杭电杯超级联赛2 算法: 贪心 补完: Yes 完成时间: August 24,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>很鸡的抢票服务器给大家提供服务, 每个人有抢到票的置信区间,\r\n若有人同时抢票服务器就寄了, 问有多少人能抢到票.</p>\r\n<p>区间排序后挨个取答案, 发现时间冲突了就退出循环.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 区间</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Interval</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> finish;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Interval other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start&lt;other.start||(start==other.start&amp;&amp;finish&lt;other.finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dep</span><span class=\"params\">(vector&lt;Interval&gt; intervals)</span></span>&#123;</span><br><span class=\"line\">    intervals.<span class=\"built_in\">push_back</span>(&#123;(<span class=\"type\">int</span>)<span class=\"number\">1e9</span><span class=\"number\">+10</span>,(<span class=\"type\">int</span>)<span class=\"number\">1e9</span><span class=\"number\">+10</span>&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(),intervals.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intervals[i].finish&lt;intervals[i<span class=\"number\">+1</span>].start) &#123;</span><br><span class=\"line\">            ++temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;Interval&gt; time;</span><br><span class=\"line\">    <span class=\"type\">int</span> start, finish;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;start&gt;&gt;finish;</span><br><span class=\"line\">        time.<span class=\"built_in\">push_back</span>(&#123;start,finish&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">dep</span>(time)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"luxury-cruise-ship\">1012-Luxury cruise ship</h1>\r\n<p>来源: 杭电杯超级联赛2 算法: 动态规划 题目链接:\r\nhttps://acm.hdu.edu.cn/showproblem.php?pid=7161 补完: Yes 完成时间:\r\nAugust 26, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>每天可以存<span class=\"math inline\">\\(7/31/365\\)</span>个硬币,\r\n直到攒够<span class=\"math inline\">\\(N\\)</span>个硬币可以买游艇,\r\n问最少要多少天恰好攒够.</p>\r\n<p>每天攒得越多越则天数可以越少, 但是<span\r\nclass=\"math inline\">\\(7/31/365\\)</span>三者互质, 不能相互取代. 但当<span\r\nclass=\"math inline\">\\(N&gt;7*31*365\\)</span>时, 就可以考虑优先攒<span\r\nclass=\"math inline\">\\(7*31\\)</span>个<span\r\nclass=\"math inline\">\\(365\\)</span>. 剩余的部分用完全背包处理.</p>\r\n<p>设<span class=\"math inline\">\\(dp[i]\\)</span>为攒<span\r\nclass=\"math inline\">\\(i\\)</span>个硬币所花最少天数, 有:</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i] = \\min(dp[i],dp[i-7/31/365]+1)\r\n\\]</span></p>\r\n<p>初始有</p>\r\n<p><span class=\"math display\">\\[\r\ndp[0]= 0\r\n\\]</span></p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">7</span>*<span class=\"number\">31</span>*<span class=\"number\">365</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">3</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">31</span>,<span class=\"number\">365</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dp[MAXN<span class=\"number\">+5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAXN; ++i) &#123;</span><br><span class=\"line\">        dp[i] = <span class=\"number\">1e18</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = c[i]; j &lt;= MAXN; ++j) &#123;</span><br><span class=\"line\">            dp[j] = <span class=\"built_in\">min</span>(dp[j],dp[j-c[i]]<span class=\"number\">+1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n&gt;=MAXN) &#123;</span><br><span class=\"line\">        ans += n/MAXN*<span class=\"number\">7</span>*<span class=\"number\">31</span>;</span><br><span class=\"line\">        n %= MAXN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dp[n]!=<span class=\"number\">1e18</span>) &#123;</span><br><span class=\"line\">        cout&lt;&lt;ans + dp[n]&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;<span class=\"comment\">// 无多组数据注释这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛03","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1003-Cyber Language\n\n来源: 杭电杯超级联赛3\n算法: 字符串\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1046&pid=1003\n补完: Yes\n完成时间: August 24, 2022\n\n## 题解\n\n只保留首字母大写的~~抽象语言~~赛博语言, 直接转化. \n\n读完数据组数之后还有换行记得读掉. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nstring a;\nvoid solve(){\n    getline(cin,a);\n    for(int i=0;i<a.length();i++){\n        if(i==0 || a[i-1]==' ')\n         printf(\"%c\",a[i]-32);\n    }\n    printf(\"\\n\");\n}\nint main(){\n    scanf(\"%d\",&T);\n    getline(cin,a);\n    while(T--)solve();\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛03.md","raw":"---\ntitle: 2022杭电杯超级联赛03\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1003-Cyber Language\n\n来源: 杭电杯超级联赛3\n算法: 字符串\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1046&pid=1003\n补完: Yes\n完成时间: August 24, 2022\n\n## 题解\n\n只保留首字母大写的~~抽象语言~~赛博语言, 直接转化. \n\n读完数据组数之后还有换行记得读掉. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nstring a;\nvoid solve(){\n    getline(cin,a);\n    for(int i=0;i<a.length();i++){\n        if(i==0 || a[i-1]==' ')\n         printf(\"%c\",a[i]-32);\n    }\n    printf(\"\\n\");\n}\nint main(){\n    scanf(\"%d\",&T);\n    getline(cin,a);\n    while(T--)solve();\n    return 0;\n}\n```\n","slug":"2022杭电杯超级联赛03","published":1,"updated":"2023-10-29T06:16:29.755Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex30002n0um8jlxhjqc","content":"<h1 id=\"cyber-language\">1003-Cyber Language</h1>\r\n<p>来源: 杭电杯超级联赛3 算法: 字符串 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1046&amp;pid=1003 补完: Yes\r\n完成时间: August 24, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>只保留首字母大写的<del>抽象语言</del>赛博语言, 直接转化.</p>\r\n<p>读完数据组数之后还有换行记得读掉.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\">string a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin,a);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">length</span>();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span> || a[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,a[i]<span class=\"number\">-32</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin,a);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"cyber-language\">1003-Cyber Language</h1>\r\n<p>来源: 杭电杯超级联赛3 算法: 字符串 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1046&amp;pid=1003 补完: Yes\r\n完成时间: August 24, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>只保留首字母大写的<del>抽象语言</del>赛博语言, 直接转化.</p>\r\n<p>读完数据组数之后还有换行记得读掉.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\">string a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin,a);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;a.<span class=\"built_in\">length</span>();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span> || a[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,a[i]<span class=\"number\">-32</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin,a);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛04","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1004-Link with Equilateral Triangle\n\n来源: 杭电杯超级联赛4\n算法: 图形规律\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1004\n补完: Yes\n完成时间: August 12, 2022\n\n题目链接\n\n## 题意简述\n\n给一个边长为n的大等边三角形，它被分割为边长为1的小等边三角形。\n\n在小三角形顶点上填充数字，只能填0，1，2；并且在大三角形的左边界不能填0，右边界不能填1，下边界不能填2。并且要求小三角形三个顶点上的数字不是3的倍数。\n\n问能否找到满足条件的方案。\n\n## 题目分析\n\n开场就过这么多人，样例还是不满足，模拟了两个三角形找不到方案，那这不得交一发输出No吗？\n\n~~过了，本题解到此结束。~~\n\n开玩笑的，不严格证明还是要放一点的。\n\n首先，由于小三角形顶点和要满足不是3的倍数，我们先枚举0，1，2的组合可能，选取合法组合：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled.png)\n\n也就是一种数字1个，另一个种数字2个的组合是可行的。\n\n接着，由于各个边均有限制，那么大三角形的节点必然是固定的。如图。\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%201.png)\n\n那么我们从左下顶点1开始填数字。由于两边一个不能填0，一个不能填2，把1作为那个只有一个的数字是不可行的，只能在其中一边填上1，另一边是对应的没被限制的0或者2，这里以1，0选择为例，由于图形对称，另一种选择与本选择同理。则有：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%202.png)\n\n这样向右又有一个小三角形两顶点已知（1和0）可以填入0或1。\n\n并且，由于大三角形左边界不能填0，如果这个三角形也填1，边界只能是2。\n\n也就是有两种情况：\n\n①边界填1，小三角形填0：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%203.png)\n\n②边界填2，小三角形填1：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%204.png)\n\n对于①，左下平行左边界的小三角形边已知两个点都是0，下边界不能填2，那么这个三角形贴下边界的点只能是1。而再下一个三角形两个顶点是1和0，第三个顶点就只能是1或者0。这个三角形如果是1，1，第三个顶点只能是0，如果是1，0，第三个顶点只能是1或者0。\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%205.png)\n\n这使得整串顶点都是1或者0。而且每一个看似自由的1/0选择都定死了另一个点的选择：比如上图中第一个0/1，选择0则固定了上方顶点必然为1，选择1则固定了下方顶点必然为0.\n\n到右边界的时候，由于右下顶点是0，右边界不能为1，所以只有两种情况：右边界填2，下边界填0；右边界填0，下边界填1。\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%206.png)\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%207.png)\n\n而这个选择看着是自由选择的，实际上会锁定上方或者下方的数字。而另一侧已经被角落的1固定了一部分，所以下侧的01选择会根据最下层三角形的数量而固定。\n\n而右侧要么会一直是0，要么中途借着边界的一个0和左边一个节点0把侧边修改成2.左侧同理，要么一直是1，要么需要借着右边也来一个1，把下一个节点修改成2.\n\n到了最上面的节点，冲突就会出现：如果右侧的数字是2，左侧只能是1.\n\n左右如果都没在这里发生变化，那么中间的数字一定是0：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%208.png)\n\n1，2，0同时出现，情况非法。\n\n如果1下一个位置是2，那么中间只能是1。又由于底下的数字限制了中间上方会出现的都是0和1（如果让2出现相当于是从2节点之类的开始的另外的对称情况），当中间是1，那么要么在右侧0和2置换的时候出现0，1，2的三角形，要么在两侧都是2的情况下出现1，1，1的三角形。\n\n具体的情况可以手动模拟一下，总之，三个节点三条边之间的限制让不合法组合的冲突无法避免，每一步暂时的维稳只能把僵局往一个方向推动，必然在一个小三角形的位置产生限制冲突且无法解决。\n\n## 不完整代码\n\n```cpp\ncout<<\"No\";\n```\n# 1006-BIT Subway\n\n来源: 杭电杯超级联赛4\n算法: 模拟, 语法\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1006\n补完: Yes\n完成时间: July 31, 2022\n\n## 题解\n\nDlee的理解是超过100元的钱打八折, 超过200元的钱打五折\n\n也就是超过100元的花费0.8元值1元, 在100~200区间就是100元值125元.\n\n真实运行是当已购票价超过100元后再买的票才打八折, 已购票价超过200元后再买的票才打五折.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,n;\nvoid solve(){\n    double DLee_ans=0,True_ans=0;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        double ticket;\n        scanf(\"%lf\",&ticket);\n        DLee_ans+=ticket;\n        if(True_ans>=200){\n            True_ans+=ticket*0.5;\n        }\n        else if(True_ans>=100){\n            True_ans+=ticket*0.8;\n        }\n        else {\n            True_ans+=ticket;\n        }\n    }\n    if(DLee_ans>=225)DLee_ans = (DLee_ans-225)*0.5+200;\n    else if(DLee_ans>=100)DLee_ans = (DLee_ans-100)*0.8+100;\n    printf(\"%.3lf %.3lf\\n\",DLee_ans,True_ans);\n}\nint main(){\n    scanf(\"%d\",&T);\n    while(T--)solve();\n    return 0;\n}\n```\n# 1007 Climb Stairs\n\n来源: 杭电杯超级联赛4\n算法: 区间和维护, 贪心\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1007\n补完: Yes\n完成时间: August 1, 2022\n\n## 题意简述\n\n有n级楼梯，每个楼梯上有一个怪物，每个怪物有一个生命值$a_i$。（为与攻击力区分，后文用$hp_i$表示）\n\n主角一开始在地面，可以当作第0级楼梯。主角有初始攻击力$a_0$。\n\n每次主角可以向上跳跃$k$级以内的楼梯，即第一步可以到达1~k层；或者向下走一级楼梯。走过的楼梯不可以再走。\n\n他只能去打得过的怪物在的楼梯。当怪物的生命值不超过他的攻击力他就打得过。打完怪物他的攻击力会加上怪物的生命值。\n\n问是否可以打完所有怪物。\n\n## 题目分析\n\n////\n\n首先，由于走楼梯的方法是向上可以跳，但向下只能一步一步走，那么要打完所有怪物，意味着每次从i级楼梯向上跳跃之后必须一步一步走回来，直到把$i+1$级上的怪物也打完，否则之后没有机会再回到被跳过的这一段了。\n\n也就是说，在跳跃能力$k$之内，只有跳跃后能逆着把这整段怪物依次打败的楼梯才能选择。如果没有选择了，就无法行动了。\n\n////\n\n那么，如果在跳跃范围内有多个点可以选择，选谁呢？\n\n我们思考一下跳跃后扫完整段的怪物后是什么情况：假设我们从i级开始跳，跳到$j$，扫完之后我们人在i+1级，由于达到过的地方不能再去，下一次跳跃选择范围是$[j+1，i+1+k]$。\n\n可以发现，下次的选择范围的最高点是固定的，最低点受到这次跳跃的影响。这次跳跃的越远，j越大，下次的选择范围就越小。\n\n所以既然有多个选择，我们应该选择距离较近的那个，也就是让j尽可能小。因为怪物的血量分布是没有规律的，选择范围越小，就越可能打不过范围内的怪物。\n\n也许你会说，向下扩展的范围是较高点那个选择本来就能打得过的，该吃的血条不都吃干净了吗？\n\n但是，留出这个扩展范围做选择，不仅是让这次跳跃变得可能继续，也让最后的落点在更高的位置，也就是完成一次跳跃之后，新的i出现了，这让再下一次的跳跃范围的最高点，新的$i_a+1+k$，比直接跳到更高层的，和跳到更低层一样的，旧的$i_b+1+k$，更高得多，获取了更多可能存在的怪物跳板——毕竟打一个小怪也能让自己的攻击力提升。\n\n////\n\n最后，怎么判断这个位置能不能跳，也就是能不能顺着这个位置把中间的怪物打个干净呢？\n\n对于一个位置在$l$的怪物，跳到$r$点回来攻击它的时候的攻击力是：\n\n跳跃前的攻击力$a$+从$r$点杀到$l+1$点多获得的攻击力$\\sum_{i=l+1}^{r} hp_i$\n\n这个数值大于当前怪物的$hp_l$即可。\n\n那么最先被想到的可能是前缀和，它可以方便地查找这样的区间和。但这意味着每次尝试跳跃的时候，都要在跳跃区间进行一次区间和的查询，总体的效率会接近$O（n^2)$ ，这个时间复杂度是不被允许的。~~（AC之后交了一发试试果然TLE了）~~\n\n////\n\n我们换个思路考虑。先从最小规模的问题开始：如果是判断落点j的前一个位置能不能下楼击杀呢？那么可行条件就是$hp_{j-1} ≤ a+hp_j$ \n\n对于当前攻击力$a$来说，就是$a≥hp_{j-1}-hp_j$\n\n再往下一个，即为$hp_{j-2}≤a+hp_j+hp_{j-1}$\n\n化为$a≥hp_{j-2}-hp_j-hp_{j-1}$ \n\n以此类推，对每个$l$来说，从跃点$j$回头击杀i位置怪物的条件就是：\n\n$a>=hp_l-\\sum_{i=l+1}^jhp_i$\n\n~~这不就刚那式子换个位置吗~~\n\n确实，确实。\n\n但其实思路里没化简的累减部分正是替代前缀和的关键。\n\n并且，归纳到整段对a的影响，也就是a要≥所有跳跃范围中累计出来的最大值。\n\n这意味着我们顺着楼梯上去的方向跑，就可以一边累减一边维护这个$a$要对比的值，记作$cmp$。当前攻击$a$大于这个楼梯上怪物的$hp$，且大于这个比较值，就说明$a$可以击败这个楼梯上的怪物并把越过的怪物回去一锅端了。如果打不了，那可以把这个楼梯上的小玩意也抓去累减，指望后面的怪物的血条贡献的攻击力可以补救它。\n\n我们使用一个变量$lever$记录我们已经干碎了的怪物的范围，每次合法的跃点就是这个范围的最新上界。再使用一个变量$stp$记录当前跳跃前踩的楼梯，每次跳跃由于要回头收割，跳跃前的楼梯一定只能是当前的再走上去一级。$stp+k$就是能达到的最远楼梯。超过这个范围还找不到能跳跃的点，怪物猎杀就宣告失败了。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nint hp[100010];\nlong long s[100010];\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,a0,k;\n\t\tcin>>n>>a0>>k;\n\t\tlong long a=a0;\n\t\tlong long cmp=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>hp[i];\n\t\t\ts[i]=s[i-1]+hp[i];\n\t\t}\n\t\tint stp=0;//当前位置\n\t\tint lever=0;//收割范围 \n\t\tfor(int i=1;i<=n&&i-stp<=k;i++){\n\t\t\tif(a>=hp[i]&&a>=cmp){\n\t\t\t\ta+=s[i]-s[lever];\n\t\t\t\tlever=i;\n\t\t\t\tstp++;//回头收割方式 步伐只能前进1\n\t\t\t\tcmp=0; \n\t\t\t}\n\t\t\telse{\n\t\t\t\tcmp=max((long long) (hp[i]-hp[i+1]),(long long)(cmp-hp[i+1]));\n\t\t\t} \n\t\t}\n\t\tif(lever==n)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}\n```\n# 1011-Link is as bear\n\n来源: 杭电杯超级联赛4\n算法: 数论, 线性基\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1011\n补完: Yes\n完成时间: July 28, 2022\n\n## 题解\n\n题目给操作: 任取子序列赋值为全体异或和. 要求全体最大异或和. \n\n等价于给$n$个数, 求其中任选某些数的最大异或和. \n\n用线性基解决. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint T,n;\nll a,ans;\nvector<ll> Base;\nvoid insert(ll x) {\n    for(auto b : Base)\n        x = min(x,b^x);\n    for(auto &b : Base)\n        b = min(b,b^x);\n    if(x)\n        Base.push_back(x);\n}\nvoid solve(){\n    ans = 0;\n    Base.clear();\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a;\n        insert(a);\n    }\n    for(auto x : Base){\n        ans ^= x;\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛04.md","raw":"---\ntitle: 2022杭电杯超级联赛04\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1004-Link with Equilateral Triangle\n\n来源: 杭电杯超级联赛4\n算法: 图形规律\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1004\n补完: Yes\n完成时间: August 12, 2022\n\n题目链接\n\n## 题意简述\n\n给一个边长为n的大等边三角形，它被分割为边长为1的小等边三角形。\n\n在小三角形顶点上填充数字，只能填0，1，2；并且在大三角形的左边界不能填0，右边界不能填1，下边界不能填2。并且要求小三角形三个顶点上的数字不是3的倍数。\n\n问能否找到满足条件的方案。\n\n## 题目分析\n\n开场就过这么多人，样例还是不满足，模拟了两个三角形找不到方案，那这不得交一发输出No吗？\n\n~~过了，本题解到此结束。~~\n\n开玩笑的，不严格证明还是要放一点的。\n\n首先，由于小三角形顶点和要满足不是3的倍数，我们先枚举0，1，2的组合可能，选取合法组合：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled.png)\n\n也就是一种数字1个，另一个种数字2个的组合是可行的。\n\n接着，由于各个边均有限制，那么大三角形的节点必然是固定的。如图。\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%201.png)\n\n那么我们从左下顶点1开始填数字。由于两边一个不能填0，一个不能填2，把1作为那个只有一个的数字是不可行的，只能在其中一边填上1，另一边是对应的没被限制的0或者2，这里以1，0选择为例，由于图形对称，另一种选择与本选择同理。则有：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%202.png)\n\n这样向右又有一个小三角形两顶点已知（1和0）可以填入0或1。\n\n并且，由于大三角形左边界不能填0，如果这个三角形也填1，边界只能是2。\n\n也就是有两种情况：\n\n①边界填1，小三角形填0：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%203.png)\n\n②边界填2，小三角形填1：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%204.png)\n\n对于①，左下平行左边界的小三角形边已知两个点都是0，下边界不能填2，那么这个三角形贴下边界的点只能是1。而再下一个三角形两个顶点是1和0，第三个顶点就只能是1或者0。这个三角形如果是1，1，第三个顶点只能是0，如果是1，0，第三个顶点只能是1或者0。\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%205.png)\n\n这使得整串顶点都是1或者0。而且每一个看似自由的1/0选择都定死了另一个点的选择：比如上图中第一个0/1，选择0则固定了上方顶点必然为1，选择1则固定了下方顶点必然为0.\n\n到右边界的时候，由于右下顶点是0，右边界不能为1，所以只有两种情况：右边界填2，下边界填0；右边界填0，下边界填1。\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%206.png)\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%207.png)\n\n而这个选择看着是自由选择的，实际上会锁定上方或者下方的数字。而另一侧已经被角落的1固定了一部分，所以下侧的01选择会根据最下层三角形的数量而固定。\n\n而右侧要么会一直是0，要么中途借着边界的一个0和左边一个节点0把侧边修改成2.左侧同理，要么一直是1，要么需要借着右边也来一个1，把下一个节点修改成2.\n\n到了最上面的节点，冲突就会出现：如果右侧的数字是2，左侧只能是1.\n\n左右如果都没在这里发生变化，那么中间的数字一定是0：\n\n![Untitled](1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%208.png)\n\n1，2，0同时出现，情况非法。\n\n如果1下一个位置是2，那么中间只能是1。又由于底下的数字限制了中间上方会出现的都是0和1（如果让2出现相当于是从2节点之类的开始的另外的对称情况），当中间是1，那么要么在右侧0和2置换的时候出现0，1，2的三角形，要么在两侧都是2的情况下出现1，1，1的三角形。\n\n具体的情况可以手动模拟一下，总之，三个节点三条边之间的限制让不合法组合的冲突无法避免，每一步暂时的维稳只能把僵局往一个方向推动，必然在一个小三角形的位置产生限制冲突且无法解决。\n\n## 不完整代码\n\n```cpp\ncout<<\"No\";\n```\n# 1006-BIT Subway\n\n来源: 杭电杯超级联赛4\n算法: 模拟, 语法\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1006\n补完: Yes\n完成时间: July 31, 2022\n\n## 题解\n\nDlee的理解是超过100元的钱打八折, 超过200元的钱打五折\n\n也就是超过100元的花费0.8元值1元, 在100~200区间就是100元值125元.\n\n真实运行是当已购票价超过100元后再买的票才打八折, 已购票价超过200元后再买的票才打五折.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,n;\nvoid solve(){\n    double DLee_ans=0,True_ans=0;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        double ticket;\n        scanf(\"%lf\",&ticket);\n        DLee_ans+=ticket;\n        if(True_ans>=200){\n            True_ans+=ticket*0.5;\n        }\n        else if(True_ans>=100){\n            True_ans+=ticket*0.8;\n        }\n        else {\n            True_ans+=ticket;\n        }\n    }\n    if(DLee_ans>=225)DLee_ans = (DLee_ans-225)*0.5+200;\n    else if(DLee_ans>=100)DLee_ans = (DLee_ans-100)*0.8+100;\n    printf(\"%.3lf %.3lf\\n\",DLee_ans,True_ans);\n}\nint main(){\n    scanf(\"%d\",&T);\n    while(T--)solve();\n    return 0;\n}\n```\n# 1007 Climb Stairs\n\n来源: 杭电杯超级联赛4\n算法: 区间和维护, 贪心\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1007\n补完: Yes\n完成时间: August 1, 2022\n\n## 题意简述\n\n有n级楼梯，每个楼梯上有一个怪物，每个怪物有一个生命值$a_i$。（为与攻击力区分，后文用$hp_i$表示）\n\n主角一开始在地面，可以当作第0级楼梯。主角有初始攻击力$a_0$。\n\n每次主角可以向上跳跃$k$级以内的楼梯，即第一步可以到达1~k层；或者向下走一级楼梯。走过的楼梯不可以再走。\n\n他只能去打得过的怪物在的楼梯。当怪物的生命值不超过他的攻击力他就打得过。打完怪物他的攻击力会加上怪物的生命值。\n\n问是否可以打完所有怪物。\n\n## 题目分析\n\n////\n\n首先，由于走楼梯的方法是向上可以跳，但向下只能一步一步走，那么要打完所有怪物，意味着每次从i级楼梯向上跳跃之后必须一步一步走回来，直到把$i+1$级上的怪物也打完，否则之后没有机会再回到被跳过的这一段了。\n\n也就是说，在跳跃能力$k$之内，只有跳跃后能逆着把这整段怪物依次打败的楼梯才能选择。如果没有选择了，就无法行动了。\n\n////\n\n那么，如果在跳跃范围内有多个点可以选择，选谁呢？\n\n我们思考一下跳跃后扫完整段的怪物后是什么情况：假设我们从i级开始跳，跳到$j$，扫完之后我们人在i+1级，由于达到过的地方不能再去，下一次跳跃选择范围是$[j+1，i+1+k]$。\n\n可以发现，下次的选择范围的最高点是固定的，最低点受到这次跳跃的影响。这次跳跃的越远，j越大，下次的选择范围就越小。\n\n所以既然有多个选择，我们应该选择距离较近的那个，也就是让j尽可能小。因为怪物的血量分布是没有规律的，选择范围越小，就越可能打不过范围内的怪物。\n\n也许你会说，向下扩展的范围是较高点那个选择本来就能打得过的，该吃的血条不都吃干净了吗？\n\n但是，留出这个扩展范围做选择，不仅是让这次跳跃变得可能继续，也让最后的落点在更高的位置，也就是完成一次跳跃之后，新的i出现了，这让再下一次的跳跃范围的最高点，新的$i_a+1+k$，比直接跳到更高层的，和跳到更低层一样的，旧的$i_b+1+k$，更高得多，获取了更多可能存在的怪物跳板——毕竟打一个小怪也能让自己的攻击力提升。\n\n////\n\n最后，怎么判断这个位置能不能跳，也就是能不能顺着这个位置把中间的怪物打个干净呢？\n\n对于一个位置在$l$的怪物，跳到$r$点回来攻击它的时候的攻击力是：\n\n跳跃前的攻击力$a$+从$r$点杀到$l+1$点多获得的攻击力$\\sum_{i=l+1}^{r} hp_i$\n\n这个数值大于当前怪物的$hp_l$即可。\n\n那么最先被想到的可能是前缀和，它可以方便地查找这样的区间和。但这意味着每次尝试跳跃的时候，都要在跳跃区间进行一次区间和的查询，总体的效率会接近$O（n^2)$ ，这个时间复杂度是不被允许的。~~（AC之后交了一发试试果然TLE了）~~\n\n////\n\n我们换个思路考虑。先从最小规模的问题开始：如果是判断落点j的前一个位置能不能下楼击杀呢？那么可行条件就是$hp_{j-1} ≤ a+hp_j$ \n\n对于当前攻击力$a$来说，就是$a≥hp_{j-1}-hp_j$\n\n再往下一个，即为$hp_{j-2}≤a+hp_j+hp_{j-1}$\n\n化为$a≥hp_{j-2}-hp_j-hp_{j-1}$ \n\n以此类推，对每个$l$来说，从跃点$j$回头击杀i位置怪物的条件就是：\n\n$a>=hp_l-\\sum_{i=l+1}^jhp_i$\n\n~~这不就刚那式子换个位置吗~~\n\n确实，确实。\n\n但其实思路里没化简的累减部分正是替代前缀和的关键。\n\n并且，归纳到整段对a的影响，也就是a要≥所有跳跃范围中累计出来的最大值。\n\n这意味着我们顺着楼梯上去的方向跑，就可以一边累减一边维护这个$a$要对比的值，记作$cmp$。当前攻击$a$大于这个楼梯上怪物的$hp$，且大于这个比较值，就说明$a$可以击败这个楼梯上的怪物并把越过的怪物回去一锅端了。如果打不了，那可以把这个楼梯上的小玩意也抓去累减，指望后面的怪物的血条贡献的攻击力可以补救它。\n\n我们使用一个变量$lever$记录我们已经干碎了的怪物的范围，每次合法的跃点就是这个范围的最新上界。再使用一个变量$stp$记录当前跳跃前踩的楼梯，每次跳跃由于要回头收割，跳跃前的楼梯一定只能是当前的再走上去一级。$stp+k$就是能达到的最远楼梯。超过这个范围还找不到能跳跃的点，怪物猎杀就宣告失败了。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nint hp[100010];\nlong long s[100010];\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,a0,k;\n\t\tcin>>n>>a0>>k;\n\t\tlong long a=a0;\n\t\tlong long cmp=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>hp[i];\n\t\t\ts[i]=s[i-1]+hp[i];\n\t\t}\n\t\tint stp=0;//当前位置\n\t\tint lever=0;//收割范围 \n\t\tfor(int i=1;i<=n&&i-stp<=k;i++){\n\t\t\tif(a>=hp[i]&&a>=cmp){\n\t\t\t\ta+=s[i]-s[lever];\n\t\t\t\tlever=i;\n\t\t\t\tstp++;//回头收割方式 步伐只能前进1\n\t\t\t\tcmp=0; \n\t\t\t}\n\t\t\telse{\n\t\t\t\tcmp=max((long long) (hp[i]-hp[i+1]),(long long)(cmp-hp[i+1]));\n\t\t\t} \n\t\t}\n\t\tif(lever==n)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}\n```\n# 1011-Link is as bear\n\n来源: 杭电杯超级联赛4\n算法: 数论, 线性基\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1047&pid=1011\n补完: Yes\n完成时间: July 28, 2022\n\n## 题解\n\n题目给操作: 任取子序列赋值为全体异或和. 要求全体最大异或和. \n\n等价于给$n$个数, 求其中任选某些数的最大异或和. \n\n用线性基解决. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint T,n;\nll a,ans;\nvector<ll> Base;\nvoid insert(ll x) {\n    for(auto b : Base)\n        x = min(x,b^x);\n    for(auto &b : Base)\n        b = min(b,b^x);\n    if(x)\n        Base.push_back(x);\n}\nvoid solve(){\n    ans = 0;\n    Base.clear();\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a;\n        insert(a);\n    }\n    for(auto x : Base){\n        ans ^= x;\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","slug":"2022杭电杯超级联赛04","published":1,"updated":"2023-10-29T06:24:10.138Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex40003n0umf3k3e5xz","content":"<h1 id=\"link-with-equilateral-triangle\">1004-Link with Equilateral\r\nTriangle</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 图形规律 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1004 补完: Yes\r\n完成时间: August 12, 2022</p>\r\n<p>题目链接</p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给一个边长为n的大等边三角形，它被分割为边长为1的小等边三角形。</p>\r\n<p>在小三角形顶点上填充数字，只能填0，1，2；并且在大三角形的左边界不能填0，右边界不能填1，下边界不能填2。并且要求小三角形三个顶点上的数字不是3的倍数。</p>\r\n<p>问能否找到满足条件的方案。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>开场就过这么多人，样例还是不满足，模拟了两个三角形找不到方案，那这不得交一发输出No吗？</p>\r\n<p><del>过了，本题解到此结束。</del></p>\r\n<p>开玩笑的，不严格证明还是要放一点的。</p>\r\n<p>首先，由于小三角形顶点和要满足不是3的倍数，我们先枚举0，1，2的组合可能，选取合法组合：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>也就是一种数字1个，另一个种数字2个的组合是可行的。</p>\r\n<p>接着，由于各个边均有限制，那么大三角形的节点必然是固定的。如图。</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>那么我们从左下顶点1开始填数字。由于两边一个不能填0，一个不能填2，把1作为那个只有一个的数字是不可行的，只能在其中一边填上1，另一边是对应的没被限制的0或者2，这里以1，0选择为例，由于图形对称，另一种选择与本选择同理。则有：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%202.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>这样向右又有一个小三角形两顶点已知（1和0）可以填入0或1。</p>\r\n<p>并且，由于大三角形左边界不能填0，如果这个三角形也填1，边界只能是2。</p>\r\n<p>也就是有两种情况：</p>\r\n<p>①边界填1，小三角形填0：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%203.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>②边界填2，小三角形填1：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%204.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>对于①，左下平行左边界的小三角形边已知两个点都是0，下边界不能填2，那么这个三角形贴下边界的点只能是1。而再下一个三角形两个顶点是1和0，第三个顶点就只能是1或者0。这个三角形如果是1，1，第三个顶点只能是0，如果是1，0，第三个顶点只能是1或者0。</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%205.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>这使得整串顶点都是1或者0。而且每一个看似自由的1/0选择都定死了另一个点的选择：比如上图中第一个0/1，选择0则固定了上方顶点必然为1，选择1则固定了下方顶点必然为0.</p>\r\n<p>到右边界的时候，由于右下顶点是0，右边界不能为1，所以只有两种情况：右边界填2，下边界填0；右边界填0，下边界填1。</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%206.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%207.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>而这个选择看着是自由选择的，实际上会锁定上方或者下方的数字。而另一侧已经被角落的1固定了一部分，所以下侧的01选择会根据最下层三角形的数量而固定。</p>\r\n<p>而右侧要么会一直是0，要么中途借着边界的一个0和左边一个节点0把侧边修改成2.左侧同理，要么一直是1，要么需要借着右边也来一个1，把下一个节点修改成2.</p>\r\n<p>到了最上面的节点，冲突就会出现：如果右侧的数字是2，左侧只能是1.</p>\r\n<p>左右如果都没在这里发生变化，那么中间的数字一定是0：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%208.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>1，2，0同时出现，情况非法。</p>\r\n<p>如果1下一个位置是2，那么中间只能是1。又由于底下的数字限制了中间上方会出现的都是0和1（如果让2出现相当于是从2节点之类的开始的另外的对称情况），当中间是1，那么要么在右侧0和2置换的时候出现0，1，2的三角形，要么在两侧都是2的情况下出现1，1，1的三角形。</p>\r\n<p>具体的情况可以手动模拟一下，总之，三个节点三条边之间的限制让不合法组合的冲突无法避免，每一步暂时的维稳只能把僵局往一个方向推动，必然在一个小三角形的位置产生限制冲突且无法解决。</p>\r\n<h2 id=\"不完整代码\">不完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"bit-subway\">1006-BIT Subway</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 模拟, 语法 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1006 补完: Yes\r\n完成时间: July 31, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>Dlee的理解是超过100元的钱打八折, 超过200元的钱打五折</p>\r\n<p>也就是超过100元的花费0.8元值1元, 在100~200区间就是100元值125元.</p>\r\n<p>真实运行是当已购票价超过100元后再买的票才打八折,\r\n已购票价超过200元后再买的票才打五折.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T,n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> DLee_ans=<span class=\"number\">0</span>,True_ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> ticket;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf&quot;</span>,&amp;ticket);</span><br><span class=\"line\">        DLee_ans+=ticket;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(True_ans&gt;=<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">            True_ans+=ticket*<span class=\"number\">0.5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(True_ans&gt;=<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            True_ans+=ticket*<span class=\"number\">0.8</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            True_ans+=ticket;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(DLee_ans&gt;=<span class=\"number\">225</span>)DLee_ans = (DLee_ans<span class=\"number\">-225</span>)*<span class=\"number\">0.5</span><span class=\"number\">+200</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(DLee_ans&gt;=<span class=\"number\">100</span>)DLee_ans = (DLee_ans<span class=\"number\">-100</span>)*<span class=\"number\">0.8</span><span class=\"number\">+100</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.3lf %.3lf\\n&quot;</span>,DLee_ans,True_ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"climb-stairs\">1007 Climb Stairs</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 区间和维护, 贪心 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1007 补完: Yes\r\n完成时间: August 1, 2022</p>\r\n<h2 id=\"题意简述-1\">题意简述</h2>\r\n<p>有n级楼梯，每个楼梯上有一个怪物，每个怪物有一个生命值<span\r\nclass=\"math inline\">\\(a_i\\)</span>。（为与攻击力区分，后文用<span\r\nclass=\"math inline\">\\(hp_i\\)</span>表示）</p>\r\n<p>主角一开始在地面，可以当作第0级楼梯。主角有初始攻击力<span\r\nclass=\"math inline\">\\(a_0\\)</span>。</p>\r\n<p>每次主角可以向上跳跃<span\r\nclass=\"math inline\">\\(k\\)</span>级以内的楼梯，即第一步可以到达1~k层；或者向下走一级楼梯。走过的楼梯不可以再走。</p>\r\n<p>他只能去打得过的怪物在的楼梯。当怪物的生命值不超过他的攻击力他就打得过。打完怪物他的攻击力会加上怪物的生命值。</p>\r\n<p>问是否可以打完所有怪物。</p>\r\n<h2 id=\"题目分析-1\">题目分析</h2>\r\n<p>////</p>\r\n<p>首先，由于走楼梯的方法是向上可以跳，但向下只能一步一步走，那么要打完所有怪物，意味着每次从i级楼梯向上跳跃之后必须一步一步走回来，直到把<span\r\nclass=\"math inline\">\\(i+1\\)</span>级上的怪物也打完，否则之后没有机会再回到被跳过的这一段了。</p>\r\n<p>也就是说，在跳跃能力<span\r\nclass=\"math inline\">\\(k\\)</span>之内，只有跳跃后能逆着把这整段怪物依次打败的楼梯才能选择。如果没有选择了，就无法行动了。</p>\r\n<p>////</p>\r\n<p>那么，如果在跳跃范围内有多个点可以选择，选谁呢？</p>\r\n<p>我们思考一下跳跃后扫完整段的怪物后是什么情况：假设我们从i级开始跳，跳到<span\r\nclass=\"math inline\">\\(j\\)</span>，扫完之后我们人在i+1级，由于达到过的地方不能再去，下一次跳跃选择范围是<span\r\nclass=\"math inline\">\\([j+1，i+1+k]\\)</span>。</p>\r\n<p>可以发现，下次的选择范围的最高点是固定的，最低点受到这次跳跃的影响。这次跳跃的越远，j越大，下次的选择范围就越小。</p>\r\n<p>所以既然有多个选择，我们应该选择距离较近的那个，也就是让j尽可能小。因为怪物的血量分布是没有规律的，选择范围越小，就越可能打不过范围内的怪物。</p>\r\n<p>也许你会说，向下扩展的范围是较高点那个选择本来就能打得过的，该吃的血条不都吃干净了吗？</p>\r\n<p>但是，留出这个扩展范围做选择，不仅是让这次跳跃变得可能继续，也让最后的落点在更高的位置，也就是完成一次跳跃之后，新的i出现了，这让再下一次的跳跃范围的最高点，新的<span\r\nclass=\"math inline\">\\(i_a+1+k\\)</span>，比直接跳到更高层的，和跳到更低层一样的，旧的<span\r\nclass=\"math inline\">\\(i_b+1+k\\)</span>，更高得多，获取了更多可能存在的怪物跳板——毕竟打一个小怪也能让自己的攻击力提升。</p>\r\n<p>////</p>\r\n<p>最后，怎么判断这个位置能不能跳，也就是能不能顺着这个位置把中间的怪物打个干净呢？</p>\r\n<p>对于一个位置在<span class=\"math inline\">\\(l\\)</span>的怪物，跳到<span\r\nclass=\"math inline\">\\(r\\)</span>点回来攻击它的时候的攻击力是：</p>\r\n<p>跳跃前的攻击力<span class=\"math inline\">\\(a\\)</span>+从<span\r\nclass=\"math inline\">\\(r\\)</span>点杀到<span\r\nclass=\"math inline\">\\(l+1\\)</span>点多获得的攻击力<span\r\nclass=\"math inline\">\\(\\sum_{i=l+1}^{r} hp_i\\)</span></p>\r\n<p>这个数值大于当前怪物的<span\r\nclass=\"math inline\">\\(hp_l\\)</span>即可。</p>\r\n<p>那么最先被想到的可能是前缀和，它可以方便地查找这样的区间和。但这意味着每次尝试跳跃的时候，都要在跳跃区间进行一次区间和的查询，总体的效率会接近<span\r\nclass=\"math inline\">\\(O（n^2)\\)</span>\r\n，这个时间复杂度是不被允许的。<del>（AC之后交了一发试试果然TLE了）</del></p>\r\n<p>////</p>\r\n<p>我们换个思路考虑。先从最小规模的问题开始：如果是判断落点j的前一个位置能不能下楼击杀呢？那么可行条件就是<span\r\nclass=\"math inline\">\\(hp_{j-1} ≤ a+hp_j\\)</span></p>\r\n<p>对于当前攻击力<span class=\"math inline\">\\(a\\)</span>来说，就是<span\r\nclass=\"math inline\">\\(a≥hp_{j-1}-hp_j\\)</span></p>\r\n<p>再往下一个，即为<span\r\nclass=\"math inline\">\\(hp_{j-2}≤a+hp_j+hp_{j-1}\\)</span></p>\r\n<p>化为<span class=\"math inline\">\\(a≥hp_{j-2}-hp_j-hp_{j-1}\\)</span></p>\r\n<p>以此类推，对每个<span\r\nclass=\"math inline\">\\(l\\)</span>来说，从跃点<span\r\nclass=\"math inline\">\\(j\\)</span>回头击杀i位置怪物的条件就是：</p>\r\n<p><span\r\nclass=\"math inline\">\\(a&gt;=hp_l-\\sum_{i=l+1}^jhp_i\\)</span></p>\r\n<p><del>这不就刚那式子换个位置吗</del></p>\r\n<p>确实，确实。</p>\r\n<p>但其实思路里没化简的累减部分正是替代前缀和的关键。</p>\r\n<p>并且，归纳到整段对a的影响，也就是a要≥所有跳跃范围中累计出来的最大值。</p>\r\n<p>这意味着我们顺着楼梯上去的方向跑，就可以一边累减一边维护这个<span\r\nclass=\"math inline\">\\(a\\)</span>要对比的值，记作<span\r\nclass=\"math inline\">\\(cmp\\)</span>。当前攻击<span\r\nclass=\"math inline\">\\(a\\)</span>大于这个楼梯上怪物的<span\r\nclass=\"math inline\">\\(hp\\)</span>，且大于这个比较值，就说明<span\r\nclass=\"math inline\">\\(a\\)</span>可以击败这个楼梯上的怪物并把越过的怪物回去一锅端了。如果打不了，那可以把这个楼梯上的小玩意也抓去累减，指望后面的怪物的血条贡献的攻击力可以补救它。</p>\r\n<p>我们使用一个变量<span\r\nclass=\"math inline\">\\(lever\\)</span>记录我们已经干碎了的怪物的范围，每次合法的跃点就是这个范围的最新上界。再使用一个变量<span\r\nclass=\"math inline\">\\(stp\\)</span>记录当前跳跃前踩的楼梯，每次跳跃由于要回头收割，跳跃前的楼梯一定只能是当前的再走上去一级。<span\r\nclass=\"math inline\">\\(stp+k\\)</span>就是能达到的最远楼梯。超过这个范围还找不到能跳跃的点，怪物猎杀就宣告失败了。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> hp[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> s[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n,a0,k;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;a0&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> a=a0;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> cmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;hp[i];</span><br><span class=\"line\">\t\t\ts[i]=s[i<span class=\"number\">-1</span>]+hp[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> stp=<span class=\"number\">0</span>;<span class=\"comment\">//当前位置</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lever=<span class=\"number\">0</span>;<span class=\"comment\">//收割范围 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n&amp;&amp;i-stp&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a&gt;=hp[i]&amp;&amp;a&gt;=cmp)&#123;</span><br><span class=\"line\">\t\t\t\ta+=s[i]-s[lever];</span><br><span class=\"line\">\t\t\t\tlever=i;</span><br><span class=\"line\">\t\t\t\tstp++;<span class=\"comment\">//回头收割方式 步伐只能前进1</span></span><br><span class=\"line\">\t\t\t\tcmp=<span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tcmp=<span class=\"built_in\">max</span>((<span class=\"type\">long</span> <span class=\"type\">long</span>) (hp[i]-hp[i<span class=\"number\">+1</span>]),(<span class=\"type\">long</span> <span class=\"type\">long</span>)(cmp-hp[i<span class=\"number\">+1</span>]));</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lever==n)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"link-is-as-bear\">1011-Link is as bear</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 数论, 线性基 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1011 补完: Yes\r\n完成时间: July 28, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>题目给操作: 任取子序列赋值为全体异或和. 要求全体最大异或和.</p>\r\n<p>等价于给<span class=\"math inline\">\\(n\\)</span>个数,\r\n求其中任选某些数的最大异或和.</p>\r\n<p>用线性基解决.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T,n;</span><br><span class=\"line\">ll a,ans;</span><br><span class=\"line\">vector&lt;ll&gt; Base;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(ll x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b : Base)</span><br><span class=\"line\">        x = <span class=\"built_in\">min</span>(x,b^x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;b : Base)</span><br><span class=\"line\">        b = <span class=\"built_in\">min</span>(b,b^x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x)</span><br><span class=\"line\">        Base.<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Base.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a;</span><br><span class=\"line\">        <span class=\"built_in\">insert</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : Base)&#123;</span><br><span class=\"line\">        ans ^= x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"link-with-equilateral-triangle\">1004-Link with Equilateral\r\nTriangle</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 图形规律 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1004 补完: Yes\r\n完成时间: August 12, 2022</p>\r\n<p>题目链接</p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给一个边长为n的大等边三角形，它被分割为边长为1的小等边三角形。</p>\r\n<p>在小三角形顶点上填充数字，只能填0，1，2；并且在大三角形的左边界不能填0，右边界不能填1，下边界不能填2。并且要求小三角形三个顶点上的数字不是3的倍数。</p>\r\n<p>问能否找到满足条件的方案。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>开场就过这么多人，样例还是不满足，模拟了两个三角形找不到方案，那这不得交一发输出No吗？</p>\r\n<p><del>过了，本题解到此结束。</del></p>\r\n<p>开玩笑的，不严格证明还是要放一点的。</p>\r\n<p>首先，由于小三角形顶点和要满足不是3的倍数，我们先枚举0，1，2的组合可能，选取合法组合：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>也就是一种数字1个，另一个种数字2个的组合是可行的。</p>\r\n<p>接着，由于各个边均有限制，那么大三角形的节点必然是固定的。如图。</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>那么我们从左下顶点1开始填数字。由于两边一个不能填0，一个不能填2，把1作为那个只有一个的数字是不可行的，只能在其中一边填上1，另一边是对应的没被限制的0或者2，这里以1，0选择为例，由于图形对称，另一种选择与本选择同理。则有：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%202.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>这样向右又有一个小三角形两顶点已知（1和0）可以填入0或1。</p>\r\n<p>并且，由于大三角形左边界不能填0，如果这个三角形也填1，边界只能是2。</p>\r\n<p>也就是有两种情况：</p>\r\n<p>①边界填1，小三角形填0：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%203.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>②边界填2，小三角形填1：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%204.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>对于①，左下平行左边界的小三角形边已知两个点都是0，下边界不能填2，那么这个三角形贴下边界的点只能是1。而再下一个三角形两个顶点是1和0，第三个顶点就只能是1或者0。这个三角形如果是1，1，第三个顶点只能是0，如果是1，0，第三个顶点只能是1或者0。</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%205.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>这使得整串顶点都是1或者0。而且每一个看似自由的1/0选择都定死了另一个点的选择：比如上图中第一个0/1，选择0则固定了上方顶点必然为1，选择1则固定了下方顶点必然为0.</p>\r\n<p>到右边界的时候，由于右下顶点是0，右边界不能为1，所以只有两种情况：右边界填2，下边界填0；右边界填0，下边界填1。</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%206.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%207.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>而这个选择看着是自由选择的，实际上会锁定上方或者下方的数字。而另一侧已经被角落的1固定了一部分，所以下侧的01选择会根据最下层三角形的数量而固定。</p>\r\n<p>而右侧要么会一直是0，要么中途借着边界的一个0和左边一个节点0把侧边修改成2.左侧同理，要么一直是1，要么需要借着右边也来一个1，把下一个节点修改成2.</p>\r\n<p>到了最上面的节点，冲突就会出现：如果右侧的数字是2，左侧只能是1.</p>\r\n<p>左右如果都没在这里发生变化，那么中间的数字一定是0：</p>\r\n<figure>\r\n<img\r\nsrc=\"1004-Link%20with%20Equilateral%20Triangle%207a4c6ef8ed5049249f98471783fb730f/Untitled%208.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>1，2，0同时出现，情况非法。</p>\r\n<p>如果1下一个位置是2，那么中间只能是1。又由于底下的数字限制了中间上方会出现的都是0和1（如果让2出现相当于是从2节点之类的开始的另外的对称情况），当中间是1，那么要么在右侧0和2置换的时候出现0，1，2的三角形，要么在两侧都是2的情况下出现1，1，1的三角形。</p>\r\n<p>具体的情况可以手动模拟一下，总之，三个节点三条边之间的限制让不合法组合的冲突无法避免，每一步暂时的维稳只能把僵局往一个方向推动，必然在一个小三角形的位置产生限制冲突且无法解决。</p>\r\n<h2 id=\"不完整代码\">不完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"bit-subway\">1006-BIT Subway</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 模拟, 语法 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1006 补完: Yes\r\n完成时间: July 31, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>Dlee的理解是超过100元的钱打八折, 超过200元的钱打五折</p>\r\n<p>也就是超过100元的花费0.8元值1元, 在100~200区间就是100元值125元.</p>\r\n<p>真实运行是当已购票价超过100元后再买的票才打八折,\r\n已购票价超过200元后再买的票才打五折.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T,n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> DLee_ans=<span class=\"number\">0</span>,True_ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> ticket;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf&quot;</span>,&amp;ticket);</span><br><span class=\"line\">        DLee_ans+=ticket;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(True_ans&gt;=<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">            True_ans+=ticket*<span class=\"number\">0.5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(True_ans&gt;=<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            True_ans+=ticket*<span class=\"number\">0.8</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            True_ans+=ticket;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(DLee_ans&gt;=<span class=\"number\">225</span>)DLee_ans = (DLee_ans<span class=\"number\">-225</span>)*<span class=\"number\">0.5</span><span class=\"number\">+200</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(DLee_ans&gt;=<span class=\"number\">100</span>)DLee_ans = (DLee_ans<span class=\"number\">-100</span>)*<span class=\"number\">0.8</span><span class=\"number\">+100</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.3lf %.3lf\\n&quot;</span>,DLee_ans,True_ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"climb-stairs\">1007 Climb Stairs</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 区间和维护, 贪心 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1007 补完: Yes\r\n完成时间: August 1, 2022</p>\r\n<h2 id=\"题意简述-1\">题意简述</h2>\r\n<p>有n级楼梯，每个楼梯上有一个怪物，每个怪物有一个生命值<span\r\nclass=\"math inline\">\\(a_i\\)</span>。（为与攻击力区分，后文用<span\r\nclass=\"math inline\">\\(hp_i\\)</span>表示）</p>\r\n<p>主角一开始在地面，可以当作第0级楼梯。主角有初始攻击力<span\r\nclass=\"math inline\">\\(a_0\\)</span>。</p>\r\n<p>每次主角可以向上跳跃<span\r\nclass=\"math inline\">\\(k\\)</span>级以内的楼梯，即第一步可以到达1~k层；或者向下走一级楼梯。走过的楼梯不可以再走。</p>\r\n<p>他只能去打得过的怪物在的楼梯。当怪物的生命值不超过他的攻击力他就打得过。打完怪物他的攻击力会加上怪物的生命值。</p>\r\n<p>问是否可以打完所有怪物。</p>\r\n<h2 id=\"题目分析-1\">题目分析</h2>\r\n<p>////</p>\r\n<p>首先，由于走楼梯的方法是向上可以跳，但向下只能一步一步走，那么要打完所有怪物，意味着每次从i级楼梯向上跳跃之后必须一步一步走回来，直到把<span\r\nclass=\"math inline\">\\(i+1\\)</span>级上的怪物也打完，否则之后没有机会再回到被跳过的这一段了。</p>\r\n<p>也就是说，在跳跃能力<span\r\nclass=\"math inline\">\\(k\\)</span>之内，只有跳跃后能逆着把这整段怪物依次打败的楼梯才能选择。如果没有选择了，就无法行动了。</p>\r\n<p>////</p>\r\n<p>那么，如果在跳跃范围内有多个点可以选择，选谁呢？</p>\r\n<p>我们思考一下跳跃后扫完整段的怪物后是什么情况：假设我们从i级开始跳，跳到<span\r\nclass=\"math inline\">\\(j\\)</span>，扫完之后我们人在i+1级，由于达到过的地方不能再去，下一次跳跃选择范围是<span\r\nclass=\"math inline\">\\([j+1，i+1+k]\\)</span>。</p>\r\n<p>可以发现，下次的选择范围的最高点是固定的，最低点受到这次跳跃的影响。这次跳跃的越远，j越大，下次的选择范围就越小。</p>\r\n<p>所以既然有多个选择，我们应该选择距离较近的那个，也就是让j尽可能小。因为怪物的血量分布是没有规律的，选择范围越小，就越可能打不过范围内的怪物。</p>\r\n<p>也许你会说，向下扩展的范围是较高点那个选择本来就能打得过的，该吃的血条不都吃干净了吗？</p>\r\n<p>但是，留出这个扩展范围做选择，不仅是让这次跳跃变得可能继续，也让最后的落点在更高的位置，也就是完成一次跳跃之后，新的i出现了，这让再下一次的跳跃范围的最高点，新的<span\r\nclass=\"math inline\">\\(i_a+1+k\\)</span>，比直接跳到更高层的，和跳到更低层一样的，旧的<span\r\nclass=\"math inline\">\\(i_b+1+k\\)</span>，更高得多，获取了更多可能存在的怪物跳板——毕竟打一个小怪也能让自己的攻击力提升。</p>\r\n<p>////</p>\r\n<p>最后，怎么判断这个位置能不能跳，也就是能不能顺着这个位置把中间的怪物打个干净呢？</p>\r\n<p>对于一个位置在<span class=\"math inline\">\\(l\\)</span>的怪物，跳到<span\r\nclass=\"math inline\">\\(r\\)</span>点回来攻击它的时候的攻击力是：</p>\r\n<p>跳跃前的攻击力<span class=\"math inline\">\\(a\\)</span>+从<span\r\nclass=\"math inline\">\\(r\\)</span>点杀到<span\r\nclass=\"math inline\">\\(l+1\\)</span>点多获得的攻击力<span\r\nclass=\"math inline\">\\(\\sum_{i=l+1}^{r} hp_i\\)</span></p>\r\n<p>这个数值大于当前怪物的<span\r\nclass=\"math inline\">\\(hp_l\\)</span>即可。</p>\r\n<p>那么最先被想到的可能是前缀和，它可以方便地查找这样的区间和。但这意味着每次尝试跳跃的时候，都要在跳跃区间进行一次区间和的查询，总体的效率会接近<span\r\nclass=\"math inline\">\\(O（n^2)\\)</span>\r\n，这个时间复杂度是不被允许的。<del>（AC之后交了一发试试果然TLE了）</del></p>\r\n<p>////</p>\r\n<p>我们换个思路考虑。先从最小规模的问题开始：如果是判断落点j的前一个位置能不能下楼击杀呢？那么可行条件就是<span\r\nclass=\"math inline\">\\(hp_{j-1} ≤ a+hp_j\\)</span></p>\r\n<p>对于当前攻击力<span class=\"math inline\">\\(a\\)</span>来说，就是<span\r\nclass=\"math inline\">\\(a≥hp_{j-1}-hp_j\\)</span></p>\r\n<p>再往下一个，即为<span\r\nclass=\"math inline\">\\(hp_{j-2}≤a+hp_j+hp_{j-1}\\)</span></p>\r\n<p>化为<span class=\"math inline\">\\(a≥hp_{j-2}-hp_j-hp_{j-1}\\)</span></p>\r\n<p>以此类推，对每个<span\r\nclass=\"math inline\">\\(l\\)</span>来说，从跃点<span\r\nclass=\"math inline\">\\(j\\)</span>回头击杀i位置怪物的条件就是：</p>\r\n<p><span\r\nclass=\"math inline\">\\(a&gt;=hp_l-\\sum_{i=l+1}^jhp_i\\)</span></p>\r\n<p><del>这不就刚那式子换个位置吗</del></p>\r\n<p>确实，确实。</p>\r\n<p>但其实思路里没化简的累减部分正是替代前缀和的关键。</p>\r\n<p>并且，归纳到整段对a的影响，也就是a要≥所有跳跃范围中累计出来的最大值。</p>\r\n<p>这意味着我们顺着楼梯上去的方向跑，就可以一边累减一边维护这个<span\r\nclass=\"math inline\">\\(a\\)</span>要对比的值，记作<span\r\nclass=\"math inline\">\\(cmp\\)</span>。当前攻击<span\r\nclass=\"math inline\">\\(a\\)</span>大于这个楼梯上怪物的<span\r\nclass=\"math inline\">\\(hp\\)</span>，且大于这个比较值，就说明<span\r\nclass=\"math inline\">\\(a\\)</span>可以击败这个楼梯上的怪物并把越过的怪物回去一锅端了。如果打不了，那可以把这个楼梯上的小玩意也抓去累减，指望后面的怪物的血条贡献的攻击力可以补救它。</p>\r\n<p>我们使用一个变量<span\r\nclass=\"math inline\">\\(lever\\)</span>记录我们已经干碎了的怪物的范围，每次合法的跃点就是这个范围的最新上界。再使用一个变量<span\r\nclass=\"math inline\">\\(stp\\)</span>记录当前跳跃前踩的楼梯，每次跳跃由于要回头收割，跳跃前的楼梯一定只能是当前的再走上去一级。<span\r\nclass=\"math inline\">\\(stp+k\\)</span>就是能达到的最远楼梯。超过这个范围还找不到能跳跃的点，怪物猎杀就宣告失败了。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> hp[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> s[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n,a0,k;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;a0&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> a=a0;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> cmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;hp[i];</span><br><span class=\"line\">\t\t\ts[i]=s[i<span class=\"number\">-1</span>]+hp[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> stp=<span class=\"number\">0</span>;<span class=\"comment\">//当前位置</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lever=<span class=\"number\">0</span>;<span class=\"comment\">//收割范围 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n&amp;&amp;i-stp&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a&gt;=hp[i]&amp;&amp;a&gt;=cmp)&#123;</span><br><span class=\"line\">\t\t\t\ta+=s[i]-s[lever];</span><br><span class=\"line\">\t\t\t\tlever=i;</span><br><span class=\"line\">\t\t\t\tstp++;<span class=\"comment\">//回头收割方式 步伐只能前进1</span></span><br><span class=\"line\">\t\t\t\tcmp=<span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tcmp=<span class=\"built_in\">max</span>((<span class=\"type\">long</span> <span class=\"type\">long</span>) (hp[i]-hp[i<span class=\"number\">+1</span>]),(<span class=\"type\">long</span> <span class=\"type\">long</span>)(cmp-hp[i<span class=\"number\">+1</span>]));</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lever==n)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"link-is-as-bear\">1011-Link is as bear</h1>\r\n<p>来源: 杭电杯超级联赛4 算法: 数论, 线性基 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1047&amp;pid=1011 补完: Yes\r\n完成时间: July 28, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>题目给操作: 任取子序列赋值为全体异或和. 要求全体最大异或和.</p>\r\n<p>等价于给<span class=\"math inline\">\\(n\\)</span>个数,\r\n求其中任选某些数的最大异或和.</p>\r\n<p>用线性基解决.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T,n;</span><br><span class=\"line\">ll a,ans;</span><br><span class=\"line\">vector&lt;ll&gt; Base;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(ll x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b : Base)</span><br><span class=\"line\">        x = <span class=\"built_in\">min</span>(x,b^x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;b : Base)</span><br><span class=\"line\">        b = <span class=\"built_in\">min</span>(b,b^x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x)</span><br><span class=\"line\">        Base.<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Base.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a;</span><br><span class=\"line\">        <span class=\"built_in\">insert</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : Base)&#123;</span><br><span class=\"line\">        ans ^= x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛05","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1010-Bragging Dice\n\n来源: 杭电杯超级联赛5\n算法: 博弈论\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1048&pid=1010\n补完: Yes\n\n[题目链接](https://acm.hdu.edu.cn/contest/problem?cid=1048&pid=1012)\n\n## 题意简述\n\nA和B两个人进行骰子游戏，这个游戏的规则是两个人分别摇两个装了$n$个骰子的骰蛊，之后从A开始喊点。可以任意喊” $x(x≥1)$个$y(1≤y≤6)$，B可以选择开点，即双方展示骰点，如果确实有$x$个及以上的$y$点骰子，A获胜，反之B获胜；B也可以选择继续喊点，但要比A的**严格**，即喊$x_2（x_2≥x)$个$y_2(1≤y_2≤6)$，或者$x$个$y_2(y_2>y)$。A同样有这两种选择，喊点要比B这轮的更严格，直到有人选择开点，游戏结束。\n\n特别地，①1点如果没有被提到，它可以充当任何数；②一个蛊内是清一色的骰子，可以视为这种骰子有多一个，比如n=5时，一个蛊内有5个6，视为蛊内有6个6；③如果蛊内所有点不重复，视为蛊内没有骰子。\n\n但是。高贵的A和B不喜欢”愚蠢的机会游戏“，所以他们要在知道所有骰子点数结果的情况下游戏，问你在双方使用最优策略的情况下A是否获胜。\n\n## 题目分析\n\n~~不喜欢机会游戏不要玩骰子！~~\n\n题目详细介绍了这个游戏的规则（虽然没提能不能看对方点数但是正常游戏当然不能啊），然后告诉你这两个玩家他们不完全遵守规则。\n\n那么题目里有用的是什么呢。\n\n第一，是这个游戏大致的规则，回看题意即可。\n\n第二，喊点必须一次比一次严格。\n\n第三，所有点不重复的花色视为蛊内没有骰子。\n\n那么，在知道所有骰点结果的情况下，先手的A当然喊符合点数结果的，**最严格**的骰点情况。这时，B不论怎么选都是必输的：开点的话，A喊的是符合的，A赢了；喊点的话，A喊的已经是符合条件的最严格骰点了，B不管喊什么，A开点之后都是A赢。\n\n~~差点考虑直接输出Win了呢。~~\n\n但虽然这题~~极其离谱~~，倒也没有离谱到A纯纯必赢。\n\n注意，所有点不重复的花色是视为无骰子的。也就是如果这两个人手气好得出奇，两个骰蛊都骰出了蛊内完全不重复的花色，这个情况是相当于整个场上没有骰子。\n\n那无论A喊什么点都不可能满足，这个情况A是必输的。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(false);\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tint pointA[10],pointB[10];\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tpointA[i]=0;\n\t\t\tpointB[i]=0;\n\t\t}\n//↓统计骰点结果\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpointA[a]++;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpointB[a]++;\n\t\t}\n\t\tint flag=0;\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tif(pointA[i]>1||pointB[i]>1){\n\t\t\t\t//有重复点，即存在一个蛊有有效点，A必赢\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==1){\n\t\t\tcout<<\"Win!\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout<<\"Just a game of chance.\\n\";\t\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛05.md","raw":"---\ntitle: 2022杭电杯超级联赛05\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1010-Bragging Dice\n\n来源: 杭电杯超级联赛5\n算法: 博弈论\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1048&pid=1010\n补完: Yes\n\n[题目链接](https://acm.hdu.edu.cn/contest/problem?cid=1048&pid=1012)\n\n## 题意简述\n\nA和B两个人进行骰子游戏，这个游戏的规则是两个人分别摇两个装了$n$个骰子的骰蛊，之后从A开始喊点。可以任意喊” $x(x≥1)$个$y(1≤y≤6)$，B可以选择开点，即双方展示骰点，如果确实有$x$个及以上的$y$点骰子，A获胜，反之B获胜；B也可以选择继续喊点，但要比A的**严格**，即喊$x_2（x_2≥x)$个$y_2(1≤y_2≤6)$，或者$x$个$y_2(y_2>y)$。A同样有这两种选择，喊点要比B这轮的更严格，直到有人选择开点，游戏结束。\n\n特别地，①1点如果没有被提到，它可以充当任何数；②一个蛊内是清一色的骰子，可以视为这种骰子有多一个，比如n=5时，一个蛊内有5个6，视为蛊内有6个6；③如果蛊内所有点不重复，视为蛊内没有骰子。\n\n但是。高贵的A和B不喜欢”愚蠢的机会游戏“，所以他们要在知道所有骰子点数结果的情况下游戏，问你在双方使用最优策略的情况下A是否获胜。\n\n## 题目分析\n\n~~不喜欢机会游戏不要玩骰子！~~\n\n题目详细介绍了这个游戏的规则（虽然没提能不能看对方点数但是正常游戏当然不能啊），然后告诉你这两个玩家他们不完全遵守规则。\n\n那么题目里有用的是什么呢。\n\n第一，是这个游戏大致的规则，回看题意即可。\n\n第二，喊点必须一次比一次严格。\n\n第三，所有点不重复的花色视为蛊内没有骰子。\n\n那么，在知道所有骰点结果的情况下，先手的A当然喊符合点数结果的，**最严格**的骰点情况。这时，B不论怎么选都是必输的：开点的话，A喊的是符合的，A赢了；喊点的话，A喊的已经是符合条件的最严格骰点了，B不管喊什么，A开点之后都是A赢。\n\n~~差点考虑直接输出Win了呢。~~\n\n但虽然这题~~极其离谱~~，倒也没有离谱到A纯纯必赢。\n\n注意，所有点不重复的花色是视为无骰子的。也就是如果这两个人手气好得出奇，两个骰蛊都骰出了蛊内完全不重复的花色，这个情况是相当于整个场上没有骰子。\n\n那无论A喊什么点都不可能满足，这个情况A是必输的。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(false);\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tint pointA[10],pointB[10];\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tpointA[i]=0;\n\t\t\tpointB[i]=0;\n\t\t}\n//↓统计骰点结果\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpointA[a]++;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpointB[a]++;\n\t\t}\n\t\tint flag=0;\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tif(pointA[i]>1||pointB[i]>1){\n\t\t\t\t//有重复点，即存在一个蛊有有效点，A必赢\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==1){\n\t\t\tcout<<\"Win!\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout<<\"Just a game of chance.\\n\";\t\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"2022杭电杯超级联赛05","published":1,"updated":"2023-10-29T06:23:01.414Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex50004n0um1d1cc6yz","content":"<h1 id=\"bragging-dice\">1010-Bragging Dice</h1>\r\n<p>来源: 杭电杯超级联赛5 算法: 博弈论 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1048&amp;pid=1010 补完:\r\nYes</p>\r\n<p><a\r\nhref=\"https://acm.hdu.edu.cn/contest/problem?cid=1048&amp;pid=1012\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>A和B两个人进行骰子游戏，这个游戏的规则是两个人分别摇两个装了<span\r\nclass=\"math inline\">\\(n\\)</span>个骰子的骰蛊，之后从A开始喊点。可以任意喊”\r\n<span class=\"math inline\">\\(x(x≥1)\\)</span>个<span\r\nclass=\"math inline\">\\(y(1≤y≤6)\\)</span>，B可以选择开点，即双方展示骰点，如果确实有<span\r\nclass=\"math inline\">\\(x\\)</span>个及以上的<span\r\nclass=\"math inline\">\\(y\\)</span>点骰子，A获胜，反之B获胜；B也可以选择继续喊点，但要比A的<strong>严格</strong>，即喊<span\r\nclass=\"math inline\">\\(x_2（x_2≥x)\\)</span>个<span\r\nclass=\"math inline\">\\(y_2(1≤y_2≤6)\\)</span>，或者<span\r\nclass=\"math inline\">\\(x\\)</span>个<span\r\nclass=\"math inline\">\\(y_2(y_2&gt;y)\\)</span>。A同样有这两种选择，喊点要比B这轮的更严格，直到有人选择开点，游戏结束。</p>\r\n<p>特别地，①1点如果没有被提到，它可以充当任何数；②一个蛊内是清一色的骰子，可以视为这种骰子有多一个，比如n=5时，一个蛊内有5个6，视为蛊内有6个6；③如果蛊内所有点不重复，视为蛊内没有骰子。</p>\r\n<p>但是。高贵的A和B不喜欢”愚蠢的机会游戏“，所以他们要在知道所有骰子点数结果的情况下游戏，问你在双方使用最优策略的情况下A是否获胜。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p><del>不喜欢机会游戏不要玩骰子！</del></p>\r\n<p>题目详细介绍了这个游戏的规则（虽然没提能不能看对方点数但是正常游戏当然不能啊），然后告诉你这两个玩家他们不完全遵守规则。</p>\r\n<p>那么题目里有用的是什么呢。</p>\r\n<p>第一，是这个游戏大致的规则，回看题意即可。</p>\r\n<p>第二，喊点必须一次比一次严格。</p>\r\n<p>第三，所有点不重复的花色视为蛊内没有骰子。</p>\r\n<p>那么，在知道所有骰点结果的情况下，先手的A当然喊符合点数结果的，<strong>最严格</strong>的骰点情况。这时，B不论怎么选都是必输的：开点的话，A喊的是符合的，A赢了；喊点的话，A喊的已经是符合条件的最严格骰点了，B不管喊什么，A开点之后都是A赢。</p>\r\n<p><del>差点考虑直接输出Win了呢。</del></p>\r\n<p>但虽然这题<del>极其离谱</del>，倒也没有离谱到A纯纯必赢。</p>\r\n<p>注意，所有点不重复的花色是视为无骰子的。也就是如果这两个人手气好得出奇，两个骰蛊都骰出了蛊内完全不重复的花色，这个情况是相当于整个场上没有骰子。</p>\r\n<p>那无论A喊什么点都不可能满足，这个情况A是必输的。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pointA[<span class=\"number\">10</span>],pointB[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">\t\t\tpointA[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tpointB[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//↓统计骰点结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a;</span><br><span class=\"line\">\t\t\tpointA[a]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a;</span><br><span class=\"line\">\t\t\tpointB[a]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(pointA[i]&gt;<span class=\"number\">1</span>||pointB[i]&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//有重复点，即存在一个蛊有有效点，A必赢</span></span><br><span class=\"line\">\t\t\t\tflag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&quot;Win!\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&quot;Just a game of chance.\\n&quot;</span>;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"bragging-dice\">1010-Bragging Dice</h1>\r\n<p>来源: 杭电杯超级联赛5 算法: 博弈论 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1048&amp;pid=1010 补完:\r\nYes</p>\r\n<p><a\r\nhref=\"https://acm.hdu.edu.cn/contest/problem?cid=1048&amp;pid=1012\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>A和B两个人进行骰子游戏，这个游戏的规则是两个人分别摇两个装了<span\r\nclass=\"math inline\">\\(n\\)</span>个骰子的骰蛊，之后从A开始喊点。可以任意喊”\r\n<span class=\"math inline\">\\(x(x≥1)\\)</span>个<span\r\nclass=\"math inline\">\\(y(1≤y≤6)\\)</span>，B可以选择开点，即双方展示骰点，如果确实有<span\r\nclass=\"math inline\">\\(x\\)</span>个及以上的<span\r\nclass=\"math inline\">\\(y\\)</span>点骰子，A获胜，反之B获胜；B也可以选择继续喊点，但要比A的<strong>严格</strong>，即喊<span\r\nclass=\"math inline\">\\(x_2（x_2≥x)\\)</span>个<span\r\nclass=\"math inline\">\\(y_2(1≤y_2≤6)\\)</span>，或者<span\r\nclass=\"math inline\">\\(x\\)</span>个<span\r\nclass=\"math inline\">\\(y_2(y_2&gt;y)\\)</span>。A同样有这两种选择，喊点要比B这轮的更严格，直到有人选择开点，游戏结束。</p>\r\n<p>特别地，①1点如果没有被提到，它可以充当任何数；②一个蛊内是清一色的骰子，可以视为这种骰子有多一个，比如n=5时，一个蛊内有5个6，视为蛊内有6个6；③如果蛊内所有点不重复，视为蛊内没有骰子。</p>\r\n<p>但是。高贵的A和B不喜欢”愚蠢的机会游戏“，所以他们要在知道所有骰子点数结果的情况下游戏，问你在双方使用最优策略的情况下A是否获胜。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p><del>不喜欢机会游戏不要玩骰子！</del></p>\r\n<p>题目详细介绍了这个游戏的规则（虽然没提能不能看对方点数但是正常游戏当然不能啊），然后告诉你这两个玩家他们不完全遵守规则。</p>\r\n<p>那么题目里有用的是什么呢。</p>\r\n<p>第一，是这个游戏大致的规则，回看题意即可。</p>\r\n<p>第二，喊点必须一次比一次严格。</p>\r\n<p>第三，所有点不重复的花色视为蛊内没有骰子。</p>\r\n<p>那么，在知道所有骰点结果的情况下，先手的A当然喊符合点数结果的，<strong>最严格</strong>的骰点情况。这时，B不论怎么选都是必输的：开点的话，A喊的是符合的，A赢了；喊点的话，A喊的已经是符合条件的最严格骰点了，B不管喊什么，A开点之后都是A赢。</p>\r\n<p><del>差点考虑直接输出Win了呢。</del></p>\r\n<p>但虽然这题<del>极其离谱</del>，倒也没有离谱到A纯纯必赢。</p>\r\n<p>注意，所有点不重复的花色是视为无骰子的。也就是如果这两个人手气好得出奇，两个骰蛊都骰出了蛊内完全不重复的花色，这个情况是相当于整个场上没有骰子。</p>\r\n<p>那无论A喊什么点都不可能满足，这个情况A是必输的。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pointA[<span class=\"number\">10</span>],pointB[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">\t\t\tpointA[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tpointB[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//↓统计骰点结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a;</span><br><span class=\"line\">\t\t\tpointA[a]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a;</span><br><span class=\"line\">\t\t\tpointB[a]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(pointA[i]&gt;<span class=\"number\">1</span>||pointB[i]&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//有重复点，即存在一个蛊有有效点，A必赢</span></span><br><span class=\"line\">\t\t\t\tflag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&quot;Win!\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&quot;Just a game of chance.\\n&quot;</span>;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛06","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1006-Meax\n\n来源: 杭电杯超级联赛6\n算法: DFS, 贪心\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1049&pid=1006\n补完: No\n## 代码\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\nlong long a[500010];\nlong long b[500010];\nvector<int> v[500010];\nvoid dfs(int x,int r){\n\ta[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==r) continue;\n\t\tdfs(y,x);\n\t\ta[x]+=a[y];\n\t}\n\t//\n\t//cout<<a[x]<<endl;\n\t//\n\treturn ;\n}\nvoid toans(int x,int r){\n\tb[x]=a[x];\n\tlong long maxx=0;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==r) continue;\n\t\ttoans(y,x);\n\t\tmaxx=max(maxx,b[y]);\n\t}\n\tb[x]+=maxx;\n\treturn;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\t\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t v[i].clear();\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i]=0;\n\t\t\tb[i]=0;\n\t\t}\n\t\tfor(int i=1;i<=n-1;i++){\n\t\t\tint u1,u2;\n\t\t\tcin>>u1>>u2;\n\t\t\tv[u1].push_back(u2);\n\t\t\tv[u2].push_back(u1);\n\t\t}\n\t\tdfs(1,0);\n\t\ttoans(1,0);\n\t\tcout<<b[1]<<\"\\n\";\n\t}\n}\n```\n# 1009-Map\n\n来源: 杭电杯超级联赛6\n算法: 向量, 计算几何\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1049&pid=1009\n补完: Yes\n完成时间: August 12, 2022\n\n## 题解\n\n有大地图$M$经过旋转压缩得到$m$, 任落在$M$内, 在空间中有一不动点同时在$M$和$m$上确定同一位置.\n\n设不动点为$P$, 设相对位置参数$\\lambda,\\mu$, 可列方程\n\n$$\n\\begin{align}\n\\vec{OP}&=\\vec{OA}+\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\n\\vec{OP}&=\\vec{Oa}+\\lambda\\vec{ab}+\\mu\\vec{ad}\n\\end{align}\n$$\n\n化简有\n\n$$\n\\begin{align}\n\\vec{AP}&=\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\n\\vec{aP}&=\\lambda\\vec{ab}+\\mu\\vec{ad}\n\\end{align}\n$$\n\n展开有\n\n$$\n\\begin{align}\nP.x-A.x&=\\lambda(B.x-A.x)+\\mu(D.x-A.x)\\\\\nP.y-A.y&=\\lambda(B.y-A.y)+\\mu(D.y-A.y)\\\\\nP.x-a.x&=\\lambda(b.x-a.x)+\\mu(d.x-a.x)\\\\\nP.y-a.y&=\\lambda(b.y-a.y)+\\mu(d.y-a.y)\\\\\n\\end{align}\n$$\n\n化简有\n\n$$\n\\begin{align}\na.x-A.x&=\\lambda(B.x-b.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)\\\\\na.y-A.y&=\\lambda(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)\\\\\n\\end{align}\n$$\n\n展开有\n\n$$\n\\begin{align}\n(a.x-A.x)(D.y-d.y+a.y-A.y)&=\\lambda(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\n(a.y-A.y)(D.x-d.x+a.x-A.x)&=\\lambda(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\n\\end{align}\n$$\n\n$$\n\\begin{align}\n(a.x-A.x)(B.y-b.y+a.y-A.y)&=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)\\\\\n(a.y-A.y)(B.x-b.x+a.x-A.x)&=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)\\\\\n\\end{align}\n$$\n\n化简有\n\n$$\n\\lambda=\\frac{(a.x-A.x)(D.y-d.y+a.y-A.y)-(a.y-A.y)(D.x-d.x+a.x-A.x)}{(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)-(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)}\n$$\n\n$$\n\\mu=\\frac{(a.x-A.x)(B.y-b.y+a.y-A.y)-(a.y-A.y)(B.x-b.x+a.x-A.x)}{(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)-(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)}\n$$\n\n最后有\n\n$$\n\\begin{align}\nP.x&=\\lambda(B.x-A.x)+\\mu(D.x-A.x)+A.x\\\\\nP.y&=\\lambda(B.y-A.y)+\\mu(D.y-A.y)+A.y\\\\\n\\end{align}\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n    double Ax,Ay,Bx,By,Cx,Cy,Dx,Dy;\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&Ax,&Ay,&Bx,&By,&Cx,&Cy,&Dx,&Dy);\n    scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy);\n    double alphaX = ax-Ax;\n    double alphaY = ay-Ay;\n    double betaX  = Bx-bx+alphaX;\n    double betaY  = By-by+alphaY;\n    double deltaX = Dx-dx+alphaX;\n    double deltaY = Dy-dy+alphaY;\n    double lambda = (alphaX*deltaY-alphaY*deltaX)/( betaX*deltaY- betaY*deltaX);\n    double mu     = (alphaX* betaY-alphaY* betaX)/(deltaX* betaY-deltaY* betaX);\n    double Px = lambda*(Bx-Ax)+mu*(Dx-Ax)+Ax;\n    double Py = lambda*(By-Ay)+mu*(Dy-Ay)+Ay;\n    printf(\"%.15lf %.15lf\\n\",Px,Py);\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# 1012-Loop\n\n来源: 杭电杯超级联赛6\n算法: 字典序, 栈\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1049&pid=1012\n补完: Yes\n完成时间: August 16, 2022\n\n## 题意简述\n\n给定一个长度为n的数组a，进行严格的k次操作：选择两个整数l，r (1≤l≤r≤n)，让数组a_l到a_r循环左移一位。\n\n使得数组a的字典序最大，输出操作后的数组a。其中字典序比较的是每个a_i的值，不考虑a_i具体的数位。\n\n## 题目分析\n\n首先，由于l和r可以相等，所谓严格的k次操作其实相当于可以少于k次。\n\n接着，一次操作之后，发生了什么？\n\n~~不是循环左移一位吗题目又不是很难懂。~~\n\n我们换个角度看看，既然操作的时候可以任选区间，并且循环左移意味着最左的数字换到区间最右端——那么一次操作实际上是否是任选一个作为区间左节点的数字，把它放到它之后的任意位置呢？是的。\n\n也就是作为左区间的每个数字，都可以自由地插入其后的位置。\n\n既然是自由插入，那我们当然是直接把这部分自由的数字排序好放进去啦~\n\n那么怎么放进去呢？\n\n我们考虑插入前的序列的有序情况：\n\n如果原来的序列是降序的，自由插入一些数字，字典序最小的结果其实就是所有数字降序排列的结果。\n\n如果原来的序列是无序的，对于已经预先排好的待插入数字，每次都插在第一个比自己小的数字之前，才能让字典序更大。\n\n并且，使用无序的一般情况的方案插入有序数列，也能得到有序数列的最优方案，故而我们采用这种混合插入的方式来插入数列。\n\n~~那区分这个干什么啊。~~\n\n对待插入的原序列的分类得出的结论，很好地辅助了我们思考如何选取这些自由插入的数字。\n\n首先的首先，由于字典序先比较数列前端，那么在前面的数字优先。\n\n接着，回看前面插入有序序列的情况：往降序序列插入自由的元素，能得到所有元素降序排列的结果。这意味着没有必要把降序的序列数纳入自由元素，也能达到所有元素降序的最优的字典序结果。并且为了节省更多机会，相等的连续元素也视为降序，也就是非严格降序序列都不用纳入自由元素。\n\n而这样节省下来的操作次数，可以抓取更多的后面无序序列的元素，让它变成自由排列的。\n\n换句话说，我们选取**破坏**了非严格降序序列的数字。\n\n再然后，怎·么判断不用抓取的非严格降序区问呢？\n\n想象两个相邻的非严格降序区问，后一个区问最前端的一小段比前—个区间最后端的一段元素大。如果直接在原序列里做判断，不管怎样都是不够正确的(这里认为k足够大):\n\n后—个区间的第─个数字大于前—个区间的最后—个数字了，认为非严格降序区间结束了，把后—个区问连续扔进自由元素里，显然浪费了操作机会——删去前面—小段就能让剩下的数字合成—个非严格降序区间了。\n认为两个区问都是非严格降序区间，在第二个区问之后去抓自由元素，显然结果不够优秀:在更前面的，第三个区间的前端元素偏大，在字典序比较中，这已经比把这些元素抓走后的结果更小了。\n\n那反正就是把中间的抓出来嘛！\n\n~~然而把第二个区间前一段偏大的抓走也是错误的。~~\n\n别忘了，”自由“的元素也不是完全自由的。\n\n它们只能往自己的后方插入。看图来理解这个选择：\n\n把两个区间描述成这样的曲线，两个区间有一段大小叠合：\n\n![Untitled](1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled.png)\n\n如果是把后一个区间的bc段纳入自由元素，那么它在自由排序的时候会插入ab段中。这是不符合规则的。只有把前一个区间的ab段扔到自由元素里才行——它们会排列进bc段，这是合法的操作。\n\n![Untitled](1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled%201.png)\n\n那么怎么把这些元素放入自由序列呢？双指针指向需要比较的元素也是可行的，但出于好写和好懂的考虑，这里使用了栈的结构。\n\n从原始序列的队首开始，依次把元素压入栈中。\n\n如果新入栈元素比栈顶元素小或相等，不严格降序的结构不被破坏，继续入栈即可。\n\n如果新入栈元素比栈顶元素大，不严格降序的结构被破坏，把原来的栈顶元素弹出，进入自由元素的队列中，消耗一次操作机会（也就是入自由元素队的机会）。继续把新元素和新的栈顶比较，直到不严格降序的结构不被破坏。\n\n最后，我们得到了长度为k的自由元素队，把它们排序后插入序列中即可。\n\n注意，仍然留在栈中的元素记得退回序列。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<algorithm> \nusing namespace std;\nint a[300010];\nint b[300010];//自由排序队 \nint c[300010];//比较等待栈 \nint main(){\n\tstd::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\tint stpb=0,stpc=0,stpa; \n\t\tfor(int i=0;i<n&&k;i++){\n\t\t\tif(stpc==0){\n\t\t\t\tc[stpc++]=a[i];//空栈则直接入栈 \n\t\t\t\tstpa=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(c[stpc-1]<a[i]){\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(c[stpc-1]>=a[i])break;\n\t\t\t\t\t\tb[stpb++]=c[stpc-1];//栈顶进队 \n\t\t\t\t\t\tstpc--;\n\t\t\t\t\t\tk--;//消耗一次进队机会 \n\t\t\t\t\t\tif(stpc==0||k==0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(k){\n\t\t\t\t\t\tc[stpc++]=a[i];\n\t\t\t\t\t\tstpa=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tc[stpc++]=a[i];//新数进栈 \n\t\t\t\t\tstpa=i;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\tfor(int i=stpc-1;i>=0;i--)a[stpa--]=c[i];//栈退回原始序列 \n\t\tstpa++;\n\t\tsort(b,b+stpb);\n\t\tstpb--;\n\t\tint flag=0;\n\t\twhile(true){\n\t\t\tif(b[stpb]>a[stpa]||stpa>=n){\n\t\t\t\tif(flag==0){\n\t\t\t\t\tcout<<b[stpb--];\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tcout<<' '<<b[stpb--];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(flag==0){\n\t\t\t\t\tcout<<a[stpa++];\n\t\t\t\t\tflag=1; \n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\tcout<<' '<<a[stpa++];\n\t\t\t}\n\t\t\tif(stpb<0)break;\n\t\t}\n\t\t\n\t\tfor(int i=stpa;i<n;i++){\n\t\t\tif(flag==0){\n\t\t\t\tcout<<a[i];\n\t\t\t}\n\t\t\tcout<<' '<<a[i];\n\t\t}\n\t\tcout<<'\\n';\n\t}\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛06.md","raw":"---\ntitle: 2022杭电杯超级联赛06\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1006-Meax\n\n来源: 杭电杯超级联赛6\n算法: DFS, 贪心\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1049&pid=1006\n补完: No\n## 代码\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\nlong long a[500010];\nlong long b[500010];\nvector<int> v[500010];\nvoid dfs(int x,int r){\n\ta[x]=1;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==r) continue;\n\t\tdfs(y,x);\n\t\ta[x]+=a[y];\n\t}\n\t//\n\t//cout<<a[x]<<endl;\n\t//\n\treturn ;\n}\nvoid toans(int x,int r){\n\tb[x]=a[x];\n\tlong long maxx=0;\n\tfor(int i=0;i<v[x].size();i++){\n\t\tint y=v[x][i];\n\t\tif(y==r) continue;\n\t\ttoans(y,x);\n\t\tmaxx=max(maxx,b[y]);\n\t}\n\tb[x]+=maxx;\n\treturn;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\t\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t v[i].clear();\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i]=0;\n\t\t\tb[i]=0;\n\t\t}\n\t\tfor(int i=1;i<=n-1;i++){\n\t\t\tint u1,u2;\n\t\t\tcin>>u1>>u2;\n\t\t\tv[u1].push_back(u2);\n\t\t\tv[u2].push_back(u1);\n\t\t}\n\t\tdfs(1,0);\n\t\ttoans(1,0);\n\t\tcout<<b[1]<<\"\\n\";\n\t}\n}\n```\n# 1009-Map\n\n来源: 杭电杯超级联赛6\n算法: 向量, 计算几何\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1049&pid=1009\n补完: Yes\n完成时间: August 12, 2022\n\n## 题解\n\n有大地图$M$经过旋转压缩得到$m$, 任落在$M$内, 在空间中有一不动点同时在$M$和$m$上确定同一位置.\n\n设不动点为$P$, 设相对位置参数$\\lambda,\\mu$, 可列方程\n\n$$\n\\begin{align}\n\\vec{OP}&=\\vec{OA}+\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\n\\vec{OP}&=\\vec{Oa}+\\lambda\\vec{ab}+\\mu\\vec{ad}\n\\end{align}\n$$\n\n化简有\n\n$$\n\\begin{align}\n\\vec{AP}&=\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\n\\vec{aP}&=\\lambda\\vec{ab}+\\mu\\vec{ad}\n\\end{align}\n$$\n\n展开有\n\n$$\n\\begin{align}\nP.x-A.x&=\\lambda(B.x-A.x)+\\mu(D.x-A.x)\\\\\nP.y-A.y&=\\lambda(B.y-A.y)+\\mu(D.y-A.y)\\\\\nP.x-a.x&=\\lambda(b.x-a.x)+\\mu(d.x-a.x)\\\\\nP.y-a.y&=\\lambda(b.y-a.y)+\\mu(d.y-a.y)\\\\\n\\end{align}\n$$\n\n化简有\n\n$$\n\\begin{align}\na.x-A.x&=\\lambda(B.x-b.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)\\\\\na.y-A.y&=\\lambda(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)\\\\\n\\end{align}\n$$\n\n展开有\n\n$$\n\\begin{align}\n(a.x-A.x)(D.y-d.y+a.y-A.y)&=\\lambda(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\n(a.y-A.y)(D.x-d.x+a.x-A.x)&=\\lambda(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\n\\end{align}\n$$\n\n$$\n\\begin{align}\n(a.x-A.x)(B.y-b.y+a.y-A.y)&=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)\\\\\n(a.y-A.y)(B.x-b.x+a.x-A.x)&=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)\\\\\n\\end{align}\n$$\n\n化简有\n\n$$\n\\lambda=\\frac{(a.x-A.x)(D.y-d.y+a.y-A.y)-(a.y-A.y)(D.x-d.x+a.x-A.x)}{(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)-(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)}\n$$\n\n$$\n\\mu=\\frac{(a.x-A.x)(B.y-b.y+a.y-A.y)-(a.y-A.y)(B.x-b.x+a.x-A.x)}{(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)-(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)}\n$$\n\n最后有\n\n$$\n\\begin{align}\nP.x&=\\lambda(B.x-A.x)+\\mu(D.x-A.x)+A.x\\\\\nP.y&=\\lambda(B.y-A.y)+\\mu(D.y-A.y)+A.y\\\\\n\\end{align}\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n    double Ax,Ay,Bx,By,Cx,Cy,Dx,Dy;\n    double ax,ay,bx,by,cx,cy,dx,dy;\n    scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&Ax,&Ay,&Bx,&By,&Cx,&Cy,&Dx,&Dy);\n    scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy);\n    double alphaX = ax-Ax;\n    double alphaY = ay-Ay;\n    double betaX  = Bx-bx+alphaX;\n    double betaY  = By-by+alphaY;\n    double deltaX = Dx-dx+alphaX;\n    double deltaY = Dy-dy+alphaY;\n    double lambda = (alphaX*deltaY-alphaY*deltaX)/( betaX*deltaY- betaY*deltaX);\n    double mu     = (alphaX* betaY-alphaY* betaX)/(deltaX* betaY-deltaY* betaX);\n    double Px = lambda*(Bx-Ax)+mu*(Dx-Ax)+Ax;\n    double Py = lambda*(By-Ay)+mu*(Dy-Ay)+Ay;\n    printf(\"%.15lf %.15lf\\n\",Px,Py);\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# 1012-Loop\n\n来源: 杭电杯超级联赛6\n算法: 字典序, 栈\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1049&pid=1012\n补完: Yes\n完成时间: August 16, 2022\n\n## 题意简述\n\n给定一个长度为n的数组a，进行严格的k次操作：选择两个整数l，r (1≤l≤r≤n)，让数组a_l到a_r循环左移一位。\n\n使得数组a的字典序最大，输出操作后的数组a。其中字典序比较的是每个a_i的值，不考虑a_i具体的数位。\n\n## 题目分析\n\n首先，由于l和r可以相等，所谓严格的k次操作其实相当于可以少于k次。\n\n接着，一次操作之后，发生了什么？\n\n~~不是循环左移一位吗题目又不是很难懂。~~\n\n我们换个角度看看，既然操作的时候可以任选区间，并且循环左移意味着最左的数字换到区间最右端——那么一次操作实际上是否是任选一个作为区间左节点的数字，把它放到它之后的任意位置呢？是的。\n\n也就是作为左区间的每个数字，都可以自由地插入其后的位置。\n\n既然是自由插入，那我们当然是直接把这部分自由的数字排序好放进去啦~\n\n那么怎么放进去呢？\n\n我们考虑插入前的序列的有序情况：\n\n如果原来的序列是降序的，自由插入一些数字，字典序最小的结果其实就是所有数字降序排列的结果。\n\n如果原来的序列是无序的，对于已经预先排好的待插入数字，每次都插在第一个比自己小的数字之前，才能让字典序更大。\n\n并且，使用无序的一般情况的方案插入有序数列，也能得到有序数列的最优方案，故而我们采用这种混合插入的方式来插入数列。\n\n~~那区分这个干什么啊。~~\n\n对待插入的原序列的分类得出的结论，很好地辅助了我们思考如何选取这些自由插入的数字。\n\n首先的首先，由于字典序先比较数列前端，那么在前面的数字优先。\n\n接着，回看前面插入有序序列的情况：往降序序列插入自由的元素，能得到所有元素降序排列的结果。这意味着没有必要把降序的序列数纳入自由元素，也能达到所有元素降序的最优的字典序结果。并且为了节省更多机会，相等的连续元素也视为降序，也就是非严格降序序列都不用纳入自由元素。\n\n而这样节省下来的操作次数，可以抓取更多的后面无序序列的元素，让它变成自由排列的。\n\n换句话说，我们选取**破坏**了非严格降序序列的数字。\n\n再然后，怎·么判断不用抓取的非严格降序区问呢？\n\n想象两个相邻的非严格降序区问，后一个区问最前端的一小段比前—个区间最后端的一段元素大。如果直接在原序列里做判断，不管怎样都是不够正确的(这里认为k足够大):\n\n后—个区间的第─个数字大于前—个区间的最后—个数字了，认为非严格降序区间结束了，把后—个区问连续扔进自由元素里，显然浪费了操作机会——删去前面—小段就能让剩下的数字合成—个非严格降序区间了。\n认为两个区问都是非严格降序区间，在第二个区问之后去抓自由元素，显然结果不够优秀:在更前面的，第三个区间的前端元素偏大，在字典序比较中，这已经比把这些元素抓走后的结果更小了。\n\n那反正就是把中间的抓出来嘛！\n\n~~然而把第二个区间前一段偏大的抓走也是错误的。~~\n\n别忘了，”自由“的元素也不是完全自由的。\n\n它们只能往自己的后方插入。看图来理解这个选择：\n\n把两个区间描述成这样的曲线，两个区间有一段大小叠合：\n\n![Untitled](1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled.png)\n\n如果是把后一个区间的bc段纳入自由元素，那么它在自由排序的时候会插入ab段中。这是不符合规则的。只有把前一个区间的ab段扔到自由元素里才行——它们会排列进bc段，这是合法的操作。\n\n![Untitled](1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled%201.png)\n\n那么怎么把这些元素放入自由序列呢？双指针指向需要比较的元素也是可行的，但出于好写和好懂的考虑，这里使用了栈的结构。\n\n从原始序列的队首开始，依次把元素压入栈中。\n\n如果新入栈元素比栈顶元素小或相等，不严格降序的结构不被破坏，继续入栈即可。\n\n如果新入栈元素比栈顶元素大，不严格降序的结构被破坏，把原来的栈顶元素弹出，进入自由元素的队列中，消耗一次操作机会（也就是入自由元素队的机会）。继续把新元素和新的栈顶比较，直到不严格降序的结构不被破坏。\n\n最后，我们得到了长度为k的自由元素队，把它们排序后插入序列中即可。\n\n注意，仍然留在栈中的元素记得退回序列。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<algorithm> \nusing namespace std;\nint a[300010];\nint b[300010];//自由排序队 \nint c[300010];//比较等待栈 \nint main(){\n\tstd::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\tint stpb=0,stpc=0,stpa; \n\t\tfor(int i=0;i<n&&k;i++){\n\t\t\tif(stpc==0){\n\t\t\t\tc[stpc++]=a[i];//空栈则直接入栈 \n\t\t\t\tstpa=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(c[stpc-1]<a[i]){\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(c[stpc-1]>=a[i])break;\n\t\t\t\t\t\tb[stpb++]=c[stpc-1];//栈顶进队 \n\t\t\t\t\t\tstpc--;\n\t\t\t\t\t\tk--;//消耗一次进队机会 \n\t\t\t\t\t\tif(stpc==0||k==0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(k){\n\t\t\t\t\t\tc[stpc++]=a[i];\n\t\t\t\t\t\tstpa=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tc[stpc++]=a[i];//新数进栈 \n\t\t\t\t\tstpa=i;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\tfor(int i=stpc-1;i>=0;i--)a[stpa--]=c[i];//栈退回原始序列 \n\t\tstpa++;\n\t\tsort(b,b+stpb);\n\t\tstpb--;\n\t\tint flag=0;\n\t\twhile(true){\n\t\t\tif(b[stpb]>a[stpa]||stpa>=n){\n\t\t\t\tif(flag==0){\n\t\t\t\t\tcout<<b[stpb--];\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tcout<<' '<<b[stpb--];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(flag==0){\n\t\t\t\t\tcout<<a[stpa++];\n\t\t\t\t\tflag=1; \n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\tcout<<' '<<a[stpa++];\n\t\t\t}\n\t\t\tif(stpb<0)break;\n\t\t}\n\t\t\n\t\tfor(int i=stpa;i<n;i++){\n\t\t\tif(flag==0){\n\t\t\t\tcout<<a[i];\n\t\t\t}\n\t\t\tcout<<' '<<a[i];\n\t\t}\n\t\tcout<<'\\n';\n\t}\n}\n```\n","slug":"2022杭电杯超级联赛06","published":1,"updated":"2023-10-29T06:39:34.538Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex60005n0um62cm5or7","content":"<h1 id=\"meax\">1006-Meax</h1>\r\n<p>来源: 杭电杯超级联赛6 算法: DFS, 贪心 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1049&amp;pid=1006 补完: No ##\r\n代码 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> a[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> b[<span class=\"number\">500010</span>];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\ta[x]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;v[x].<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> y=v[x][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y==r) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(y,x);</span><br><span class=\"line\">\t\ta[x]+=a[y];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">//cout&lt;&lt;a[x]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">toans</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\tb[x]=a[x];</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> maxx=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;v[x].<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> y=v[x][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y==r) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">toans</span>(y,x);</span><br><span class=\"line\">\t\tmaxx=<span class=\"built_in\">max</span>(maxx,b[y]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb[x]+=maxx;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tstd::cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t v[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\ta[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tb[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> u1,u2;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;u1&gt;&gt;u2;</span><br><span class=\"line\">\t\t\tv[u1].<span class=\"built_in\">push_back</span>(u2);</span><br><span class=\"line\">\t\t\tv[u2].<span class=\"built_in\">push_back</span>(u1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">toans</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tcout&lt;&lt;b[<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> # 1009-Map</p>\r\n<p>来源: 杭电杯超级联赛6 算法: 向量, 计算几何 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1049&amp;pid=1009 补完: Yes\r\n完成时间: August 12, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>有大地图<span class=\"math inline\">\\(M\\)</span>经过旋转压缩得到<span\r\nclass=\"math inline\">\\(m\\)</span>, 任落在<span\r\nclass=\"math inline\">\\(M\\)</span>内, 在空间中有一不动点同时在<span\r\nclass=\"math inline\">\\(M\\)</span>和<span\r\nclass=\"math inline\">\\(m\\)</span>上确定同一位置.</p>\r\n<p>设不动点为<span class=\"math inline\">\\(P\\)</span>, 设相对位置参数<span\r\nclass=\"math inline\">\\(\\lambda,\\mu\\)</span>, 可列方程</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n\\vec{OP}&amp;=\\vec{OA}+\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\r\n\\vec{OP}&amp;=\\vec{Oa}+\\lambda\\vec{ab}+\\mu\\vec{ad}\r\n\\end{align}\r\n\\]</span></p>\r\n<p>化简有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n\\vec{AP}&amp;=\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\r\n\\vec{aP}&amp;=\\lambda\\vec{ab}+\\mu\\vec{ad}\r\n\\end{align}\r\n\\]</span></p>\r\n<p>展开有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nP.x-A.x&amp;=\\lambda(B.x-A.x)+\\mu(D.x-A.x)\\\\\r\nP.y-A.y&amp;=\\lambda(B.y-A.y)+\\mu(D.y-A.y)\\\\\r\nP.x-a.x&amp;=\\lambda(b.x-a.x)+\\mu(d.x-a.x)\\\\\r\nP.y-a.y&amp;=\\lambda(b.y-a.y)+\\mu(d.y-a.y)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p>化简有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\na.x-A.x&amp;=\\lambda(B.x-b.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)\\\\\r\na.y-A.y&amp;=\\lambda(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p>展开有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n(a.x-A.x)(D.y-d.y+a.y-A.y)&amp;=\\lambda(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\r\n(a.y-A.y)(D.x-d.x+a.x-A.x)&amp;=\\lambda(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n(a.x-A.x)(B.y-b.y+a.y-A.y)&amp;=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)\\\\\r\n(a.y-A.y)(B.x-b.x+a.x-A.x)&amp;=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p>化简有</p>\r\n<p><span class=\"math display\">\\[\r\n\\lambda=\\frac{(a.x-A.x)(D.y-d.y+a.y-A.y)-(a.y-A.y)(D.x-d.x+a.x-A.x)}{(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)-(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\mu=\\frac{(a.x-A.x)(B.y-b.y+a.y-A.y)-(a.y-A.y)(B.x-b.x+a.x-A.x)}{(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)-(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)}\r\n\\]</span></p>\r\n<p>最后有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nP.x&amp;=\\lambda(B.x-A.x)+\\mu(D.x-A.x)+A.x\\\\\r\nP.y&amp;=\\lambda(B.y-A.y)+\\mu(D.y-A.y)+A.y\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> Ax,Ay,Bx,By,Cx,Cy,Dx,Dy;</span><br><span class=\"line\">    <span class=\"type\">double</span> ax,ay,bx,by,cx,cy,dx,dy;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf%lf%lf%lf%lf%lf%lf%lf&quot;</span>,&amp;Ax,&amp;Ay,&amp;Bx,&amp;By,&amp;Cx,&amp;Cy,&amp;Dx,&amp;Dy);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf%lf%lf%lf%lf%lf%lf%lf&quot;</span>,&amp;ax,&amp;ay,&amp;bx,&amp;by,&amp;cx,&amp;cy,&amp;dx,&amp;dy);</span><br><span class=\"line\">    <span class=\"type\">double</span> alphaX = ax-Ax;</span><br><span class=\"line\">    <span class=\"type\">double</span> alphaY = ay-Ay;</span><br><span class=\"line\">    <span class=\"type\">double</span> betaX  = Bx-bx+alphaX;</span><br><span class=\"line\">    <span class=\"type\">double</span> betaY  = By-by+alphaY;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltaX = Dx-dx+alphaX;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltaY = Dy-dy+alphaY;</span><br><span class=\"line\">    <span class=\"type\">double</span> lambda = (alphaX*deltaY-alphaY*deltaX)/( betaX*deltaY- betaY*deltaX);</span><br><span class=\"line\">    <span class=\"type\">double</span> mu     = (alphaX* betaY-alphaY* betaX)/(deltaX* betaY-deltaY* betaX);</span><br><span class=\"line\">    <span class=\"type\">double</span> Px = lambda*(Bx-Ax)+mu*(Dx-Ax)+Ax;</span><br><span class=\"line\">    <span class=\"type\">double</span> Py = lambda*(By-Ay)+mu*(Dy-Ay)+Ay;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf %.15lf\\n&quot;</span>,Px,Py);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"loop\">1012-Loop</h1>\r\n<p>来源: 杭电杯超级联赛6 算法: 字典序, 栈 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1049&amp;pid=1012 补完: Yes\r\n完成时间: August 16, 2022</p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给定一个长度为n的数组a，进行严格的k次操作：选择两个整数l，r\r\n(1≤l≤r≤n)，让数组a_l到a_r循环左移一位。</p>\r\n<p>使得数组a的字典序最大，输出操作后的数组a。其中字典序比较的是每个a_i的值，不考虑a_i具体的数位。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>首先，由于l和r可以相等，所谓严格的k次操作其实相当于可以少于k次。</p>\r\n<p>接着，一次操作之后，发生了什么？</p>\r\n<p><del>不是循环左移一位吗题目又不是很难懂。</del></p>\r\n<p>我们换个角度看看，既然操作的时候可以任选区间，并且循环左移意味着最左的数字换到区间最右端——那么一次操作实际上是否是任选一个作为区间左节点的数字，把它放到它之后的任意位置呢？是的。</p>\r\n<p>也就是作为左区间的每个数字，都可以自由地插入其后的位置。</p>\r\n<p>既然是自由插入，那我们当然是直接把这部分自由的数字排序好放进去啦~</p>\r\n<p>那么怎么放进去呢？</p>\r\n<p>我们考虑插入前的序列的有序情况：</p>\r\n<p>如果原来的序列是降序的，自由插入一些数字，字典序最小的结果其实就是所有数字降序排列的结果。</p>\r\n<p>如果原来的序列是无序的，对于已经预先排好的待插入数字，每次都插在第一个比自己小的数字之前，才能让字典序更大。</p>\r\n<p>并且，使用无序的一般情况的方案插入有序数列，也能得到有序数列的最优方案，故而我们采用这种混合插入的方式来插入数列。</p>\r\n<p><del>那区分这个干什么啊。</del></p>\r\n<p>对待插入的原序列的分类得出的结论，很好地辅助了我们思考如何选取这些自由插入的数字。</p>\r\n<p>首先的首先，由于字典序先比较数列前端，那么在前面的数字优先。</p>\r\n<p>接着，回看前面插入有序序列的情况：往降序序列插入自由的元素，能得到所有元素降序排列的结果。这意味着没有必要把降序的序列数纳入自由元素，也能达到所有元素降序的最优的字典序结果。并且为了节省更多机会，相等的连续元素也视为降序，也就是非严格降序序列都不用纳入自由元素。</p>\r\n<p>而这样节省下来的操作次数，可以抓取更多的后面无序序列的元素，让它变成自由排列的。</p>\r\n<p>换句话说，我们选取<strong>破坏</strong>了非严格降序序列的数字。</p>\r\n<p>再然后，怎·么判断不用抓取的非严格降序区问呢？</p>\r\n<p>想象两个相邻的非严格降序区问，后一个区问最前端的一小段比前—个区间最后端的一段元素大。如果直接在原序列里做判断，不管怎样都是不够正确的(这里认为k足够大):</p>\r\n<p>后—个区间的第─个数字大于前—个区间的最后—个数字了，认为非严格降序区间结束了，把后—个区问连续扔进自由元素里，显然浪费了操作机会——删去前面—小段就能让剩下的数字合成—个非严格降序区间了。\r\n认为两个区问都是非严格降序区间，在第二个区问之后去抓自由元素，显然结果不够优秀:在更前面的，第三个区间的前端元素偏大，在字典序比较中，这已经比把这些元素抓走后的结果更小了。</p>\r\n<p>那反正就是把中间的抓出来嘛！</p>\r\n<p><del>然而把第二个区间前一段偏大的抓走也是错误的。</del></p>\r\n<p>别忘了，”自由“的元素也不是完全自由的。</p>\r\n<p>它们只能往自己的后方插入。看图来理解这个选择：</p>\r\n<p>把两个区间描述成这样的曲线，两个区间有一段大小叠合：</p>\r\n<figure>\r\n<img src=\"1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>如果是把后一个区间的bc段纳入自由元素，那么它在自由排序的时候会插入ab段中。这是不符合规则的。只有把前一个区间的ab段扔到自由元素里才行——它们会排列进bc段，这是合法的操作。</p>\r\n<figure>\r\n<img src=\"1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>那么怎么把这些元素放入自由序列呢？双指针指向需要比较的元素也是可行的，但出于好写和好懂的考虑，这里使用了栈的结构。</p>\r\n<p>从原始序列的队首开始，依次把元素压入栈中。</p>\r\n<p>如果新入栈元素比栈顶元素小或相等，不严格降序的结构不被破坏，继续入栈即可。</p>\r\n<p>如果新入栈元素比栈顶元素大，不严格降序的结构被破坏，把原来的栈顶元素弹出，进入自由元素的队列中，消耗一次操作机会（也就是入自由元素队的机会）。继续把新元素和新的栈顶比较，直到不严格降序的结构不被破坏。</p>\r\n<p>最后，我们得到了长度为k的自由元素队，把它们排序后插入序列中即可。</p>\r\n<p>注意，仍然留在栈中的元素记得退回序列。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">300010</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">300010</span>];<span class=\"comment\">//自由排序队 </span></span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">300010</span>];<span class=\"comment\">//比较等待栈 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tstd::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  std::cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> T;</span><br><span class=\"line\">\tcin&gt;&gt;T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n,k;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> stpb=<span class=\"number\">0</span>,stpc=<span class=\"number\">0</span>,stpa; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n&amp;&amp;k;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stpc==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\tc[stpc++]=a[i];<span class=\"comment\">//空栈则直接入栈 </span></span><br><span class=\"line\">\t\t\t\tstpa=i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(c[stpc<span class=\"number\">-1</span>]&lt;a[i])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(c[stpc<span class=\"number\">-1</span>]&gt;=a[i])<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\tb[stpb++]=c[stpc<span class=\"number\">-1</span>];<span class=\"comment\">//栈顶进队 </span></span><br><span class=\"line\">\t\t\t\t\t\tstpc--;</span><br><span class=\"line\">\t\t\t\t\t\tk--;<span class=\"comment\">//消耗一次进队机会 </span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(stpc==<span class=\"number\">0</span>||k==<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(k)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tc[stpc++]=a[i];</span><br><span class=\"line\">\t\t\t\t\t\tstpa=i;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tc[stpc++]=a[i];<span class=\"comment\">//新数进栈 </span></span><br><span class=\"line\">\t\t\t\t\tstpa=i;</span><br><span class=\"line\">\t\t\t\t&#125; </span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=stpc<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)a[stpa--]=c[i];<span class=\"comment\">//栈退回原始序列 </span></span><br><span class=\"line\">\t\tstpa++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(b,b+stpb);</span><br><span class=\"line\">\t\tstpb--;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(b[stpb]&gt;a[stpa]||stpa&gt;=n)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcout&lt;&lt;b[stpb--];</span><br><span class=\"line\">\t\t\t\t\tflag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;b[stpb--];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcout&lt;&lt;a[stpa++];</span><br><span class=\"line\">\t\t\t\t\tflag=<span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;a[stpa++];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stpb&lt;<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=stpa;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;a[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;a[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"meax\">1006-Meax</h1>\r\n<p>来源: 杭电杯超级联赛6 算法: DFS, 贪心 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1049&amp;pid=1006 补完: No ##\r\n代码 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> a[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> b[<span class=\"number\">500010</span>];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\ta[x]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;v[x].<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> y=v[x][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y==r) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(y,x);</span><br><span class=\"line\">\t\ta[x]+=a[y];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">//cout&lt;&lt;a[x]&lt;&lt;endl;</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">toans</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\tb[x]=a[x];</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> maxx=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;v[x].<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> y=v[x][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y==r) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">toans</span>(y,x);</span><br><span class=\"line\">\t\tmaxx=<span class=\"built_in\">max</span>(maxx,b[y]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tb[x]+=maxx;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tstd::cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t v[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\ta[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tb[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> u1,u2;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;u1&gt;&gt;u2;</span><br><span class=\"line\">\t\t\tv[u1].<span class=\"built_in\">push_back</span>(u2);</span><br><span class=\"line\">\t\t\tv[u2].<span class=\"built_in\">push_back</span>(u1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">toans</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tcout&lt;&lt;b[<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> # 1009-Map</p>\r\n<p>来源: 杭电杯超级联赛6 算法: 向量, 计算几何 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1049&amp;pid=1009 补完: Yes\r\n完成时间: August 12, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>有大地图<span class=\"math inline\">\\(M\\)</span>经过旋转压缩得到<span\r\nclass=\"math inline\">\\(m\\)</span>, 任落在<span\r\nclass=\"math inline\">\\(M\\)</span>内, 在空间中有一不动点同时在<span\r\nclass=\"math inline\">\\(M\\)</span>和<span\r\nclass=\"math inline\">\\(m\\)</span>上确定同一位置.</p>\r\n<p>设不动点为<span class=\"math inline\">\\(P\\)</span>, 设相对位置参数<span\r\nclass=\"math inline\">\\(\\lambda,\\mu\\)</span>, 可列方程</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n\\vec{OP}&amp;=\\vec{OA}+\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\r\n\\vec{OP}&amp;=\\vec{Oa}+\\lambda\\vec{ab}+\\mu\\vec{ad}\r\n\\end{align}\r\n\\]</span></p>\r\n<p>化简有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n\\vec{AP}&amp;=\\lambda\\vec{AB}+\\mu\\vec{AD}\\\\\r\n\\vec{aP}&amp;=\\lambda\\vec{ab}+\\mu\\vec{ad}\r\n\\end{align}\r\n\\]</span></p>\r\n<p>展开有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nP.x-A.x&amp;=\\lambda(B.x-A.x)+\\mu(D.x-A.x)\\\\\r\nP.y-A.y&amp;=\\lambda(B.y-A.y)+\\mu(D.y-A.y)\\\\\r\nP.x-a.x&amp;=\\lambda(b.x-a.x)+\\mu(d.x-a.x)\\\\\r\nP.y-a.y&amp;=\\lambda(b.y-a.y)+\\mu(d.y-a.y)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p>化简有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\na.x-A.x&amp;=\\lambda(B.x-b.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)\\\\\r\na.y-A.y&amp;=\\lambda(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p>展开有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n(a.x-A.x)(D.y-d.y+a.y-A.y)&amp;=\\lambda(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\r\n(a.y-A.y)(D.x-d.x+a.x-A.x)&amp;=\\lambda(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)+\\mu(D.x-d.x+a.x-A.x)(D.y-d.y+a.y-A.y)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n(a.x-A.x)(B.y-b.y+a.y-A.y)&amp;=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)\\\\\r\n(a.y-A.y)(B.x-b.x+a.x-A.x)&amp;=\\lambda(B.x-b.x+a.x-A.x)(B.y-b.y+a.y-A.y)+\\mu(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<p>化简有</p>\r\n<p><span class=\"math display\">\\[\r\n\\lambda=\\frac{(a.x-A.x)(D.y-d.y+a.y-A.y)-(a.y-A.y)(D.x-d.x+a.x-A.x)}{(B.x-b.x+a.x-A.x)(D.y-d.y+a.y-A.y)-(B.y-b.y+a.y-A.y)(D.x-d.x+a.x-A.x)}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\mu=\\frac{(a.x-A.x)(B.y-b.y+a.y-A.y)-(a.y-A.y)(B.x-b.x+a.x-A.x)}{(D.x-d.x+a.x-A.x)(B.y-b.y+a.y-A.y)-(D.y-d.y+a.y-A.y)(B.x-b.x+a.x-A.x)}\r\n\\]</span></p>\r\n<p>最后有</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nP.x&amp;=\\lambda(B.x-A.x)+\\mu(D.x-A.x)+A.x\\\\\r\nP.y&amp;=\\lambda(B.y-A.y)+\\mu(D.y-A.y)+A.y\\\\\r\n\\end{align}\r\n\\]</span></p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> Ax,Ay,Bx,By,Cx,Cy,Dx,Dy;</span><br><span class=\"line\">    <span class=\"type\">double</span> ax,ay,bx,by,cx,cy,dx,dy;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf%lf%lf%lf%lf%lf%lf%lf&quot;</span>,&amp;Ax,&amp;Ay,&amp;Bx,&amp;By,&amp;Cx,&amp;Cy,&amp;Dx,&amp;Dy);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%lf%lf%lf%lf%lf%lf%lf%lf&quot;</span>,&amp;ax,&amp;ay,&amp;bx,&amp;by,&amp;cx,&amp;cy,&amp;dx,&amp;dy);</span><br><span class=\"line\">    <span class=\"type\">double</span> alphaX = ax-Ax;</span><br><span class=\"line\">    <span class=\"type\">double</span> alphaY = ay-Ay;</span><br><span class=\"line\">    <span class=\"type\">double</span> betaX  = Bx-bx+alphaX;</span><br><span class=\"line\">    <span class=\"type\">double</span> betaY  = By-by+alphaY;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltaX = Dx-dx+alphaX;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltaY = Dy-dy+alphaY;</span><br><span class=\"line\">    <span class=\"type\">double</span> lambda = (alphaX*deltaY-alphaY*deltaX)/( betaX*deltaY- betaY*deltaX);</span><br><span class=\"line\">    <span class=\"type\">double</span> mu     = (alphaX* betaY-alphaY* betaX)/(deltaX* betaY-deltaY* betaX);</span><br><span class=\"line\">    <span class=\"type\">double</span> Px = lambda*(Bx-Ax)+mu*(Dx-Ax)+Ax;</span><br><span class=\"line\">    <span class=\"type\">double</span> Py = lambda*(By-Ay)+mu*(Dy-Ay)+Ay;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf %.15lf\\n&quot;</span>,Px,Py);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"loop\">1012-Loop</h1>\r\n<p>来源: 杭电杯超级联赛6 算法: 字典序, 栈 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1049&amp;pid=1012 补完: Yes\r\n完成时间: August 16, 2022</p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给定一个长度为n的数组a，进行严格的k次操作：选择两个整数l，r\r\n(1≤l≤r≤n)，让数组a_l到a_r循环左移一位。</p>\r\n<p>使得数组a的字典序最大，输出操作后的数组a。其中字典序比较的是每个a_i的值，不考虑a_i具体的数位。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>首先，由于l和r可以相等，所谓严格的k次操作其实相当于可以少于k次。</p>\r\n<p>接着，一次操作之后，发生了什么？</p>\r\n<p><del>不是循环左移一位吗题目又不是很难懂。</del></p>\r\n<p>我们换个角度看看，既然操作的时候可以任选区间，并且循环左移意味着最左的数字换到区间最右端——那么一次操作实际上是否是任选一个作为区间左节点的数字，把它放到它之后的任意位置呢？是的。</p>\r\n<p>也就是作为左区间的每个数字，都可以自由地插入其后的位置。</p>\r\n<p>既然是自由插入，那我们当然是直接把这部分自由的数字排序好放进去啦~</p>\r\n<p>那么怎么放进去呢？</p>\r\n<p>我们考虑插入前的序列的有序情况：</p>\r\n<p>如果原来的序列是降序的，自由插入一些数字，字典序最小的结果其实就是所有数字降序排列的结果。</p>\r\n<p>如果原来的序列是无序的，对于已经预先排好的待插入数字，每次都插在第一个比自己小的数字之前，才能让字典序更大。</p>\r\n<p>并且，使用无序的一般情况的方案插入有序数列，也能得到有序数列的最优方案，故而我们采用这种混合插入的方式来插入数列。</p>\r\n<p><del>那区分这个干什么啊。</del></p>\r\n<p>对待插入的原序列的分类得出的结论，很好地辅助了我们思考如何选取这些自由插入的数字。</p>\r\n<p>首先的首先，由于字典序先比较数列前端，那么在前面的数字优先。</p>\r\n<p>接着，回看前面插入有序序列的情况：往降序序列插入自由的元素，能得到所有元素降序排列的结果。这意味着没有必要把降序的序列数纳入自由元素，也能达到所有元素降序的最优的字典序结果。并且为了节省更多机会，相等的连续元素也视为降序，也就是非严格降序序列都不用纳入自由元素。</p>\r\n<p>而这样节省下来的操作次数，可以抓取更多的后面无序序列的元素，让它变成自由排列的。</p>\r\n<p>换句话说，我们选取<strong>破坏</strong>了非严格降序序列的数字。</p>\r\n<p>再然后，怎·么判断不用抓取的非严格降序区问呢？</p>\r\n<p>想象两个相邻的非严格降序区问，后一个区问最前端的一小段比前—个区间最后端的一段元素大。如果直接在原序列里做判断，不管怎样都是不够正确的(这里认为k足够大):</p>\r\n<p>后—个区间的第─个数字大于前—个区间的最后—个数字了，认为非严格降序区间结束了，把后—个区问连续扔进自由元素里，显然浪费了操作机会——删去前面—小段就能让剩下的数字合成—个非严格降序区间了。\r\n认为两个区问都是非严格降序区间，在第二个区问之后去抓自由元素，显然结果不够优秀:在更前面的，第三个区间的前端元素偏大，在字典序比较中，这已经比把这些元素抓走后的结果更小了。</p>\r\n<p>那反正就是把中间的抓出来嘛！</p>\r\n<p><del>然而把第二个区间前一段偏大的抓走也是错误的。</del></p>\r\n<p>别忘了，”自由“的元素也不是完全自由的。</p>\r\n<p>它们只能往自己的后方插入。看图来理解这个选择：</p>\r\n<p>把两个区间描述成这样的曲线，两个区间有一段大小叠合：</p>\r\n<figure>\r\n<img src=\"1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>如果是把后一个区间的bc段纳入自由元素，那么它在自由排序的时候会插入ab段中。这是不符合规则的。只有把前一个区间的ab段扔到自由元素里才行——它们会排列进bc段，这是合法的操作。</p>\r\n<figure>\r\n<img src=\"1012-Loop%20f82d7605f8b44a44a4559d7311567a9e/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>那么怎么把这些元素放入自由序列呢？双指针指向需要比较的元素也是可行的，但出于好写和好懂的考虑，这里使用了栈的结构。</p>\r\n<p>从原始序列的队首开始，依次把元素压入栈中。</p>\r\n<p>如果新入栈元素比栈顶元素小或相等，不严格降序的结构不被破坏，继续入栈即可。</p>\r\n<p>如果新入栈元素比栈顶元素大，不严格降序的结构被破坏，把原来的栈顶元素弹出，进入自由元素的队列中，消耗一次操作机会（也就是入自由元素队的机会）。继续把新元素和新的栈顶比较，直到不严格降序的结构不被破坏。</p>\r\n<p>最后，我们得到了长度为k的自由元素队，把它们排序后插入序列中即可。</p>\r\n<p>注意，仍然留在栈中的元素记得退回序列。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">300010</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">300010</span>];<span class=\"comment\">//自由排序队 </span></span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">300010</span>];<span class=\"comment\">//比较等待栈 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tstd::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  std::cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> T;</span><br><span class=\"line\">\tcin&gt;&gt;T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n,k;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> stpb=<span class=\"number\">0</span>,stpc=<span class=\"number\">0</span>,stpa; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n&amp;&amp;k;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stpc==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\tc[stpc++]=a[i];<span class=\"comment\">//空栈则直接入栈 </span></span><br><span class=\"line\">\t\t\t\tstpa=i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(c[stpc<span class=\"number\">-1</span>]&lt;a[i])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(c[stpc<span class=\"number\">-1</span>]&gt;=a[i])<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\tb[stpb++]=c[stpc<span class=\"number\">-1</span>];<span class=\"comment\">//栈顶进队 </span></span><br><span class=\"line\">\t\t\t\t\t\tstpc--;</span><br><span class=\"line\">\t\t\t\t\t\tk--;<span class=\"comment\">//消耗一次进队机会 </span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(stpc==<span class=\"number\">0</span>||k==<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(k)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tc[stpc++]=a[i];</span><br><span class=\"line\">\t\t\t\t\t\tstpa=i;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tc[stpc++]=a[i];<span class=\"comment\">//新数进栈 </span></span><br><span class=\"line\">\t\t\t\t\tstpa=i;</span><br><span class=\"line\">\t\t\t\t&#125; </span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=stpc<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)a[stpa--]=c[i];<span class=\"comment\">//栈退回原始序列 </span></span><br><span class=\"line\">\t\tstpa++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(b,b+stpb);</span><br><span class=\"line\">\t\tstpb--;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(b[stpb]&gt;a[stpa]||stpa&gt;=n)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcout&lt;&lt;b[stpb--];</span><br><span class=\"line\">\t\t\t\t\tflag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;b[stpb--];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcout&lt;&lt;a[stpa++];</span><br><span class=\"line\">\t\t\t\t\tflag=<span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;a[stpa++];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(stpb&lt;<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=stpa;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;a[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;a[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛07","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1004-Black Magic\n\n来源: 杭电杯超级联赛7\n算法: 贪心\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1050&pid=1004\n补完: Yes\n完成时间: August 9, 2022\n\n[题目链接](https://acm.hdu.edu.cn/contest/problem?cid=1050&pid=1004)\n\n## 题意简述\n\n有若干个方块，一种是纯白，一种左侧面是黑色，一种右侧面是黑色，一种是纯黑。黑魔法可以把两个黑色面相贴的方块合并成一个。\n\n给出四种方块的数量$E、L、R、B$。问把方块自由线性排列后合并，最后的方块总数量最小和最大的结果。\n\n## 题目分析\n\n读题，可知四种方块的特性是：白方块$E$不会和其他的方块合并，单侧黑的方块$L$和$R$放置成$RL$会合并，黑块$B$可以和黑块合并，串多长都行，或者在左右侧呈$RB/BL/RBL$形状和单侧方块合并。\n\n方块排列是**自由**的，直接给出一个**最优结果**即可，没有放置的先后顺序的要求，没有分步过程，也就没有后效性，直接**贪心**找到最合适的方案是可以尝试的。\n\n————\n\n先考虑数量最少。\n\n要让方块数量尽量少，就是要让方块尽量多地合并。\n\n首先，白色方块**无法合并**，把白色方块数量作为答案的最初值。\n\n对于黑色方块，它可以随意和左方块或者右方块连接，并且连接完左右方块还是保持原来的左或者右可以连接的情况。\n\n所以黑色方块**直接并入**左或者右方块，暂时不用考虑。\n\n对于左右方块。可以**成对**地合并，让方块尽量变少。\n\n多余出来的方块落单。\n\n也就是左或者右方块比较少的那个全数并入比较多的那个，答案贡献就是$max（L，R）$。\n\n再考虑比较特殊的情况：没有左右方块的时候。\n\n这时候黑色方块**不能**直接并入，那么把所有的黑色方块接在一起变成一块就行。对答案的贡献是$1$。\n\n————\n\n再考虑数量最多。\n\n与之前相反，这次我们要让左右方块尽量不要合并。显然，左右方块**同种**连续堆放的时候，不会发生合并。只有左右方块两种放在一起才会合并。而且左右方块一定要黑色那面贴合才会合并。那么我们只考虑左右方块的时候，只要把左方块全放在左边，右方块全放在右边，这样左右方块相接的地方也不会合并，没有方块减少的情况发生。\n\n使用1表示黑面，举个例子：\n\n…（1，0）（1，0）（0，1）（0，1）（0，1）（0，1）…\n\n两边可以无限叠放左右方块，都不会发生合并。\n\n那么他们就给答案来了$L+R$的贡献。\n\n保全了单边的方块之后，我们再看看很容易合并的纯黑方块。\n\n如果没有黑块，那很简单，把白块的数量也加入答案即可。\n\n如果有，我们试着把黑色方块插入，会发现只有左右方块界线的位置才不会发生合并。\n\n也就是变成：\n\n…（1，0）（1，1）（0，1）…\n\n再之后，黑块插入到**任意**位置都会被合并，那么我们方便起见，把黑块全部**堆放在中间**先。\n\n这样以后，我们插入白块来拯救这个情况。\n\n白块不止不会和其他方块合并，它还能**阻隔**会合并的方块。在这需要阻隔的是中间堆放着的黑方块群。\n\n很显然，如果白块数量$E$有黑块数量$B-1$以上，就可以在每两个黑块中间都插入一个白块。那么所有的黑白块都不会合并，$E+B$计入答案贡献。\n\n如果数量不够，那么每次插入一个白块，都可以让一组相邻的黑块被阻隔，相当于一个大黑块被切成两个，再插入一个，再切一刀。插入E个白块，黑块就被切成$E+1$段，这就是黑块的答案贡献。再加上白块E本身不会合并，总共的答案贡献就是$E+1+E=2*E+1$。\n\n最后按这个逻辑编写代码即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint E,L,R,B;\n\t\tcin>>E>>L>>R>>B;\n\t\tint ans=E;\n\t\tans+=max(L,R);\n\t\tif(L==0&&R==0&&B!=0){\n\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<' ';\n\t\t\n\t\tif(B==0){\n\t\t\tans=R+L+E;\n\t\t\tcout<<ans<<'\\n';\n\t\t}\n\t\telse{\n\t\t\tans=R+L;\n\t\t\tif(E>=B-1)ans+=E+B;\n\t\t\telse ans+=E*2+1;\n\t\t\tcout<<ans<<'\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n```\n# 1008-Triangle Gam\n\n来源: 杭电杯超级联赛7\n算法: Nim, 博弈论\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1050&pid=1008\n补完: Yes\n完成时间: August 9, 2022\n\n## 题意：\n\nKate和Emilico玩游戏，给定非退化三角形三条边长度分别为$a、b、c$，玩家轮流在$3$个整数中的一个上减少某个正整数。如果在游戏者的操作后不存在边长为$a、b、c$的非退化三角形，则游戏者失败。\n\nKate先手，问Kate会赢吗？若赢输出“Win”，否则输出“Lose”。\n\n## 解法：\n\n### 容易推出：\n\n要满足三角形两边之和大于第三边，如果有一条边是1，那么另外两条边一定是等长的，且当至少有一条边为1时，下一轮无论玩家减少哪一条边的边长，都无法形成三角形。\n\n### 因此题目转换为\n\nkate是否可以先将三角形的任一边变成1，可以就Win，否则Lose。\n\n### 现在引入一个经典博弈问题：Nim游戏\n\n$n$堆物品，每堆有$a_i$个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。\n\n取走最后一个物品的人获胜。\n\n当且仅当：$a_1\\oplus a_2 \\oplus ...\\oplus a_n = 0$，为先手必赢\n\n### 知识迁移\n\nNim游戏中是要将所有$a_i$变为0，该题目则是将$a、b、c$其中一个变为1，以此要先将$a、b、c$ 都减1，再进行异或运算。\n\n## 代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint a,b,c; \n\t\tcin>>a>>b>>c;\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\tif(a^b^c)cout<<\"Win\\n\";\n\t\telse cout<<\"Lose\\n\"; \n\t}\n\treturn 0;\n\t\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛07.md","raw":"---\ntitle: 2022杭电杯超级联赛07\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1004-Black Magic\n\n来源: 杭电杯超级联赛7\n算法: 贪心\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1050&pid=1004\n补完: Yes\n完成时间: August 9, 2022\n\n[题目链接](https://acm.hdu.edu.cn/contest/problem?cid=1050&pid=1004)\n\n## 题意简述\n\n有若干个方块，一种是纯白，一种左侧面是黑色，一种右侧面是黑色，一种是纯黑。黑魔法可以把两个黑色面相贴的方块合并成一个。\n\n给出四种方块的数量$E、L、R、B$。问把方块自由线性排列后合并，最后的方块总数量最小和最大的结果。\n\n## 题目分析\n\n读题，可知四种方块的特性是：白方块$E$不会和其他的方块合并，单侧黑的方块$L$和$R$放置成$RL$会合并，黑块$B$可以和黑块合并，串多长都行，或者在左右侧呈$RB/BL/RBL$形状和单侧方块合并。\n\n方块排列是**自由**的，直接给出一个**最优结果**即可，没有放置的先后顺序的要求，没有分步过程，也就没有后效性，直接**贪心**找到最合适的方案是可以尝试的。\n\n————\n\n先考虑数量最少。\n\n要让方块数量尽量少，就是要让方块尽量多地合并。\n\n首先，白色方块**无法合并**，把白色方块数量作为答案的最初值。\n\n对于黑色方块，它可以随意和左方块或者右方块连接，并且连接完左右方块还是保持原来的左或者右可以连接的情况。\n\n所以黑色方块**直接并入**左或者右方块，暂时不用考虑。\n\n对于左右方块。可以**成对**地合并，让方块尽量变少。\n\n多余出来的方块落单。\n\n也就是左或者右方块比较少的那个全数并入比较多的那个，答案贡献就是$max（L，R）$。\n\n再考虑比较特殊的情况：没有左右方块的时候。\n\n这时候黑色方块**不能**直接并入，那么把所有的黑色方块接在一起变成一块就行。对答案的贡献是$1$。\n\n————\n\n再考虑数量最多。\n\n与之前相反，这次我们要让左右方块尽量不要合并。显然，左右方块**同种**连续堆放的时候，不会发生合并。只有左右方块两种放在一起才会合并。而且左右方块一定要黑色那面贴合才会合并。那么我们只考虑左右方块的时候，只要把左方块全放在左边，右方块全放在右边，这样左右方块相接的地方也不会合并，没有方块减少的情况发生。\n\n使用1表示黑面，举个例子：\n\n…（1，0）（1，0）（0，1）（0，1）（0，1）（0，1）…\n\n两边可以无限叠放左右方块，都不会发生合并。\n\n那么他们就给答案来了$L+R$的贡献。\n\n保全了单边的方块之后，我们再看看很容易合并的纯黑方块。\n\n如果没有黑块，那很简单，把白块的数量也加入答案即可。\n\n如果有，我们试着把黑色方块插入，会发现只有左右方块界线的位置才不会发生合并。\n\n也就是变成：\n\n…（1，0）（1，1）（0，1）…\n\n再之后，黑块插入到**任意**位置都会被合并，那么我们方便起见，把黑块全部**堆放在中间**先。\n\n这样以后，我们插入白块来拯救这个情况。\n\n白块不止不会和其他方块合并，它还能**阻隔**会合并的方块。在这需要阻隔的是中间堆放着的黑方块群。\n\n很显然，如果白块数量$E$有黑块数量$B-1$以上，就可以在每两个黑块中间都插入一个白块。那么所有的黑白块都不会合并，$E+B$计入答案贡献。\n\n如果数量不够，那么每次插入一个白块，都可以让一组相邻的黑块被阻隔，相当于一个大黑块被切成两个，再插入一个，再切一刀。插入E个白块，黑块就被切成$E+1$段，这就是黑块的答案贡献。再加上白块E本身不会合并，总共的答案贡献就是$E+1+E=2*E+1$。\n\n最后按这个逻辑编写代码即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint E,L,R,B;\n\t\tcin>>E>>L>>R>>B;\n\t\tint ans=E;\n\t\tans+=max(L,R);\n\t\tif(L==0&&R==0&&B!=0){\n\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<' ';\n\t\t\n\t\tif(B==0){\n\t\t\tans=R+L+E;\n\t\t\tcout<<ans<<'\\n';\n\t\t}\n\t\telse{\n\t\t\tans=R+L;\n\t\t\tif(E>=B-1)ans+=E+B;\n\t\t\telse ans+=E*2+1;\n\t\t\tcout<<ans<<'\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n```\n# 1008-Triangle Gam\n\n来源: 杭电杯超级联赛7\n算法: Nim, 博弈论\n题目链接: https://acm.hdu.edu.cn/contest/problem?cid=1050&pid=1008\n补完: Yes\n完成时间: August 9, 2022\n\n## 题意：\n\nKate和Emilico玩游戏，给定非退化三角形三条边长度分别为$a、b、c$，玩家轮流在$3$个整数中的一个上减少某个正整数。如果在游戏者的操作后不存在边长为$a、b、c$的非退化三角形，则游戏者失败。\n\nKate先手，问Kate会赢吗？若赢输出“Win”，否则输出“Lose”。\n\n## 解法：\n\n### 容易推出：\n\n要满足三角形两边之和大于第三边，如果有一条边是1，那么另外两条边一定是等长的，且当至少有一条边为1时，下一轮无论玩家减少哪一条边的边长，都无法形成三角形。\n\n### 因此题目转换为\n\nkate是否可以先将三角形的任一边变成1，可以就Win，否则Lose。\n\n### 现在引入一个经典博弈问题：Nim游戏\n\n$n$堆物品，每堆有$a_i$个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。\n\n取走最后一个物品的人获胜。\n\n当且仅当：$a_1\\oplus a_2 \\oplus ...\\oplus a_n = 0$，为先手必赢\n\n### 知识迁移\n\nNim游戏中是要将所有$a_i$变为0，该题目则是将$a、b、c$其中一个变为1，以此要先将$a、b、c$ 都减1，再进行异或运算。\n\n## 代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint a,b,c; \n\t\tcin>>a>>b>>c;\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\tif(a^b^c)cout<<\"Win\\n\";\n\t\telse cout<<\"Lose\\n\"; \n\t}\n\treturn 0;\n\t\n}\n```\n","slug":"2022杭电杯超级联赛07","published":1,"updated":"2023-10-29T06:21:56.490Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex60006n0um5rt4a679","content":"<h1 id=\"black-magic\">1004-Black Magic</h1>\r\n<p>来源: 杭电杯超级联赛7 算法: 贪心 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1050&amp;pid=1004 补完: Yes\r\n完成时间: August 9, 2022</p>\r\n<p><a\r\nhref=\"https://acm.hdu.edu.cn/contest/problem?cid=1050&amp;pid=1004\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>有若干个方块，一种是纯白，一种左侧面是黑色，一种右侧面是黑色，一种是纯黑。黑魔法可以把两个黑色面相贴的方块合并成一个。</p>\r\n<p>给出四种方块的数量<span\r\nclass=\"math inline\">\\(E、L、R、B\\)</span>。问把方块自由线性排列后合并，最后的方块总数量最小和最大的结果。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>读题，可知四种方块的特性是：白方块<span\r\nclass=\"math inline\">\\(E\\)</span>不会和其他的方块合并，单侧黑的方块<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>放置成<span\r\nclass=\"math inline\">\\(RL\\)</span>会合并，黑块<span\r\nclass=\"math inline\">\\(B\\)</span>可以和黑块合并，串多长都行，或者在左右侧呈<span\r\nclass=\"math inline\">\\(RB/BL/RBL\\)</span>形状和单侧方块合并。</p>\r\n<p>方块排列是<strong>自由</strong>的，直接给出一个<strong>最优结果</strong>即可，没有放置的先后顺序的要求，没有分步过程，也就没有后效性，直接<strong>贪心</strong>找到最合适的方案是可以尝试的。</p>\r\n<p>————</p>\r\n<p>先考虑数量最少。</p>\r\n<p>要让方块数量尽量少，就是要让方块尽量多地合并。</p>\r\n<p>首先，白色方块<strong>无法合并</strong>，把白色方块数量作为答案的最初值。</p>\r\n<p>对于黑色方块，它可以随意和左方块或者右方块连接，并且连接完左右方块还是保持原来的左或者右可以连接的情况。</p>\r\n<p>所以黑色方块<strong>直接并入</strong>左或者右方块，暂时不用考虑。</p>\r\n<p>对于左右方块。可以<strong>成对</strong>地合并，让方块尽量变少。</p>\r\n<p>多余出来的方块落单。</p>\r\n<p>也就是左或者右方块比较少的那个全数并入比较多的那个，答案贡献就是<span\r\nclass=\"math inline\">\\(max（L，R）\\)</span>。</p>\r\n<p>再考虑比较特殊的情况：没有左右方块的时候。</p>\r\n<p>这时候黑色方块<strong>不能</strong>直接并入，那么把所有的黑色方块接在一起变成一块就行。对答案的贡献是<span\r\nclass=\"math inline\">\\(1\\)</span>。</p>\r\n<p>————</p>\r\n<p>再考虑数量最多。</p>\r\n<p>与之前相反，这次我们要让左右方块尽量不要合并。显然，左右方块<strong>同种</strong>连续堆放的时候，不会发生合并。只有左右方块两种放在一起才会合并。而且左右方块一定要黑色那面贴合才会合并。那么我们只考虑左右方块的时候，只要把左方块全放在左边，右方块全放在右边，这样左右方块相接的地方也不会合并，没有方块减少的情况发生。</p>\r\n<p>使用1表示黑面，举个例子：</p>\r\n<p>…（1，0）（1，0）（0，1）（0，1）（0，1）（0，1）…</p>\r\n<p>两边可以无限叠放左右方块，都不会发生合并。</p>\r\n<p>那么他们就给答案来了<span\r\nclass=\"math inline\">\\(L+R\\)</span>的贡献。</p>\r\n<p>保全了单边的方块之后，我们再看看很容易合并的纯黑方块。</p>\r\n<p>如果没有黑块，那很简单，把白块的数量也加入答案即可。</p>\r\n<p>如果有，我们试着把黑色方块插入，会发现只有左右方块界线的位置才不会发生合并。</p>\r\n<p>也就是变成：</p>\r\n<p>…（1，0）（1，1）（0，1）…</p>\r\n<p>再之后，黑块插入到<strong>任意</strong>位置都会被合并，那么我们方便起见，把黑块全部<strong>堆放在中间</strong>先。</p>\r\n<p>这样以后，我们插入白块来拯救这个情况。</p>\r\n<p>白块不止不会和其他方块合并，它还能<strong>阻隔</strong>会合并的方块。在这需要阻隔的是中间堆放着的黑方块群。</p>\r\n<p>很显然，如果白块数量<span\r\nclass=\"math inline\">\\(E\\)</span>有黑块数量<span\r\nclass=\"math inline\">\\(B-1\\)</span>以上，就可以在每两个黑块中间都插入一个白块。那么所有的黑白块都不会合并，<span\r\nclass=\"math inline\">\\(E+B\\)</span>计入答案贡献。</p>\r\n<p>如果数量不够，那么每次插入一个白块，都可以让一组相邻的黑块被阻隔，相当于一个大黑块被切成两个，再插入一个，再切一刀。插入E个白块，黑块就被切成<span\r\nclass=\"math inline\">\\(E+1\\)</span>段，这就是黑块的答案贡献。再加上白块E本身不会合并，总共的答案贡献就是<span\r\nclass=\"math inline\">\\(E+1+E=2*E+1\\)</span>。</p>\r\n<p>最后按这个逻辑编写代码即可。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> E,L,R,B;</span><br><span class=\"line\">\t\tcin&gt;&gt;E&gt;&gt;L&gt;&gt;R&gt;&gt;B;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans=E;</span><br><span class=\"line\">\t\tans+=<span class=\"built_in\">max</span>(L,R);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L==<span class=\"number\">0</span>&amp;&amp;R==<span class=\"number\">0</span>&amp;&amp;B!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tans++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(B==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tans=R+L+E;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tans=R+L;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(E&gt;=B<span class=\"number\">-1</span>)ans+=E+B;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ans+=E*<span class=\"number\">2</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"triangle-gam\">1008-Triangle Gam</h1>\r\n<p>来源: 杭电杯超级联赛7 算法: Nim, 博弈论 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1050&amp;pid=1008 补完: Yes\r\n完成时间: August 9, 2022</p>\r\n<h2 id=\"题意\">题意：</h2>\r\n<p>Kate和Emilico玩游戏，给定非退化三角形三条边长度分别为<span\r\nclass=\"math inline\">\\(a、b、c\\)</span>，玩家轮流在<span\r\nclass=\"math inline\">\\(3\\)</span>个整数中的一个上减少某个正整数。如果在游戏者的操作后不存在边长为<span\r\nclass=\"math inline\">\\(a、b、c\\)</span>的非退化三角形，则游戏者失败。</p>\r\n<p>Kate先手，问Kate会赢吗？若赢输出“Win”，否则输出“Lose”。</p>\r\n<h2 id=\"解法\">解法：</h2>\r\n<h3 id=\"容易推出\">容易推出：</h3>\r\n<p>要满足三角形两边之和大于第三边，如果有一条边是1，那么另外两条边一定是等长的，且当至少有一条边为1时，下一轮无论玩家减少哪一条边的边长，都无法形成三角形。</p>\r\n<h3 id=\"因此题目转换为\">因此题目转换为</h3>\r\n<p>kate是否可以先将三角形的任一边变成1，可以就Win，否则Lose。</p>\r\n<h3\r\nid=\"现在引入一个经典博弈问题nim游戏\">现在引入一个经典博弈问题：Nim游戏</h3>\r\n<p><span class=\"math inline\">\\(n\\)</span>堆物品，每堆有<span\r\nclass=\"math inline\">\\(a_i\\)</span>个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。</p>\r\n<p>取走最后一个物品的人获胜。</p>\r\n<p>当且仅当：<span class=\"math inline\">\\(a_1\\oplus a_2 \\oplus ...\\oplus\r\na_n = 0\\)</span>，为先手必赢</p>\r\n<h3 id=\"知识迁移\">知识迁移</h3>\r\n<p>Nim游戏中是要将所有<span\r\nclass=\"math inline\">\\(a_i\\)</span>变为0，该题目则是将<span\r\nclass=\"math inline\">\\(a、b、c\\)</span>其中一个变为1，以此要先将<span\r\nclass=\"math inline\">\\(a、b、c\\)</span> 都减1，再进行异或运算。</p>\r\n<h2 id=\"代码\">代码：</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a,b,c; </span><br><span class=\"line\">\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class=\"line\">\t\ta--;</span><br><span class=\"line\">\t\tb--;</span><br><span class=\"line\">\t\tc--;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a^b^c)cout&lt;&lt;<span class=\"string\">&quot;Win\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Lose\\n&quot;</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"black-magic\">1004-Black Magic</h1>\r\n<p>来源: 杭电杯超级联赛7 算法: 贪心 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1050&amp;pid=1004 补完: Yes\r\n完成时间: August 9, 2022</p>\r\n<p><a\r\nhref=\"https://acm.hdu.edu.cn/contest/problem?cid=1050&amp;pid=1004\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>有若干个方块，一种是纯白，一种左侧面是黑色，一种右侧面是黑色，一种是纯黑。黑魔法可以把两个黑色面相贴的方块合并成一个。</p>\r\n<p>给出四种方块的数量<span\r\nclass=\"math inline\">\\(E、L、R、B\\)</span>。问把方块自由线性排列后合并，最后的方块总数量最小和最大的结果。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>读题，可知四种方块的特性是：白方块<span\r\nclass=\"math inline\">\\(E\\)</span>不会和其他的方块合并，单侧黑的方块<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>放置成<span\r\nclass=\"math inline\">\\(RL\\)</span>会合并，黑块<span\r\nclass=\"math inline\">\\(B\\)</span>可以和黑块合并，串多长都行，或者在左右侧呈<span\r\nclass=\"math inline\">\\(RB/BL/RBL\\)</span>形状和单侧方块合并。</p>\r\n<p>方块排列是<strong>自由</strong>的，直接给出一个<strong>最优结果</strong>即可，没有放置的先后顺序的要求，没有分步过程，也就没有后效性，直接<strong>贪心</strong>找到最合适的方案是可以尝试的。</p>\r\n<p>————</p>\r\n<p>先考虑数量最少。</p>\r\n<p>要让方块数量尽量少，就是要让方块尽量多地合并。</p>\r\n<p>首先，白色方块<strong>无法合并</strong>，把白色方块数量作为答案的最初值。</p>\r\n<p>对于黑色方块，它可以随意和左方块或者右方块连接，并且连接完左右方块还是保持原来的左或者右可以连接的情况。</p>\r\n<p>所以黑色方块<strong>直接并入</strong>左或者右方块，暂时不用考虑。</p>\r\n<p>对于左右方块。可以<strong>成对</strong>地合并，让方块尽量变少。</p>\r\n<p>多余出来的方块落单。</p>\r\n<p>也就是左或者右方块比较少的那个全数并入比较多的那个，答案贡献就是<span\r\nclass=\"math inline\">\\(max（L，R）\\)</span>。</p>\r\n<p>再考虑比较特殊的情况：没有左右方块的时候。</p>\r\n<p>这时候黑色方块<strong>不能</strong>直接并入，那么把所有的黑色方块接在一起变成一块就行。对答案的贡献是<span\r\nclass=\"math inline\">\\(1\\)</span>。</p>\r\n<p>————</p>\r\n<p>再考虑数量最多。</p>\r\n<p>与之前相反，这次我们要让左右方块尽量不要合并。显然，左右方块<strong>同种</strong>连续堆放的时候，不会发生合并。只有左右方块两种放在一起才会合并。而且左右方块一定要黑色那面贴合才会合并。那么我们只考虑左右方块的时候，只要把左方块全放在左边，右方块全放在右边，这样左右方块相接的地方也不会合并，没有方块减少的情况发生。</p>\r\n<p>使用1表示黑面，举个例子：</p>\r\n<p>…（1，0）（1，0）（0，1）（0，1）（0，1）（0，1）…</p>\r\n<p>两边可以无限叠放左右方块，都不会发生合并。</p>\r\n<p>那么他们就给答案来了<span\r\nclass=\"math inline\">\\(L+R\\)</span>的贡献。</p>\r\n<p>保全了单边的方块之后，我们再看看很容易合并的纯黑方块。</p>\r\n<p>如果没有黑块，那很简单，把白块的数量也加入答案即可。</p>\r\n<p>如果有，我们试着把黑色方块插入，会发现只有左右方块界线的位置才不会发生合并。</p>\r\n<p>也就是变成：</p>\r\n<p>…（1，0）（1，1）（0，1）…</p>\r\n<p>再之后，黑块插入到<strong>任意</strong>位置都会被合并，那么我们方便起见，把黑块全部<strong>堆放在中间</strong>先。</p>\r\n<p>这样以后，我们插入白块来拯救这个情况。</p>\r\n<p>白块不止不会和其他方块合并，它还能<strong>阻隔</strong>会合并的方块。在这需要阻隔的是中间堆放着的黑方块群。</p>\r\n<p>很显然，如果白块数量<span\r\nclass=\"math inline\">\\(E\\)</span>有黑块数量<span\r\nclass=\"math inline\">\\(B-1\\)</span>以上，就可以在每两个黑块中间都插入一个白块。那么所有的黑白块都不会合并，<span\r\nclass=\"math inline\">\\(E+B\\)</span>计入答案贡献。</p>\r\n<p>如果数量不够，那么每次插入一个白块，都可以让一组相邻的黑块被阻隔，相当于一个大黑块被切成两个，再插入一个，再切一刀。插入E个白块，黑块就被切成<span\r\nclass=\"math inline\">\\(E+1\\)</span>段，这就是黑块的答案贡献。再加上白块E本身不会合并，总共的答案贡献就是<span\r\nclass=\"math inline\">\\(E+1+E=2*E+1\\)</span>。</p>\r\n<p>最后按这个逻辑编写代码即可。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> E,L,R,B;</span><br><span class=\"line\">\t\tcin&gt;&gt;E&gt;&gt;L&gt;&gt;R&gt;&gt;B;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans=E;</span><br><span class=\"line\">\t\tans+=<span class=\"built_in\">max</span>(L,R);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L==<span class=\"number\">0</span>&amp;&amp;R==<span class=\"number\">0</span>&amp;&amp;B!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tans++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(B==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tans=R+L+E;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tans=R+L;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(E&gt;=B<span class=\"number\">-1</span>)ans+=E+B;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ans+=E*<span class=\"number\">2</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"triangle-gam\">1008-Triangle Gam</h1>\r\n<p>来源: 杭电杯超级联赛7 算法: Nim, 博弈论 题目链接:\r\nhttps://acm.hdu.edu.cn/contest/problem?cid=1050&amp;pid=1008 补完: Yes\r\n完成时间: August 9, 2022</p>\r\n<h2 id=\"题意\">题意：</h2>\r\n<p>Kate和Emilico玩游戏，给定非退化三角形三条边长度分别为<span\r\nclass=\"math inline\">\\(a、b、c\\)</span>，玩家轮流在<span\r\nclass=\"math inline\">\\(3\\)</span>个整数中的一个上减少某个正整数。如果在游戏者的操作后不存在边长为<span\r\nclass=\"math inline\">\\(a、b、c\\)</span>的非退化三角形，则游戏者失败。</p>\r\n<p>Kate先手，问Kate会赢吗？若赢输出“Win”，否则输出“Lose”。</p>\r\n<h2 id=\"解法\">解法：</h2>\r\n<h3 id=\"容易推出\">容易推出：</h3>\r\n<p>要满足三角形两边之和大于第三边，如果有一条边是1，那么另外两条边一定是等长的，且当至少有一条边为1时，下一轮无论玩家减少哪一条边的边长，都无法形成三角形。</p>\r\n<h3 id=\"因此题目转换为\">因此题目转换为</h3>\r\n<p>kate是否可以先将三角形的任一边变成1，可以就Win，否则Lose。</p>\r\n<h3\r\nid=\"现在引入一个经典博弈问题nim游戏\">现在引入一个经典博弈问题：Nim游戏</h3>\r\n<p><span class=\"math inline\">\\(n\\)</span>堆物品，每堆有<span\r\nclass=\"math inline\">\\(a_i\\)</span>个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。</p>\r\n<p>取走最后一个物品的人获胜。</p>\r\n<p>当且仅当：<span class=\"math inline\">\\(a_1\\oplus a_2 \\oplus ...\\oplus\r\na_n = 0\\)</span>，为先手必赢</p>\r\n<h3 id=\"知识迁移\">知识迁移</h3>\r\n<p>Nim游戏中是要将所有<span\r\nclass=\"math inline\">\\(a_i\\)</span>变为0，该题目则是将<span\r\nclass=\"math inline\">\\(a、b、c\\)</span>其中一个变为1，以此要先将<span\r\nclass=\"math inline\">\\(a、b、c\\)</span> 都减1，再进行异或运算。</p>\r\n<h2 id=\"代码\">代码：</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a,b,c; </span><br><span class=\"line\">\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class=\"line\">\t\ta--;</span><br><span class=\"line\">\t\tb--;</span><br><span class=\"line\">\t\tc--;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a^b^c)cout&lt;&lt;<span class=\"string\">&quot;Win\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;Lose\\n&quot;</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛08","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1001-Theramore\n\n来源: 杭电杯超级联赛8\n算法: 贪心\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1001\n补完: Yes\n完成时间: August 11, 2022\n\n## 题意\n\n给定一个只含有‘0’和‘1’的字符串，有无数次机会可以选择长度为奇数的任意间隔并将其反转，输出能得到的字典序最小的字符串。\n\n## 解法\n\n因为只能选择长度为奇数的任意间隔，所以**奇数位置上的字符只能移动到奇数位置，偶数位置上的字符只能移动到偶数位置上**。例如：位置5上的’0‘是可以被移到位置1上的。\n\n我们可以分别计算出奇数位置上和偶数位置上‘0’的个数，然后从前往后对应奇偶位置地放置这些’0‘（原来奇数位置上的’0‘还是要放在奇数位置上），放完’0‘后，就可以开始放’1‘，这样的字符串就是能得到的字典序最小的字符串。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<stdio.h> \nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint a=0,b=0;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(i%2==0&&s[i]=='0')a++;\n\t\t\tif(i%2==1&&s[i]=='0')b++;\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(i%2==0){\n\t\t\t\tif(a>0){\n\t\t\t\t\tputchar('0');\n\t\t\t\t\ta--;\n\t\t\t\t}\n\t\t\t\telse putchar('1');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(b>0){\n\t\t\t\t\tputchar('0');\n\t\t\t\t\tb--;\n\t\t\t\t}\n\t\t\t\telse putchar('1');\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n\t\n}\n```\n# 1004-Quel'Thalas\n\n来源: 杭电杯超级联赛8\n算法: 模拟\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1004\n补完: Yes\n完成时间: August 11, 2022\n\n## 题解\n\n问使用几条线可以覆盖$[0,0]\\sim[n,n]$且不包括$[0,0]$的所有点, 以$n$条竖线和$n$条横线即可.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin>>n;\n    cout<<2*n<<endl;\n}\n\nint main() {\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# 1008-Orgrimmar\n\n来源: 杭电杯超级联赛8\n算法: 动态规划, 树形DP\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1008\n补完: Yes\n完成时间: August 11, 2022\n\n[题目链接](https://acm.dingbacode.com/contest/problem?cid=1051&pid=1008)\n\n## 题意简述\n\n给一个有$n$个节点，$n-1$条边的无向连通图（树），任意删除一些点（以及连接它的边），使得剩下的点构成若干个**离散集**，其中离散集的定义是每个点至多连接了一条边。\n\n求最多剩下多少点。\n\n## 题目分析\n\n**——题意理解——**\n\n要让剩下的点满足这个离散集的定义，那么点要么干脆是**孤立的点**，要么是**两个点**由一条边相连。超过三个点相连就必定有一个点和另外两点相连，连接了至少两条边。\n\n**——初步思路——**\n\n首先我们考虑把树切割成链。\n\n删除若干个点之后树变成了若干条链，那么对一条链，每三个点删除一个点，就能让所有的点都满足定义。\n\n~~但是好难噢，树链剖分也不是删点剖的，连板子都没有。~~\n\n构造一些样例尝试之后，也很容易发现删除点是有后效性的，贪心这条路可能也走不通。\n\n具体表现在一个节点被删除之后，它的子树的状态会收到影响。\n\n~~这么一看好像DP噢，试试，试试。~~\n\n**——经典引入——**\n\n本题的要求和一种经典的树形DP非常吻合——**求树的最大独立集**\n\n> 独立集：图的一个顶点子集，该子集中的任意两个项点在图中不相邻。\n> \n\n首先，和大部分树形DP相同，整体上使用类似后序遍历的DFS跑，也就是先求子树的最优解，再合并求出亲节点的最优解，最后询问根节点的最优解。\n\n再确定我们需要的变量。首先，必不可少的一个变量表示当前的**节点编号**；接着，在这个情景里，每个节点有**两种选择**：选入集合/不选入集合。\n\n我们用$f[i][0]$表示不选i节点，用$f[i][1]$表示选$i$节点。DP函数$f$的值是以$i$为根节点的子树中的最大独立集节点数（如果点有权值，则是最大点权和）。\n\n如果我们**不选**$i$节点，那么它所有的子节点都是**可选择**的。用$j$表示$i$的子节点，那么就有：\n\n$f[i][0]=\\sum max(f[j][0],f[j][1])$ ;\n\n如果我们**选**了$i$节点，那么它的所有子节点都**不能选择**，否则i就不是独立的点了。\n\n$f[i][1]=\\sum f[j][0];$\n\n**——迁移使用——**\n\n本题和求树的最大独立集的问题的差别在于，不要求选取的点集中所有的点都是独立的点，还可以有若干个两个节点相连的点对。\n\n我们还是先试着用$f[i][0]$表示不选i节点，用$f[i][1]$表示选$i$节点。\n\n如果我们不选$i$节点，那么它所有的子节点仍然都是可选择的。用$j$表示$i$的子节点，那么**同样**有：\n\n$f[i][0]=\\sum max(f[j][0],f[j][1])$ ;\n\n但是，如果我们选了i节点，**并不是**所有的子节点都不能选择。i可以不是独立的点，它可以和其中**一个**子节点连接成一个**点对**。\n\n如果它和一个子节点连接成了一个点对，那么这个子节点的所有子节点，也就是i的孙辈节点都**不能**再选择了，否则就会形成一个三个点相连的链，不符合题目要求。\n\n当然，也可以一个子节点都不选。这样i的孙辈节点仍然可以**自由选择**。\n\n既然出现了分异，那么一个$f[i][1]$就不够用了。\n\n我们使用$f[i][1]$表示和之前一样的，不选择任何子节点的情况。那么状态转移方程显然**还是**那个样子：\n\n$f[i][1]=\\sum f[j][0];$\n\n另外加一个$f[i][2]$表示选了一个子节点的情况。\n\n具体选哪个子节点，当然贪心地选择选了之后贡献最多的那个。记住选择这个点之后，孙辈的点不能选，所以选择的状态是$f[j][1]$而不可以是$f[j][2]$。\n\n也就是$max(f[j][1]-f[j][0])$对应的点。\n\n处理的时候让$f[i][2]$和$f[i][1$]先一起累计$\\sum f[j][0]$，最后$f[i][2]$加上选择的子节点多出来的贡献就行。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<vector> \nusing namespace std; \nconst int N = 5e5 + 10;\nvector<int> tr[N];\nint f[N][3],n;\nvoid dfs(int u,int k) {\n  f[u][0]=0;\n\tf[u][1]=1;\n\tf[u][2]=1;\n\tint d=0;\n    for (int i=0;i<tr[u].size();i++) {\n    \tint v=tr[u][i];\n        if(v==k)continue;//双向连边的情况下要防止搜回亲节点\n        dfs(v,u);\n        f[u][0]+=max(max(f[v][0], f[v][1]),f[v][2]);\n        f[u][1]+=f[v][0];\n        f[u][2]+=f[v][0];\n        d=max(d,f[v][1]-f[v][0]);\n    }\n    f[u][2]+=d;\n}\nint main() {\n\t\t//题目给的建议加入的代码\n\t\tint size(512<<20);  // 512M\n    __asm__ ( \"movq %0, %%rsp\\n\"::\"r\"((char*)malloc(size)+size));\n\t\t//\n    ios::sync_with_stdio(false);\n    int t;\n    cin>>t;\n    while(t--){\n    \tfor(int i=1;i<=N;i++)tr[i].clear();\n    \tcin >> n;\n    \tfor (int i=0;i<n-1;i++) {\n    \t\tint x,y;\n    \t    cin >>x>>y;\n    \t    tr[y].push_back(x);\n    \t    tr[x].push_back(y);\n    \t}\n    \tdfs(1,0);\n    \tcout <<max(max(f[1][0], f[1][1]),f[1][2])<<'\\n';\n    }\n    //return 0;  //加上会re \n    exit(0); \n}\n```\n# 1011-Stormwind\n\n来源: 杭电杯超级联赛8\n算法: 枚举, 贪心\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1011\n补完: Yes\n完成时间: August 11, 2022\n\n[题目链接](https://acm.dingbacode.com/contest/problem?cid=1051&pid=1011)\n\n## 题意简述\n\n给一个边长$n*m$的矩形，$n$和$m$是整数。平行矩形边切割这个矩形，把它分成若干的小矩形。每次切割都贯穿矩形，也就是切割线一定要交于原矩形的两边。要求每个小矩形边长是整数且面积不小于k。\n\n求最多切割次数。\n\n## 题目分析\n\n~~切割欸，乍一看好像不能贪心。~~\n\n但由于本题切割要求的特殊性：每一次切割都**贯穿**矩形，也就是**不会**有呈T型或者L型镶嵌的矩形存在，小矩形一定是规规整整，每行每列固定数量**整齐排列**的。\n\n其实也就是确定一个横着切几刀和纵着切几刀的方案。\n\n那么我们是可以**贪心**的：显然每个矩形在满足面积大于k的情况下应该**尽量小**，这样才可能切出**更多**矩形，在这样规整的切割里也就是切**更多次**了。\n\n也就是对于一个一边长为$i$的小矩形，我们找到最小的$j$作为另一个边长，满足$i*j≥k$。\n\n那么$j$就是$k/i$向上取整。也就是确定$i$之后，$j$跟着确定了。\n\n确定了小矩形的长和宽之后，我们可以**直接计算**出大矩形能切出几个小矩形来。\n\n比如大矩形一边长为$n$，对应小矩形的边长为$i$，$n/i$向下取整就是分割数量，切割次数比这个值**小1**。\n\n另一边同理。\n\n这样以来，我们**只要**确定一个小矩形边长之一的$i$，这个方案对应的答案就能计算出来了。\n\n本题保证大矩形边长在$1e5$以内，显然遍历枚举$1e5$范围内的整数$i$是可以接受的。\n\n甚至因为只需要满足$i*j≥k$，所以i遍历到$sqrt（k）$就可以结束，再之后的$ij$数对是重复的（比如2*5和5*2）。\n\n需要注意，如果计算出来一边切不出哪怕一个小矩形，也就是形如$n<i$的情况，那么这个答案是**无效**的。\n\n最后使用一个变量更新最大答案即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cmath> \nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,m,k;\n\t\tcin>>n>>m>>k;\n\t\tint ans=0;\n\t\tfor(int i=1;i<=sqrt(k);i++){//枚举矩形的一个变成i \n\t\t\tint j=k/i;\n\t\t\tif(i*j<k)j++;//找到满足i*j>=k的最小的j \n\t\t\t//n边切i \n\t\t\tint a=n/i;//n边可以分出几个i长度的段 \n\t\t\tint b=m/j;\n\t\t\tif(a!=0&&b!=0)//有一边一段都分不出来，答案无效 \n\t\t\tans=max(ans,a+b-2);//否则更新答案 \n\t\t\t//n边切j \n\t\t\ta=n/j;\n\t\t\tb=m/i;\n\t\t\tif(a!=0&&b!=0)\n\t\t\tans=max(ans,a+b-2);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t} \n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛08.md","raw":"---\ntitle: 2022杭电杯超级联赛08\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1001-Theramore\n\n来源: 杭电杯超级联赛8\n算法: 贪心\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1001\n补完: Yes\n完成时间: August 11, 2022\n\n## 题意\n\n给定一个只含有‘0’和‘1’的字符串，有无数次机会可以选择长度为奇数的任意间隔并将其反转，输出能得到的字典序最小的字符串。\n\n## 解法\n\n因为只能选择长度为奇数的任意间隔，所以**奇数位置上的字符只能移动到奇数位置，偶数位置上的字符只能移动到偶数位置上**。例如：位置5上的’0‘是可以被移到位置1上的。\n\n我们可以分别计算出奇数位置上和偶数位置上‘0’的个数，然后从前往后对应奇偶位置地放置这些’0‘（原来奇数位置上的’0‘还是要放在奇数位置上），放完’0‘后，就可以开始放’1‘，这样的字符串就是能得到的字典序最小的字符串。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<stdio.h> \nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint a=0,b=0;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(i%2==0&&s[i]=='0')a++;\n\t\t\tif(i%2==1&&s[i]=='0')b++;\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(i%2==0){\n\t\t\t\tif(a>0){\n\t\t\t\t\tputchar('0');\n\t\t\t\t\ta--;\n\t\t\t\t}\n\t\t\t\telse putchar('1');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(b>0){\n\t\t\t\t\tputchar('0');\n\t\t\t\t\tb--;\n\t\t\t\t}\n\t\t\t\telse putchar('1');\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n\t\n}\n```\n# 1004-Quel'Thalas\n\n来源: 杭电杯超级联赛8\n算法: 模拟\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1004\n补完: Yes\n完成时间: August 11, 2022\n\n## 题解\n\n问使用几条线可以覆盖$[0,0]\\sim[n,n]$且不包括$[0,0]$的所有点, 以$n$条竖线和$n$条横线即可.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin>>n;\n    cout<<2*n<<endl;\n}\n\nint main() {\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# 1008-Orgrimmar\n\n来源: 杭电杯超级联赛8\n算法: 动态规划, 树形DP\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1008\n补完: Yes\n完成时间: August 11, 2022\n\n[题目链接](https://acm.dingbacode.com/contest/problem?cid=1051&pid=1008)\n\n## 题意简述\n\n给一个有$n$个节点，$n-1$条边的无向连通图（树），任意删除一些点（以及连接它的边），使得剩下的点构成若干个**离散集**，其中离散集的定义是每个点至多连接了一条边。\n\n求最多剩下多少点。\n\n## 题目分析\n\n**——题意理解——**\n\n要让剩下的点满足这个离散集的定义，那么点要么干脆是**孤立的点**，要么是**两个点**由一条边相连。超过三个点相连就必定有一个点和另外两点相连，连接了至少两条边。\n\n**——初步思路——**\n\n首先我们考虑把树切割成链。\n\n删除若干个点之后树变成了若干条链，那么对一条链，每三个点删除一个点，就能让所有的点都满足定义。\n\n~~但是好难噢，树链剖分也不是删点剖的，连板子都没有。~~\n\n构造一些样例尝试之后，也很容易发现删除点是有后效性的，贪心这条路可能也走不通。\n\n具体表现在一个节点被删除之后，它的子树的状态会收到影响。\n\n~~这么一看好像DP噢，试试，试试。~~\n\n**——经典引入——**\n\n本题的要求和一种经典的树形DP非常吻合——**求树的最大独立集**\n\n> 独立集：图的一个顶点子集，该子集中的任意两个项点在图中不相邻。\n> \n\n首先，和大部分树形DP相同，整体上使用类似后序遍历的DFS跑，也就是先求子树的最优解，再合并求出亲节点的最优解，最后询问根节点的最优解。\n\n再确定我们需要的变量。首先，必不可少的一个变量表示当前的**节点编号**；接着，在这个情景里，每个节点有**两种选择**：选入集合/不选入集合。\n\n我们用$f[i][0]$表示不选i节点，用$f[i][1]$表示选$i$节点。DP函数$f$的值是以$i$为根节点的子树中的最大独立集节点数（如果点有权值，则是最大点权和）。\n\n如果我们**不选**$i$节点，那么它所有的子节点都是**可选择**的。用$j$表示$i$的子节点，那么就有：\n\n$f[i][0]=\\sum max(f[j][0],f[j][1])$ ;\n\n如果我们**选**了$i$节点，那么它的所有子节点都**不能选择**，否则i就不是独立的点了。\n\n$f[i][1]=\\sum f[j][0];$\n\n**——迁移使用——**\n\n本题和求树的最大独立集的问题的差别在于，不要求选取的点集中所有的点都是独立的点，还可以有若干个两个节点相连的点对。\n\n我们还是先试着用$f[i][0]$表示不选i节点，用$f[i][1]$表示选$i$节点。\n\n如果我们不选$i$节点，那么它所有的子节点仍然都是可选择的。用$j$表示$i$的子节点，那么**同样**有：\n\n$f[i][0]=\\sum max(f[j][0],f[j][1])$ ;\n\n但是，如果我们选了i节点，**并不是**所有的子节点都不能选择。i可以不是独立的点，它可以和其中**一个**子节点连接成一个**点对**。\n\n如果它和一个子节点连接成了一个点对，那么这个子节点的所有子节点，也就是i的孙辈节点都**不能**再选择了，否则就会形成一个三个点相连的链，不符合题目要求。\n\n当然，也可以一个子节点都不选。这样i的孙辈节点仍然可以**自由选择**。\n\n既然出现了分异，那么一个$f[i][1]$就不够用了。\n\n我们使用$f[i][1]$表示和之前一样的，不选择任何子节点的情况。那么状态转移方程显然**还是**那个样子：\n\n$f[i][1]=\\sum f[j][0];$\n\n另外加一个$f[i][2]$表示选了一个子节点的情况。\n\n具体选哪个子节点，当然贪心地选择选了之后贡献最多的那个。记住选择这个点之后，孙辈的点不能选，所以选择的状态是$f[j][1]$而不可以是$f[j][2]$。\n\n也就是$max(f[j][1]-f[j][0])$对应的点。\n\n处理的时候让$f[i][2]$和$f[i][1$]先一起累计$\\sum f[j][0]$，最后$f[i][2]$加上选择的子节点多出来的贡献就行。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<vector> \nusing namespace std; \nconst int N = 5e5 + 10;\nvector<int> tr[N];\nint f[N][3],n;\nvoid dfs(int u,int k) {\n  f[u][0]=0;\n\tf[u][1]=1;\n\tf[u][2]=1;\n\tint d=0;\n    for (int i=0;i<tr[u].size();i++) {\n    \tint v=tr[u][i];\n        if(v==k)continue;//双向连边的情况下要防止搜回亲节点\n        dfs(v,u);\n        f[u][0]+=max(max(f[v][0], f[v][1]),f[v][2]);\n        f[u][1]+=f[v][0];\n        f[u][2]+=f[v][0];\n        d=max(d,f[v][1]-f[v][0]);\n    }\n    f[u][2]+=d;\n}\nint main() {\n\t\t//题目给的建议加入的代码\n\t\tint size(512<<20);  // 512M\n    __asm__ ( \"movq %0, %%rsp\\n\"::\"r\"((char*)malloc(size)+size));\n\t\t//\n    ios::sync_with_stdio(false);\n    int t;\n    cin>>t;\n    while(t--){\n    \tfor(int i=1;i<=N;i++)tr[i].clear();\n    \tcin >> n;\n    \tfor (int i=0;i<n-1;i++) {\n    \t\tint x,y;\n    \t    cin >>x>>y;\n    \t    tr[y].push_back(x);\n    \t    tr[x].push_back(y);\n    \t}\n    \tdfs(1,0);\n    \tcout <<max(max(f[1][0], f[1][1]),f[1][2])<<'\\n';\n    }\n    //return 0;  //加上会re \n    exit(0); \n}\n```\n# 1011-Stormwind\n\n来源: 杭电杯超级联赛8\n算法: 枚举, 贪心\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1051&pid=1011\n补完: Yes\n完成时间: August 11, 2022\n\n[题目链接](https://acm.dingbacode.com/contest/problem?cid=1051&pid=1011)\n\n## 题意简述\n\n给一个边长$n*m$的矩形，$n$和$m$是整数。平行矩形边切割这个矩形，把它分成若干的小矩形。每次切割都贯穿矩形，也就是切割线一定要交于原矩形的两边。要求每个小矩形边长是整数且面积不小于k。\n\n求最多切割次数。\n\n## 题目分析\n\n~~切割欸，乍一看好像不能贪心。~~\n\n但由于本题切割要求的特殊性：每一次切割都**贯穿**矩形，也就是**不会**有呈T型或者L型镶嵌的矩形存在，小矩形一定是规规整整，每行每列固定数量**整齐排列**的。\n\n其实也就是确定一个横着切几刀和纵着切几刀的方案。\n\n那么我们是可以**贪心**的：显然每个矩形在满足面积大于k的情况下应该**尽量小**，这样才可能切出**更多**矩形，在这样规整的切割里也就是切**更多次**了。\n\n也就是对于一个一边长为$i$的小矩形，我们找到最小的$j$作为另一个边长，满足$i*j≥k$。\n\n那么$j$就是$k/i$向上取整。也就是确定$i$之后，$j$跟着确定了。\n\n确定了小矩形的长和宽之后，我们可以**直接计算**出大矩形能切出几个小矩形来。\n\n比如大矩形一边长为$n$，对应小矩形的边长为$i$，$n/i$向下取整就是分割数量，切割次数比这个值**小1**。\n\n另一边同理。\n\n这样以来，我们**只要**确定一个小矩形边长之一的$i$，这个方案对应的答案就能计算出来了。\n\n本题保证大矩形边长在$1e5$以内，显然遍历枚举$1e5$范围内的整数$i$是可以接受的。\n\n甚至因为只需要满足$i*j≥k$，所以i遍历到$sqrt（k）$就可以结束，再之后的$ij$数对是重复的（比如2*5和5*2）。\n\n需要注意，如果计算出来一边切不出哪怕一个小矩形，也就是形如$n<i$的情况，那么这个答案是**无效**的。\n\n最后使用一个变量更新最大答案即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cmath> \nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,m,k;\n\t\tcin>>n>>m>>k;\n\t\tint ans=0;\n\t\tfor(int i=1;i<=sqrt(k);i++){//枚举矩形的一个变成i \n\t\t\tint j=k/i;\n\t\t\tif(i*j<k)j++;//找到满足i*j>=k的最小的j \n\t\t\t//n边切i \n\t\t\tint a=n/i;//n边可以分出几个i长度的段 \n\t\t\tint b=m/j;\n\t\t\tif(a!=0&&b!=0)//有一边一段都分不出来，答案无效 \n\t\t\tans=max(ans,a+b-2);//否则更新答案 \n\t\t\t//n边切j \n\t\t\ta=n/j;\n\t\t\tb=m/i;\n\t\t\tif(a!=0&&b!=0)\n\t\t\tans=max(ans,a+b-2);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t} \n}\n```\n","slug":"2022杭电杯超级联赛08","published":1,"updated":"2023-10-29T06:24:43.580Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex70007n0um8s33b91n","content":"<h1 id=\"theramore\">1001-Theramore</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 贪心 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1001 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>给定一个只含有‘0’和‘1’的字符串，有无数次机会可以选择长度为奇数的任意间隔并将其反转，输出能得到的字典序最小的字符串。</p>\r\n<h2 id=\"解法\">解法</h2>\r\n<p>因为只能选择长度为奇数的任意间隔，所以<strong>奇数位置上的字符只能移动到奇数位置，偶数位置上的字符只能移动到偶数位置上</strong>。例如：位置5上的’0‘是可以被移到位置1上的。</p>\r\n<p>我们可以分别计算出奇数位置上和偶数位置上‘0’的个数，然后从前往后对应奇偶位置地放置这些’0‘（原来奇数位置上的’0‘还是要放在奇数位置上），放完’0‘后，就可以开始放’1‘，这样的字符串就是能得到的字典序最小的字符串。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\tstring s;</span><br><span class=\"line\">\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a=<span class=\"number\">0</span>,b=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;s[i]==<span class=\"string\">&#x27;0&#x27;</span>)a++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">1</span>&amp;&amp;s[i]==<span class=\"string\">&#x27;0&#x27;</span>)b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t\t\ta--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(b&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t\t\tb--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"quelthalas\">1004-Quel'Thalas</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 模拟 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1004 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>问使用几条线可以覆盖<span\r\nclass=\"math inline\">\\([0,0]\\sim[n,n]\\)</span>且不包括<span\r\nclass=\"math inline\">\\([0,0]\\)</span>的所有点, 以<span\r\nclass=\"math inline\">\\(n\\)</span>条竖线和<span\r\nclass=\"math inline\">\\(n\\)</span>条横线即可.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"number\">2</span>*n&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"orgrimmar\">1008-Orgrimmar</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 动态规划, 树形DP 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1008 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<p><a\r\nhref=\"https://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1008\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给一个有<span class=\"math inline\">\\(n\\)</span>个节点，<span\r\nclass=\"math inline\">\\(n-1\\)</span>条边的无向连通图（树），任意删除一些点（以及连接它的边），使得剩下的点构成若干个<strong>离散集</strong>，其中离散集的定义是每个点至多连接了一条边。</p>\r\n<p>求最多剩下多少点。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p><strong>——题意理解——</strong></p>\r\n<p>要让剩下的点满足这个离散集的定义，那么点要么干脆是<strong>孤立的点</strong>，要么是<strong>两个点</strong>由一条边相连。超过三个点相连就必定有一个点和另外两点相连，连接了至少两条边。</p>\r\n<p><strong>——初步思路——</strong></p>\r\n<p>首先我们考虑把树切割成链。</p>\r\n<p>删除若干个点之后树变成了若干条链，那么对一条链，每三个点删除一个点，就能让所有的点都满足定义。</p>\r\n<p><del>但是好难噢，树链剖分也不是删点剖的，连板子都没有。</del></p>\r\n<p>构造一些样例尝试之后，也很容易发现删除点是有后效性的，贪心这条路可能也走不通。</p>\r\n<p>具体表现在一个节点被删除之后，它的子树的状态会收到影响。</p>\r\n<p><del>这么一看好像DP噢，试试，试试。</del></p>\r\n<p><strong>——经典引入——</strong></p>\r\n<p>本题的要求和一种经典的树形DP非常吻合——<strong>求树的最大独立集</strong></p>\r\n<blockquote>\r\n<p>独立集：图的一个顶点子集，该子集中的任意两个项点在图中不相邻。</p>\r\n</blockquote>\r\n<p>首先，和大部分树形DP相同，整体上使用类似后序遍历的DFS跑，也就是先求子树的最优解，再合并求出亲节点的最优解，最后询问根节点的最优解。</p>\r\n<p>再确定我们需要的变量。首先，必不可少的一个变量表示当前的<strong>节点编号</strong>；接着，在这个情景里，每个节点有<strong>两种选择</strong>：选入集合/不选入集合。</p>\r\n<p>我们用<span\r\nclass=\"math inline\">\\(f[i][0]\\)</span>表示不选i节点，用<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>表示选<span\r\nclass=\"math inline\">\\(i\\)</span>节点。DP函数<span\r\nclass=\"math inline\">\\(f\\)</span>的值是以<span\r\nclass=\"math inline\">\\(i\\)</span>为根节点的子树中的最大独立集节点数（如果点有权值，则是最大点权和）。</p>\r\n<p>如果我们<strong>不选</strong><span\r\nclass=\"math inline\">\\(i\\)</span>节点，那么它所有的子节点都是<strong>可选择</strong>的。用<span\r\nclass=\"math inline\">\\(j\\)</span>表示<span\r\nclass=\"math inline\">\\(i\\)</span>的子节点，那么就有：</p>\r\n<p><span class=\"math inline\">\\(f[i][0]=\\sum\r\nmax(f[j][0],f[j][1])\\)</span> ;</p>\r\n<p>如果我们<strong>选</strong>了<span\r\nclass=\"math inline\">\\(i\\)</span>节点，那么它的所有子节点都<strong>不能选择</strong>，否则i就不是独立的点了。</p>\r\n<p><span class=\"math inline\">\\(f[i][1]=\\sum f[j][0];\\)</span></p>\r\n<p><strong>——迁移使用——</strong></p>\r\n<p>本题和求树的最大独立集的问题的差别在于，不要求选取的点集中所有的点都是独立的点，还可以有若干个两个节点相连的点对。</p>\r\n<p>我们还是先试着用<span\r\nclass=\"math inline\">\\(f[i][0]\\)</span>表示不选i节点，用<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>表示选<span\r\nclass=\"math inline\">\\(i\\)</span>节点。</p>\r\n<p>如果我们不选<span\r\nclass=\"math inline\">\\(i\\)</span>节点，那么它所有的子节点仍然都是可选择的。用<span\r\nclass=\"math inline\">\\(j\\)</span>表示<span\r\nclass=\"math inline\">\\(i\\)</span>的子节点，那么<strong>同样</strong>有：</p>\r\n<p><span class=\"math inline\">\\(f[i][0]=\\sum\r\nmax(f[j][0],f[j][1])\\)</span> ;</p>\r\n<p>但是，如果我们选了i节点，<strong>并不是</strong>所有的子节点都不能选择。i可以不是独立的点，它可以和其中<strong>一个</strong>子节点连接成一个<strong>点对</strong>。</p>\r\n<p>如果它和一个子节点连接成了一个点对，那么这个子节点的所有子节点，也就是i的孙辈节点都<strong>不能</strong>再选择了，否则就会形成一个三个点相连的链，不符合题目要求。</p>\r\n<p>当然，也可以一个子节点都不选。这样i的孙辈节点仍然可以<strong>自由选择</strong>。</p>\r\n<p>既然出现了分异，那么一个<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>就不够用了。</p>\r\n<p>我们使用<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>表示和之前一样的，不选择任何子节点的情况。那么状态转移方程显然<strong>还是</strong>那个样子：</p>\r\n<p><span class=\"math inline\">\\(f[i][1]=\\sum f[j][0];\\)</span></p>\r\n<p>另外加一个<span\r\nclass=\"math inline\">\\(f[i][2]\\)</span>表示选了一个子节点的情况。</p>\r\n<p>具体选哪个子节点，当然贪心地选择选了之后贡献最多的那个。记住选择这个点之后，孙辈的点不能选，所以选择的状态是<span\r\nclass=\"math inline\">\\(f[j][1]\\)</span>而不可以是<span\r\nclass=\"math inline\">\\(f[j][2]\\)</span>。</p>\r\n<p>也就是<span\r\nclass=\"math inline\">\\(max(f[j][1]-f[j][0])\\)</span>对应的点。</p>\r\n<p>处理的时候让<span class=\"math inline\">\\(f[i][2]\\)</span>和<span\r\nclass=\"math inline\">\\(f[i][1\\)</span>]先一起累计<span\r\nclass=\"math inline\">\\(\\sum f[j][0]\\)</span>，最后<span\r\nclass=\"math inline\">\\(f[i][2]\\)</span>加上选择的子节点多出来的贡献就行。</p>\r\n<h2 id=\"完整代码-1\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; tr[N];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N][<span class=\"number\">3</span>],n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">  f[u][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u][<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\tf[u][<span class=\"number\">2</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> d=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;tr[u].<span class=\"built_in\">size</span>();i++) &#123;</span><br><span class=\"line\">    \t<span class=\"type\">int</span> v=tr[u][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==k)<span class=\"keyword\">continue</span>;<span class=\"comment\">//双向连边的情况下要防止搜回亲节点</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">        f[u][<span class=\"number\">0</span>]+=<span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(f[v][<span class=\"number\">0</span>], f[v][<span class=\"number\">1</span>]),f[v][<span class=\"number\">2</span>]);</span><br><span class=\"line\">        f[u][<span class=\"number\">1</span>]+=f[v][<span class=\"number\">0</span>];</span><br><span class=\"line\">        f[u][<span class=\"number\">2</span>]+=f[v][<span class=\"number\">0</span>];</span><br><span class=\"line\">        d=<span class=\"built_in\">max</span>(d,f[v][<span class=\"number\">1</span>]-f[v][<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[u][<span class=\"number\">2</span>]+=d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//题目给的建议加入的代码</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">(<span class=\"number\">512</span>&lt;&lt;<span class=\"number\">20</span>)</span></span>;  <span class=\"comment\">// 512M</span></span><br><span class=\"line\">    __asm__ ( <span class=\"string\">&quot;movq %0, %%rsp\\n&quot;</span>::<span class=\"string\">&quot;r&quot;</span>((<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(size)+size));</span><br><span class=\"line\">\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)tr[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    \tcin &gt;&gt; n;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++) &#123;</span><br><span class=\"line\">    \t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">    \t    cin &gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    \t    tr[y].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">    \t    tr[x].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    \tcout &lt;&lt;<span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(f[<span class=\"number\">1</span>][<span class=\"number\">0</span>], f[<span class=\"number\">1</span>][<span class=\"number\">1</span>]),f[<span class=\"number\">1</span>][<span class=\"number\">2</span>])&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//return 0;  //加上会re </span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"stormwind\">1011-Stormwind</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 枚举, 贪心 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1011 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<p><a\r\nhref=\"https://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1011\">题目链接</a></p>\r\n<h2 id=\"题意简述-1\">题意简述</h2>\r\n<p>给一个边长<span class=\"math inline\">\\(n*m\\)</span>的矩形，<span\r\nclass=\"math inline\">\\(n\\)</span>和<span\r\nclass=\"math inline\">\\(m\\)</span>是整数。平行矩形边切割这个矩形，把它分成若干的小矩形。每次切割都贯穿矩形，也就是切割线一定要交于原矩形的两边。要求每个小矩形边长是整数且面积不小于k。</p>\r\n<p>求最多切割次数。</p>\r\n<h2 id=\"题目分析-1\">题目分析</h2>\r\n<p><del>切割欸，乍一看好像不能贪心。</del></p>\r\n<p>但由于本题切割要求的特殊性：每一次切割都<strong>贯穿</strong>矩形，也就是<strong>不会</strong>有呈T型或者L型镶嵌的矩形存在，小矩形一定是规规整整，每行每列固定数量<strong>整齐排列</strong>的。</p>\r\n<p>其实也就是确定一个横着切几刀和纵着切几刀的方案。</p>\r\n<p>那么我们是可以<strong>贪心</strong>的：显然每个矩形在满足面积大于k的情况下应该<strong>尽量小</strong>，这样才可能切出<strong>更多</strong>矩形，在这样规整的切割里也就是切<strong>更多次</strong>了。</p>\r\n<p>也就是对于一个一边长为<span\r\nclass=\"math inline\">\\(i\\)</span>的小矩形，我们找到最小的<span\r\nclass=\"math inline\">\\(j\\)</span>作为另一个边长，满足<span\r\nclass=\"math inline\">\\(i*j≥k\\)</span>。</p>\r\n<p>那么<span class=\"math inline\">\\(j\\)</span>就是<span\r\nclass=\"math inline\">\\(k/i\\)</span>向上取整。也就是确定<span\r\nclass=\"math inline\">\\(i\\)</span>之后，<span\r\nclass=\"math inline\">\\(j\\)</span>跟着确定了。</p>\r\n<p>确定了小矩形的长和宽之后，我们可以<strong>直接计算</strong>出大矩形能切出几个小矩形来。</p>\r\n<p>比如大矩形一边长为<span\r\nclass=\"math inline\">\\(n\\)</span>，对应小矩形的边长为<span\r\nclass=\"math inline\">\\(i\\)</span>，<span\r\nclass=\"math inline\">\\(n/i\\)</span>向下取整就是分割数量，切割次数比这个值<strong>小1</strong>。</p>\r\n<p>另一边同理。</p>\r\n<p>这样以来，我们<strong>只要</strong>确定一个小矩形边长之一的<span\r\nclass=\"math inline\">\\(i\\)</span>，这个方案对应的答案就能计算出来了。</p>\r\n<p>本题保证大矩形边长在<span\r\nclass=\"math inline\">\\(1e5\\)</span>以内，显然遍历枚举<span\r\nclass=\"math inline\">\\(1e5\\)</span>范围内的整数<span\r\nclass=\"math inline\">\\(i\\)</span>是可以接受的。</p>\r\n<p>甚至因为只需要满足<span\r\nclass=\"math inline\">\\(i*j≥k\\)</span>，所以i遍历到<span\r\nclass=\"math inline\">\\(sqrt（k）\\)</span>就可以结束，再之后的<span\r\nclass=\"math inline\">\\(ij\\)</span>数对是重复的（比如2<em>5和5</em>2）。</p>\r\n<p>需要注意，如果计算出来一边切不出哪怕一个小矩形，也就是形如<span\r\nclass=\"math inline\">\\(n&lt;i\\)</span>的情况，那么这个答案是<strong>无效</strong>的。</p>\r\n<p>最后使用一个变量更新最大答案即可。</p>\r\n<h2 id=\"完整代码-2\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n,m,k;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"built_in\">sqrt</span>(k);i++)&#123;<span class=\"comment\">//枚举矩形的一个变成i </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j=k/i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i*j&lt;k)j++;<span class=\"comment\">//找到满足i*j&gt;=k的最小的j </span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//n边切i </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> a=n/i;<span class=\"comment\">//n边可以分出几个i长度的段 </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> b=m/j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a!=<span class=\"number\">0</span>&amp;&amp;b!=<span class=\"number\">0</span>)<span class=\"comment\">//有一边一段都分不出来，答案无效 </span></span><br><span class=\"line\">\t\t\tans=<span class=\"built_in\">max</span>(ans,a+b<span class=\"number\">-2</span>);<span class=\"comment\">//否则更新答案 </span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//n边切j </span></span><br><span class=\"line\">\t\t\ta=n/j;</span><br><span class=\"line\">\t\t\tb=m/i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a!=<span class=\"number\">0</span>&amp;&amp;b!=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tans=<span class=\"built_in\">max</span>(ans,a+b<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"theramore\">1001-Theramore</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 贪心 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1001 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>给定一个只含有‘0’和‘1’的字符串，有无数次机会可以选择长度为奇数的任意间隔并将其反转，输出能得到的字典序最小的字符串。</p>\r\n<h2 id=\"解法\">解法</h2>\r\n<p>因为只能选择长度为奇数的任意间隔，所以<strong>奇数位置上的字符只能移动到奇数位置，偶数位置上的字符只能移动到偶数位置上</strong>。例如：位置5上的’0‘是可以被移到位置1上的。</p>\r\n<p>我们可以分别计算出奇数位置上和偶数位置上‘0’的个数，然后从前往后对应奇偶位置地放置这些’0‘（原来奇数位置上的’0‘还是要放在奇数位置上），放完’0‘后，就可以开始放’1‘，这样的字符串就是能得到的字典序最小的字符串。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\tstring s;</span><br><span class=\"line\">\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a=<span class=\"number\">0</span>,b=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>&amp;&amp;s[i]==<span class=\"string\">&#x27;0&#x27;</span>)a++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">1</span>&amp;&amp;s[i]==<span class=\"string\">&#x27;0&#x27;</span>)b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t\t\ta--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(b&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t\t\t\tb--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"quelthalas\">1004-Quel'Thalas</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 模拟 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1004 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>问使用几条线可以覆盖<span\r\nclass=\"math inline\">\\([0,0]\\sim[n,n]\\)</span>且不包括<span\r\nclass=\"math inline\">\\([0,0]\\)</span>的所有点, 以<span\r\nclass=\"math inline\">\\(n\\)</span>条竖线和<span\r\nclass=\"math inline\">\\(n\\)</span>条横线即可.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"number\">2</span>*n&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"orgrimmar\">1008-Orgrimmar</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 动态规划, 树形DP 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1008 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<p><a\r\nhref=\"https://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1008\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给一个有<span class=\"math inline\">\\(n\\)</span>个节点，<span\r\nclass=\"math inline\">\\(n-1\\)</span>条边的无向连通图（树），任意删除一些点（以及连接它的边），使得剩下的点构成若干个<strong>离散集</strong>，其中离散集的定义是每个点至多连接了一条边。</p>\r\n<p>求最多剩下多少点。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p><strong>——题意理解——</strong></p>\r\n<p>要让剩下的点满足这个离散集的定义，那么点要么干脆是<strong>孤立的点</strong>，要么是<strong>两个点</strong>由一条边相连。超过三个点相连就必定有一个点和另外两点相连，连接了至少两条边。</p>\r\n<p><strong>——初步思路——</strong></p>\r\n<p>首先我们考虑把树切割成链。</p>\r\n<p>删除若干个点之后树变成了若干条链，那么对一条链，每三个点删除一个点，就能让所有的点都满足定义。</p>\r\n<p><del>但是好难噢，树链剖分也不是删点剖的，连板子都没有。</del></p>\r\n<p>构造一些样例尝试之后，也很容易发现删除点是有后效性的，贪心这条路可能也走不通。</p>\r\n<p>具体表现在一个节点被删除之后，它的子树的状态会收到影响。</p>\r\n<p><del>这么一看好像DP噢，试试，试试。</del></p>\r\n<p><strong>——经典引入——</strong></p>\r\n<p>本题的要求和一种经典的树形DP非常吻合——<strong>求树的最大独立集</strong></p>\r\n<blockquote>\r\n<p>独立集：图的一个顶点子集，该子集中的任意两个项点在图中不相邻。</p>\r\n</blockquote>\r\n<p>首先，和大部分树形DP相同，整体上使用类似后序遍历的DFS跑，也就是先求子树的最优解，再合并求出亲节点的最优解，最后询问根节点的最优解。</p>\r\n<p>再确定我们需要的变量。首先，必不可少的一个变量表示当前的<strong>节点编号</strong>；接着，在这个情景里，每个节点有<strong>两种选择</strong>：选入集合/不选入集合。</p>\r\n<p>我们用<span\r\nclass=\"math inline\">\\(f[i][0]\\)</span>表示不选i节点，用<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>表示选<span\r\nclass=\"math inline\">\\(i\\)</span>节点。DP函数<span\r\nclass=\"math inline\">\\(f\\)</span>的值是以<span\r\nclass=\"math inline\">\\(i\\)</span>为根节点的子树中的最大独立集节点数（如果点有权值，则是最大点权和）。</p>\r\n<p>如果我们<strong>不选</strong><span\r\nclass=\"math inline\">\\(i\\)</span>节点，那么它所有的子节点都是<strong>可选择</strong>的。用<span\r\nclass=\"math inline\">\\(j\\)</span>表示<span\r\nclass=\"math inline\">\\(i\\)</span>的子节点，那么就有：</p>\r\n<p><span class=\"math inline\">\\(f[i][0]=\\sum\r\nmax(f[j][0],f[j][1])\\)</span> ;</p>\r\n<p>如果我们<strong>选</strong>了<span\r\nclass=\"math inline\">\\(i\\)</span>节点，那么它的所有子节点都<strong>不能选择</strong>，否则i就不是独立的点了。</p>\r\n<p><span class=\"math inline\">\\(f[i][1]=\\sum f[j][0];\\)</span></p>\r\n<p><strong>——迁移使用——</strong></p>\r\n<p>本题和求树的最大独立集的问题的差别在于，不要求选取的点集中所有的点都是独立的点，还可以有若干个两个节点相连的点对。</p>\r\n<p>我们还是先试着用<span\r\nclass=\"math inline\">\\(f[i][0]\\)</span>表示不选i节点，用<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>表示选<span\r\nclass=\"math inline\">\\(i\\)</span>节点。</p>\r\n<p>如果我们不选<span\r\nclass=\"math inline\">\\(i\\)</span>节点，那么它所有的子节点仍然都是可选择的。用<span\r\nclass=\"math inline\">\\(j\\)</span>表示<span\r\nclass=\"math inline\">\\(i\\)</span>的子节点，那么<strong>同样</strong>有：</p>\r\n<p><span class=\"math inline\">\\(f[i][0]=\\sum\r\nmax(f[j][0],f[j][1])\\)</span> ;</p>\r\n<p>但是，如果我们选了i节点，<strong>并不是</strong>所有的子节点都不能选择。i可以不是独立的点，它可以和其中<strong>一个</strong>子节点连接成一个<strong>点对</strong>。</p>\r\n<p>如果它和一个子节点连接成了一个点对，那么这个子节点的所有子节点，也就是i的孙辈节点都<strong>不能</strong>再选择了，否则就会形成一个三个点相连的链，不符合题目要求。</p>\r\n<p>当然，也可以一个子节点都不选。这样i的孙辈节点仍然可以<strong>自由选择</strong>。</p>\r\n<p>既然出现了分异，那么一个<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>就不够用了。</p>\r\n<p>我们使用<span\r\nclass=\"math inline\">\\(f[i][1]\\)</span>表示和之前一样的，不选择任何子节点的情况。那么状态转移方程显然<strong>还是</strong>那个样子：</p>\r\n<p><span class=\"math inline\">\\(f[i][1]=\\sum f[j][0];\\)</span></p>\r\n<p>另外加一个<span\r\nclass=\"math inline\">\\(f[i][2]\\)</span>表示选了一个子节点的情况。</p>\r\n<p>具体选哪个子节点，当然贪心地选择选了之后贡献最多的那个。记住选择这个点之后，孙辈的点不能选，所以选择的状态是<span\r\nclass=\"math inline\">\\(f[j][1]\\)</span>而不可以是<span\r\nclass=\"math inline\">\\(f[j][2]\\)</span>。</p>\r\n<p>也就是<span\r\nclass=\"math inline\">\\(max(f[j][1]-f[j][0])\\)</span>对应的点。</p>\r\n<p>处理的时候让<span class=\"math inline\">\\(f[i][2]\\)</span>和<span\r\nclass=\"math inline\">\\(f[i][1\\)</span>]先一起累计<span\r\nclass=\"math inline\">\\(\\sum f[j][0]\\)</span>，最后<span\r\nclass=\"math inline\">\\(f[i][2]\\)</span>加上选择的子节点多出来的贡献就行。</p>\r\n<h2 id=\"完整代码-1\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; tr[N];</span><br><span class=\"line\"><span class=\"type\">int</span> f[N][<span class=\"number\">3</span>],n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">  f[u][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u][<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\tf[u][<span class=\"number\">2</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> d=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;tr[u].<span class=\"built_in\">size</span>();i++) &#123;</span><br><span class=\"line\">    \t<span class=\"type\">int</span> v=tr[u][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==k)<span class=\"keyword\">continue</span>;<span class=\"comment\">//双向连边的情况下要防止搜回亲节点</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">        f[u][<span class=\"number\">0</span>]+=<span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(f[v][<span class=\"number\">0</span>], f[v][<span class=\"number\">1</span>]),f[v][<span class=\"number\">2</span>]);</span><br><span class=\"line\">        f[u][<span class=\"number\">1</span>]+=f[v][<span class=\"number\">0</span>];</span><br><span class=\"line\">        f[u][<span class=\"number\">2</span>]+=f[v][<span class=\"number\">0</span>];</span><br><span class=\"line\">        d=<span class=\"built_in\">max</span>(d,f[v][<span class=\"number\">1</span>]-f[v][<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[u][<span class=\"number\">2</span>]+=d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//题目给的建议加入的代码</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">(<span class=\"number\">512</span>&lt;&lt;<span class=\"number\">20</span>)</span></span>;  <span class=\"comment\">// 512M</span></span><br><span class=\"line\">    __asm__ ( <span class=\"string\">&quot;movq %0, %%rsp\\n&quot;</span>::<span class=\"string\">&quot;r&quot;</span>((<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(size)+size));</span><br><span class=\"line\">\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)tr[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    \tcin &gt;&gt; n;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++) &#123;</span><br><span class=\"line\">    \t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">    \t    cin &gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    \t    tr[y].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">    \t    tr[x].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    \tcout &lt;&lt;<span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(f[<span class=\"number\">1</span>][<span class=\"number\">0</span>], f[<span class=\"number\">1</span>][<span class=\"number\">1</span>]),f[<span class=\"number\">1</span>][<span class=\"number\">2</span>])&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//return 0;  //加上会re </span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"stormwind\">1011-Stormwind</h1>\r\n<p>来源: 杭电杯超级联赛8 算法: 枚举, 贪心 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1011 补完:\r\nYes 完成时间: August 11, 2022</p>\r\n<p><a\r\nhref=\"https://acm.dingbacode.com/contest/problem?cid=1051&amp;pid=1011\">题目链接</a></p>\r\n<h2 id=\"题意简述-1\">题意简述</h2>\r\n<p>给一个边长<span class=\"math inline\">\\(n*m\\)</span>的矩形，<span\r\nclass=\"math inline\">\\(n\\)</span>和<span\r\nclass=\"math inline\">\\(m\\)</span>是整数。平行矩形边切割这个矩形，把它分成若干的小矩形。每次切割都贯穿矩形，也就是切割线一定要交于原矩形的两边。要求每个小矩形边长是整数且面积不小于k。</p>\r\n<p>求最多切割次数。</p>\r\n<h2 id=\"题目分析-1\">题目分析</h2>\r\n<p><del>切割欸，乍一看好像不能贪心。</del></p>\r\n<p>但由于本题切割要求的特殊性：每一次切割都<strong>贯穿</strong>矩形，也就是<strong>不会</strong>有呈T型或者L型镶嵌的矩形存在，小矩形一定是规规整整，每行每列固定数量<strong>整齐排列</strong>的。</p>\r\n<p>其实也就是确定一个横着切几刀和纵着切几刀的方案。</p>\r\n<p>那么我们是可以<strong>贪心</strong>的：显然每个矩形在满足面积大于k的情况下应该<strong>尽量小</strong>，这样才可能切出<strong>更多</strong>矩形，在这样规整的切割里也就是切<strong>更多次</strong>了。</p>\r\n<p>也就是对于一个一边长为<span\r\nclass=\"math inline\">\\(i\\)</span>的小矩形，我们找到最小的<span\r\nclass=\"math inline\">\\(j\\)</span>作为另一个边长，满足<span\r\nclass=\"math inline\">\\(i*j≥k\\)</span>。</p>\r\n<p>那么<span class=\"math inline\">\\(j\\)</span>就是<span\r\nclass=\"math inline\">\\(k/i\\)</span>向上取整。也就是确定<span\r\nclass=\"math inline\">\\(i\\)</span>之后，<span\r\nclass=\"math inline\">\\(j\\)</span>跟着确定了。</p>\r\n<p>确定了小矩形的长和宽之后，我们可以<strong>直接计算</strong>出大矩形能切出几个小矩形来。</p>\r\n<p>比如大矩形一边长为<span\r\nclass=\"math inline\">\\(n\\)</span>，对应小矩形的边长为<span\r\nclass=\"math inline\">\\(i\\)</span>，<span\r\nclass=\"math inline\">\\(n/i\\)</span>向下取整就是分割数量，切割次数比这个值<strong>小1</strong>。</p>\r\n<p>另一边同理。</p>\r\n<p>这样以来，我们<strong>只要</strong>确定一个小矩形边长之一的<span\r\nclass=\"math inline\">\\(i\\)</span>，这个方案对应的答案就能计算出来了。</p>\r\n<p>本题保证大矩形边长在<span\r\nclass=\"math inline\">\\(1e5\\)</span>以内，显然遍历枚举<span\r\nclass=\"math inline\">\\(1e5\\)</span>范围内的整数<span\r\nclass=\"math inline\">\\(i\\)</span>是可以接受的。</p>\r\n<p>甚至因为只需要满足<span\r\nclass=\"math inline\">\\(i*j≥k\\)</span>，所以i遍历到<span\r\nclass=\"math inline\">\\(sqrt（k）\\)</span>就可以结束，再之后的<span\r\nclass=\"math inline\">\\(ij\\)</span>数对是重复的（比如2<em>5和5</em>2）。</p>\r\n<p>需要注意，如果计算出来一边切不出哪怕一个小矩形，也就是形如<span\r\nclass=\"math inline\">\\(n&lt;i\\)</span>的情况，那么这个答案是<strong>无效</strong>的。</p>\r\n<p>最后使用一个变量更新最大答案即可。</p>\r\n<h2 id=\"完整代码-2\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n,m,k;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"built_in\">sqrt</span>(k);i++)&#123;<span class=\"comment\">//枚举矩形的一个变成i </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j=k/i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i*j&lt;k)j++;<span class=\"comment\">//找到满足i*j&gt;=k的最小的j </span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//n边切i </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> a=n/i;<span class=\"comment\">//n边可以分出几个i长度的段 </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> b=m/j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a!=<span class=\"number\">0</span>&amp;&amp;b!=<span class=\"number\">0</span>)<span class=\"comment\">//有一边一段都分不出来，答案无效 </span></span><br><span class=\"line\">\t\t\tans=<span class=\"built_in\">max</span>(ans,a+b<span class=\"number\">-2</span>);<span class=\"comment\">//否则更新答案 </span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//n边切j </span></span><br><span class=\"line\">\t\t\ta=n/j;</span><br><span class=\"line\">\t\t\tb=m/i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a!=<span class=\"number\">0</span>&amp;&amp;b!=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tans=<span class=\"built_in\">max</span>(ans,a+b<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛09","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1010-Sum Plus Product\n\n来源: 杭电杯超级联赛9\n算法: 数论, 语法\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1052&pid=1010\n补完: Yes\n完成时间: August 16, 2022\n\n## 题解\n\n以球$a,b,c$为例推演发现, 不论谁先组合都有答案$a+b+c+ab+ac+bc+abc$.\n\n总体计算答案时可视为若干球依次放入$ans +=new+new\\cdot ans$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 505;\n\nll a[MAXN];\n\nll add(ll a, ll b){\n    return (a+b)%P;\n}\n\nll mul(ll a, ll b){\n    return (a*b)%P;\n}\nvoid solve() {\n    int n;\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        cin>>a[i];\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans = add(ans,add(a[i],mul(ans,a[i])));\n    }\n    cout<<ans<<\"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛09.md","raw":"---\ntitle: 2022杭电杯超级联赛09\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1010-Sum Plus Product\n\n来源: 杭电杯超级联赛9\n算法: 数论, 语法\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1052&pid=1010\n补完: Yes\n完成时间: August 16, 2022\n\n## 题解\n\n以球$a,b,c$为例推演发现, 不论谁先组合都有答案$a+b+c+ab+ac+bc+abc$.\n\n总体计算答案时可视为若干球依次放入$ans +=new+new\\cdot ans$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 505;\n\nll a[MAXN];\n\nll add(ll a, ll b){\n    return (a+b)%P;\n}\n\nll mul(ll a, ll b){\n    return (a*b)%P;\n}\nvoid solve() {\n    int n;\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        cin>>a[i];\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans = add(ans,add(a[i],mul(ans,a[i])));\n    }\n    cout<<ans<<\"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022杭电杯超级联赛09","published":1,"updated":"2023-10-29T06:23:56.378Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex80008n0umecfi3m1y","content":"<h1 id=\"sum-plus-product\">1010-Sum Plus Product</h1>\r\n<p>来源: 杭电杯超级联赛9 算法: 数论, 语法 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1052&amp;pid=1010 补完:\r\nYes 完成时间: August 16, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>以球<span class=\"math inline\">\\(a,b,c\\)</span>为例推演发现,\r\n不论谁先组合都有答案<span\r\nclass=\"math inline\">\\(a+b+c+ab+ac+bc+abc\\)</span>.</p>\r\n<p>总体计算答案时可视为若干球依次放入<span class=\"math inline\">\\(ans\r\n+=new+new\\cdot ans\\)</span></p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">505</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll a[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a*b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">add</span>(ans,<span class=\"built_in\">add</span>(a[i],<span class=\"built_in\">mul</span>(ans,a[i])));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"sum-plus-product\">1010-Sum Plus Product</h1>\r\n<p>来源: 杭电杯超级联赛9 算法: 数论, 语法 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1052&amp;pid=1010 补完:\r\nYes 完成时间: August 16, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>以球<span class=\"math inline\">\\(a,b,c\\)</span>为例推演发现,\r\n不论谁先组合都有答案<span\r\nclass=\"math inline\">\\(a+b+c+ab+ac+bc+abc\\)</span>.</p>\r\n<p>总体计算答案时可视为若干球依次放入<span class=\"math inline\">\\(ans\r\n+=new+new\\cdot ans\\)</span></p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">505</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll a[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a*b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">add</span>(ans,<span class=\"built_in\">add</span>(a[i],<span class=\"built_in\">mul</span>(ans,a[i])));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022杭电杯超级联赛10","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# 1003-Wavy Tree\n\n来源: 杭电杯超级联赛10\n算法: 模拟, 贪心\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1053&pid=1003\n补完: Yes\n\n[题目链接](https://acm.dingbacode.com/contest/problem?cid=1053&pid=1003)\n\n## 题意简述\n\n一个数列被称为”波浪“，表示这个数列中的所有$i（1<i<n）$，满足$a_{i-1}<a_i\\&\\&a_i>a{i+1}$或者$a_{i-1}>a_i\\&\\&a_i<a{i+1}$。\n\n让一个数字+1或者-1消耗一个代价。\n\n给你一个数列，问你把它变成波浪数列的最小代价。\n\n## 题目分析\n\n这样的波浪数列即要求每个数字要么是**”峰“**，要么是**”谷“**，不能是”山坡上“的数字。\n\n那么波浪数列可以分为**两种**：第一个数字是”峰“；或者第一个数字是”谷“。\n\n首先思考**贪心**的策略：\n\n一个数字$a_i$是峰的话，$a_{i+1}$就是谷。如果$a_{i+1}$本身就满足比$a_i$小的性质，我们就不用动它。如果不满足，我们让它消耗最少的代价变得满足条件：把$a_{i-1}$变成$a_i-1$。\n\n反之亦然。\n\n显然对每个**相邻**数字的操作来看，这样是最节省费用的策略。\n\n那么这样简单粗暴的贪心策略是否会有后效性导致局部最优的决策得不到全局的最优解呢？\n\n~~交一发问评测机呗。~~\n\n错误的，没到最后时候不要浪费罚时啊！\n\n我们来简单整个比较极端的样例测试一下。\n\n这个策略让人担心的点是：符合要求就不调整的话，会不会把整个数列波动的中线带到很高或者很低的地方，从而使得后面的序列浪费很多代价呢？\n\n那我们假设，一个数列长成这个鬼样：\n\n![Untitled](1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled.png)\n\n把第一个点当作谷，前四个点都不需要操作。这会让后面的序列都被迫提高，而导致费用过高吗？\n\n显然是**不会**的。\n\n在这里第五个点**不需要**操作。或者假设它需要操作的话——比如它比第四个点更高，我们只把它调到比第四个点小1的位置。那第六个点要调到高于它，也就是和第四个点平齐的位置。那第七个点又**不需要**操作了。\n\n而这里的不用操作的第五个或者第七个后面的点，显然**不关心**前面其他的点到底再什么鬼地方——策略中，$i$只需要和$i-1$比大小。\n\n并且如果想把高于点团的这部分拉下来，反而浪费了调整它们需要的代价。\n\n那再考虑一下如果在底下的点需要上调的情况：比如在这里第四个点很小。\n\n那么让它比第三个点大的代价是和前一个点的差值+1。和让前面的点来迁就它的代价**没有区别**。并且由于第四个点是”峰“，我们还希望第五个点比它小。如果让前面的第三个点下降来迁就第四个点，让第五个点小于第四个点的**可能性就更小**，或者说本来第五个点就比较大的话，让第五个点小于第四个点的**代价就更大**。\n\n且如果这个差值代价**极大**，大到比其他的费用和还大得多。那么让点1作为峰，点4作为谷的时候，就会因为不用修改点4剩下更多的费用，这个方案的结果就会替代前面的运算。\n\n那么这个方案就是可以尝试的。\n\n~~如果WA了再想别的吧磨叽20分钟就是一个罚时了。~~\n\n关于代码，因为比较的时候只要拿$a_i$和前一个数修改后的结果比较，如果用一个变量比如$now$来记录这个比较值，就能在读入$a_i$的时候直接跑答案，用两个变量分别记录两种方案的结果，最后比较即可。\n\n~~但我懒。~~要区分谁是谁的$3*n$复杂度不如复制粘贴的$n+n+n$复杂度。\n\n核心代码be like：\n\n![Untitled](1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled%201.png)\n\n剩下的复制粘贴吧！\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint a[1000010];\nint main(){\n\tios::sync_with_stdio(false);\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint now=a[0];\n\t\tlong long ans=0; \n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(i%2==0){//大 \n              //核心在这↓\n\t\t\t\tif(a[i]>now){\n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow+=1;\n\t\t\t\t\tans+=now-a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//小 \n\t\t\t\tif(a[i]<now){//换个符号 \n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow-=1;//加减改一下 \n\t\t\t\t\tans+=a[i]-now;//前后翻一下 \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long anss=ans;//记录上一个答案 \n\t\tnow=a[0];\n\t\tans=0; //两个变量初始化 \n\t\t\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(i%2!=0){//整段for复制过来只改了这行 \n\t\t\t\tif(a[i]>now){\n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow+=1;\n\t\t\t\t\tans+=now-a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a[i]<now){\n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow-=1;\n\t\t\t\t\tans+=a[i]-now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tanss=min(anss,ans);\n\t\tcout<<anss<<'\\n';\n\t}\n\treturn 0; \n}\n```\n# 1007-Even Tree Split\n\n来源: 杭电杯超级联赛10\n算法: DFS, 图论\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1053&pid=1007\n补完: Yes\n完成时间: August 18, 2022\n\n## 题解\n\n给含$n$个节点的无向树, 可任意删除边形成不同的分量集. \n\n问删除后各个分量都含偶数个点的划分方案数量.\n\n若有子树含偶数个点, 那么此子树就可以被分离出来.\n\n整个树上有$num$个可分离的位置, 组合就有答案$2^{num}$种方案, 排除不删除的方案就有$ans=2^{num}-1$. \n\nDFS过程中会对根结点也判断一次可否分离故$num$需要再减$1$\n\n注意多组数据时需要严格初始化.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 200005;\n\nvector<int> e[MAXN];\nint cnt[MAXN];\nint num;\n\nll Mul(ll a, ll b){\n    return (a * b) % P;\n}\nll Pow(ll a, ll n){\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = Mul(a, ans);\n        a = Mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\n\nvoid dfs(int u,int f){\n    cnt[u] = 0;\n    for (auto v: e[u]) {\n        if (v==f)continue;\n        dfs(v,u);\n        cnt[u] += cnt[v] + 1;\n    }\n    if (cnt[u]%2) {\n        num++;\n    }\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    num = 0;\n    for (int i = 1; i <= n; i++) {\n        e[i].clear();\n    }\n    for (int i = 1; i < n; i++) {\n        int u,v;\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs(1,0);\n    cout<<Pow(2,num-1)-1<<\"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022杭电杯超级联赛10.md","raw":"---\ntitle: 2022杭电杯超级联赛10\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# 1003-Wavy Tree\n\n来源: 杭电杯超级联赛10\n算法: 模拟, 贪心\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1053&pid=1003\n补完: Yes\n\n[题目链接](https://acm.dingbacode.com/contest/problem?cid=1053&pid=1003)\n\n## 题意简述\n\n一个数列被称为”波浪“，表示这个数列中的所有$i（1<i<n）$，满足$a_{i-1}<a_i\\&\\&a_i>a{i+1}$或者$a_{i-1}>a_i\\&\\&a_i<a{i+1}$。\n\n让一个数字+1或者-1消耗一个代价。\n\n给你一个数列，问你把它变成波浪数列的最小代价。\n\n## 题目分析\n\n这样的波浪数列即要求每个数字要么是**”峰“**，要么是**”谷“**，不能是”山坡上“的数字。\n\n那么波浪数列可以分为**两种**：第一个数字是”峰“；或者第一个数字是”谷“。\n\n首先思考**贪心**的策略：\n\n一个数字$a_i$是峰的话，$a_{i+1}$就是谷。如果$a_{i+1}$本身就满足比$a_i$小的性质，我们就不用动它。如果不满足，我们让它消耗最少的代价变得满足条件：把$a_{i-1}$变成$a_i-1$。\n\n反之亦然。\n\n显然对每个**相邻**数字的操作来看，这样是最节省费用的策略。\n\n那么这样简单粗暴的贪心策略是否会有后效性导致局部最优的决策得不到全局的最优解呢？\n\n~~交一发问评测机呗。~~\n\n错误的，没到最后时候不要浪费罚时啊！\n\n我们来简单整个比较极端的样例测试一下。\n\n这个策略让人担心的点是：符合要求就不调整的话，会不会把整个数列波动的中线带到很高或者很低的地方，从而使得后面的序列浪费很多代价呢？\n\n那我们假设，一个数列长成这个鬼样：\n\n![Untitled](1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled.png)\n\n把第一个点当作谷，前四个点都不需要操作。这会让后面的序列都被迫提高，而导致费用过高吗？\n\n显然是**不会**的。\n\n在这里第五个点**不需要**操作。或者假设它需要操作的话——比如它比第四个点更高，我们只把它调到比第四个点小1的位置。那第六个点要调到高于它，也就是和第四个点平齐的位置。那第七个点又**不需要**操作了。\n\n而这里的不用操作的第五个或者第七个后面的点，显然**不关心**前面其他的点到底再什么鬼地方——策略中，$i$只需要和$i-1$比大小。\n\n并且如果想把高于点团的这部分拉下来，反而浪费了调整它们需要的代价。\n\n那再考虑一下如果在底下的点需要上调的情况：比如在这里第四个点很小。\n\n那么让它比第三个点大的代价是和前一个点的差值+1。和让前面的点来迁就它的代价**没有区别**。并且由于第四个点是”峰“，我们还希望第五个点比它小。如果让前面的第三个点下降来迁就第四个点，让第五个点小于第四个点的**可能性就更小**，或者说本来第五个点就比较大的话，让第五个点小于第四个点的**代价就更大**。\n\n且如果这个差值代价**极大**，大到比其他的费用和还大得多。那么让点1作为峰，点4作为谷的时候，就会因为不用修改点4剩下更多的费用，这个方案的结果就会替代前面的运算。\n\n那么这个方案就是可以尝试的。\n\n~~如果WA了再想别的吧磨叽20分钟就是一个罚时了。~~\n\n关于代码，因为比较的时候只要拿$a_i$和前一个数修改后的结果比较，如果用一个变量比如$now$来记录这个比较值，就能在读入$a_i$的时候直接跑答案，用两个变量分别记录两种方案的结果，最后比较即可。\n\n~~但我懒。~~要区分谁是谁的$3*n$复杂度不如复制粘贴的$n+n+n$复杂度。\n\n核心代码be like：\n\n![Untitled](1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled%201.png)\n\n剩下的复制粘贴吧！\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint a[1000010];\nint main(){\n\tios::sync_with_stdio(false);\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint now=a[0];\n\t\tlong long ans=0; \n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(i%2==0){//大 \n              //核心在这↓\n\t\t\t\tif(a[i]>now){\n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow+=1;\n\t\t\t\t\tans+=now-a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//小 \n\t\t\t\tif(a[i]<now){//换个符号 \n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow-=1;//加减改一下 \n\t\t\t\t\tans+=a[i]-now;//前后翻一下 \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long anss=ans;//记录上一个答案 \n\t\tnow=a[0];\n\t\tans=0; //两个变量初始化 \n\t\t\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(i%2!=0){//整段for复制过来只改了这行 \n\t\t\t\tif(a[i]>now){\n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow+=1;\n\t\t\t\t\tans+=now-a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a[i]<now){\n\t\t\t\t\tnow=a[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnow-=1;\n\t\t\t\t\tans+=a[i]-now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tanss=min(anss,ans);\n\t\tcout<<anss<<'\\n';\n\t}\n\treturn 0; \n}\n```\n# 1007-Even Tree Split\n\n来源: 杭电杯超级联赛10\n算法: DFS, 图论\n题目链接: https://acm.dingbacode.com/contest/problem?cid=1053&pid=1007\n补完: Yes\n完成时间: August 18, 2022\n\n## 题解\n\n给含$n$个节点的无向树, 可任意删除边形成不同的分量集. \n\n问删除后各个分量都含偶数个点的划分方案数量.\n\n若有子树含偶数个点, 那么此子树就可以被分离出来.\n\n整个树上有$num$个可分离的位置, 组合就有答案$2^{num}$种方案, 排除不删除的方案就有$ans=2^{num}-1$. \n\nDFS过程中会对根结点也判断一次可否分离故$num$需要再减$1$\n\n注意多组数据时需要严格初始化.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 200005;\n\nvector<int> e[MAXN];\nint cnt[MAXN];\nint num;\n\nll Mul(ll a, ll b){\n    return (a * b) % P;\n}\nll Pow(ll a, ll n){\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = Mul(a, ans);\n        a = Mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\n\nvoid dfs(int u,int f){\n    cnt[u] = 0;\n    for (auto v: e[u]) {\n        if (v==f)continue;\n        dfs(v,u);\n        cnt[u] += cnt[v] + 1;\n    }\n    if (cnt[u]%2) {\n        num++;\n    }\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    num = 0;\n    for (int i = 1; i <= n; i++) {\n        e[i].clear();\n    }\n    for (int i = 1; i < n; i++) {\n        int u,v;\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs(1,0);\n    cout<<Pow(2,num-1)-1<<\"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022杭电杯超级联赛10","published":1,"updated":"2023-10-29T06:21:05.211Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex80009n0um24vi4kfy","content":"<h1 id=\"wavy-tree\">1003-Wavy Tree</h1>\r\n<p>来源: 杭电杯超级联赛10 算法: 模拟, 贪心 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1053&amp;pid=1003 补完:\r\nYes</p>\r\n<p><a\r\nhref=\"https://acm.dingbacode.com/contest/problem?cid=1053&amp;pid=1003\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>一个数列被称为”波浪“，表示这个数列中的所有<span\r\nclass=\"math inline\">\\(i（1&lt;i&lt;n）\\)</span>，满足<span\r\nclass=\"math inline\">\\(a_{i-1}&lt;a_i\\&amp;\\&amp;a_i&gt;a{i+1}\\)</span>或者<span\r\nclass=\"math inline\">\\(a_{i-1}&gt;a_i\\&amp;\\&amp;a_i&lt;a{i+1}\\)</span>。</p>\r\n<p>让一个数字+1或者-1消耗一个代价。</p>\r\n<p>给你一个数列，问你把它变成波浪数列的最小代价。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>这样的波浪数列即要求每个数字要么是<strong>”峰“</strong>，要么是<strong>”谷“</strong>，不能是”山坡上“的数字。</p>\r\n<p>那么波浪数列可以分为<strong>两种</strong>：第一个数字是”峰“；或者第一个数字是”谷“。</p>\r\n<p>首先思考<strong>贪心</strong>的策略：</p>\r\n<p>一个数字<span class=\"math inline\">\\(a_i\\)</span>是峰的话，<span\r\nclass=\"math inline\">\\(a_{i+1}\\)</span>就是谷。如果<span\r\nclass=\"math inline\">\\(a_{i+1}\\)</span>本身就满足比<span\r\nclass=\"math inline\">\\(a_i\\)</span>小的性质，我们就不用动它。如果不满足，我们让它消耗最少的代价变得满足条件：把<span\r\nclass=\"math inline\">\\(a_{i-1}\\)</span>变成<span\r\nclass=\"math inline\">\\(a_i-1\\)</span>。</p>\r\n<p>反之亦然。</p>\r\n<p>显然对每个<strong>相邻</strong>数字的操作来看，这样是最节省费用的策略。</p>\r\n<p>那么这样简单粗暴的贪心策略是否会有后效性导致局部最优的决策得不到全局的最优解呢？</p>\r\n<p><del>交一发问评测机呗。</del></p>\r\n<p>错误的，没到最后时候不要浪费罚时啊！</p>\r\n<p>我们来简单整个比较极端的样例测试一下。</p>\r\n<p>这个策略让人担心的点是：符合要求就不调整的话，会不会把整个数列波动的中线带到很高或者很低的地方，从而使得后面的序列浪费很多代价呢？</p>\r\n<p>那我们假设，一个数列长成这个鬼样：</p>\r\n<figure>\r\n<img\r\nsrc=\"1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>把第一个点当作谷，前四个点都不需要操作。这会让后面的序列都被迫提高，而导致费用过高吗？</p>\r\n<p>显然是<strong>不会</strong>的。</p>\r\n<p>在这里第五个点<strong>不需要</strong>操作。或者假设它需要操作的话——比如它比第四个点更高，我们只把它调到比第四个点小1的位置。那第六个点要调到高于它，也就是和第四个点平齐的位置。那第七个点又<strong>不需要</strong>操作了。</p>\r\n<p>而这里的不用操作的第五个或者第七个后面的点，显然<strong>不关心</strong>前面其他的点到底再什么鬼地方——策略中，<span\r\nclass=\"math inline\">\\(i\\)</span>只需要和<span\r\nclass=\"math inline\">\\(i-1\\)</span>比大小。</p>\r\n<p>并且如果想把高于点团的这部分拉下来，反而浪费了调整它们需要的代价。</p>\r\n<p>那再考虑一下如果在底下的点需要上调的情况：比如在这里第四个点很小。</p>\r\n<p>那么让它比第三个点大的代价是和前一个点的差值+1。和让前面的点来迁就它的代价<strong>没有区别</strong>。并且由于第四个点是”峰“，我们还希望第五个点比它小。如果让前面的第三个点下降来迁就第四个点，让第五个点小于第四个点的<strong>可能性就更小</strong>，或者说本来第五个点就比较大的话，让第五个点小于第四个点的<strong>代价就更大</strong>。</p>\r\n<p>且如果这个差值代价<strong>极大</strong>，大到比其他的费用和还大得多。那么让点1作为峰，点4作为谷的时候，就会因为不用修改点4剩下更多的费用，这个方案的结果就会替代前面的运算。</p>\r\n<p>那么这个方案就是可以尝试的。</p>\r\n<p><del>如果WA了再想别的吧磨叽20分钟就是一个罚时了。</del></p>\r\n<p>关于代码，因为比较的时候只要拿<span\r\nclass=\"math inline\">\\(a_i\\)</span>和前一个数修改后的结果比较，如果用一个变量比如<span\r\nclass=\"math inline\">\\(now\\)</span>来记录这个比较值，就能在读入<span\r\nclass=\"math inline\">\\(a_i\\)</span>的时候直接跑答案，用两个变量分别记录两种方案的结果，最后比较即可。</p>\r\n<p><del>但我懒。</del>要区分谁是谁的<span\r\nclass=\"math inline\">\\(3*n\\)</span>复杂度不如复制粘贴的<span\r\nclass=\"math inline\">\\(n+n+n\\)</span>复杂度。</p>\r\n<p>核心代码be like：</p>\r\n<figure>\r\n<img\r\nsrc=\"1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>剩下的复制粘贴吧！</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">1000010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now=a[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans=<span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;<span class=\"comment\">//大 </span></span><br><span class=\"line\">              <span class=\"comment\">//核心在这↓</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&gt;now)&#123;</span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow+=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tans+=now-a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//小 </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&lt;now)&#123;<span class=\"comment\">//换个符号 </span></span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow-=<span class=\"number\">1</span>;<span class=\"comment\">//加减改一下 </span></span><br><span class=\"line\">\t\t\t\t\tans+=a[i]-now;<span class=\"comment\">//前后翻一下 </span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> anss=ans;<span class=\"comment\">//记录上一个答案 </span></span><br><span class=\"line\">\t\tnow=a[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tans=<span class=\"number\">0</span>; <span class=\"comment\">//两个变量初始化 </span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//整段for复制过来只改了这行 </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&gt;now)&#123;</span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow+=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tans+=now-a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&lt;now)&#123;</span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow-=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tans+=a[i]-now;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tanss=<span class=\"built_in\">min</span>(anss,ans);</span><br><span class=\"line\">\t\tcout&lt;&lt;anss&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"even-tree-split\">1007-Even Tree Split</h1>\r\n<p>来源: 杭电杯超级联赛10 算法: DFS, 图论 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1053&amp;pid=1007 补完:\r\nYes 完成时间: August 18, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给含<span class=\"math inline\">\\(n\\)</span>个节点的无向树,\r\n可任意删除边形成不同的分量集.</p>\r\n<p>问删除后各个分量都含偶数个点的划分方案数量.</p>\r\n<p>若有子树含偶数个点, 那么此子树就可以被分离出来.</p>\r\n<p>整个树上有<span class=\"math inline\">\\(num\\)</span>个可分离的位置,\r\n组合就有答案<span class=\"math inline\">\\(2^{num}\\)</span>种方案,\r\n排除不删除的方案就有<span\r\nclass=\"math inline\">\\(ans=2^{num}-1\\)</span>.</p>\r\n<p>DFS过程中会对根结点也判断一次可否分离故<span\r\nclass=\"math inline\">\\(num\\)</span>需要再减<span\r\nclass=\"math inline\">\\(1\\)</span></p>\r\n<p>注意多组数据时需要严格初始化.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">200005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Pow</span><span class=\"params\">(ll a, ll n)</span></span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">Mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">Mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">    cnt[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">        cnt[u] += cnt[v] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt[u]%<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        e[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        e[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">Pow</span>(<span class=\"number\">2</span>,num<span class=\"number\">-1</span>)<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"wavy-tree\">1003-Wavy Tree</h1>\r\n<p>来源: 杭电杯超级联赛10 算法: 模拟, 贪心 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1053&amp;pid=1003 补完:\r\nYes</p>\r\n<p><a\r\nhref=\"https://acm.dingbacode.com/contest/problem?cid=1053&amp;pid=1003\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>一个数列被称为”波浪“，表示这个数列中的所有<span\r\nclass=\"math inline\">\\(i（1&lt;i&lt;n）\\)</span>，满足<span\r\nclass=\"math inline\">\\(a_{i-1}&lt;a_i\\&amp;\\&amp;a_i&gt;a{i+1}\\)</span>或者<span\r\nclass=\"math inline\">\\(a_{i-1}&gt;a_i\\&amp;\\&amp;a_i&lt;a{i+1}\\)</span>。</p>\r\n<p>让一个数字+1或者-1消耗一个代价。</p>\r\n<p>给你一个数列，问你把它变成波浪数列的最小代价。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>这样的波浪数列即要求每个数字要么是<strong>”峰“</strong>，要么是<strong>”谷“</strong>，不能是”山坡上“的数字。</p>\r\n<p>那么波浪数列可以分为<strong>两种</strong>：第一个数字是”峰“；或者第一个数字是”谷“。</p>\r\n<p>首先思考<strong>贪心</strong>的策略：</p>\r\n<p>一个数字<span class=\"math inline\">\\(a_i\\)</span>是峰的话，<span\r\nclass=\"math inline\">\\(a_{i+1}\\)</span>就是谷。如果<span\r\nclass=\"math inline\">\\(a_{i+1}\\)</span>本身就满足比<span\r\nclass=\"math inline\">\\(a_i\\)</span>小的性质，我们就不用动它。如果不满足，我们让它消耗最少的代价变得满足条件：把<span\r\nclass=\"math inline\">\\(a_{i-1}\\)</span>变成<span\r\nclass=\"math inline\">\\(a_i-1\\)</span>。</p>\r\n<p>反之亦然。</p>\r\n<p>显然对每个<strong>相邻</strong>数字的操作来看，这样是最节省费用的策略。</p>\r\n<p>那么这样简单粗暴的贪心策略是否会有后效性导致局部最优的决策得不到全局的最优解呢？</p>\r\n<p><del>交一发问评测机呗。</del></p>\r\n<p>错误的，没到最后时候不要浪费罚时啊！</p>\r\n<p>我们来简单整个比较极端的样例测试一下。</p>\r\n<p>这个策略让人担心的点是：符合要求就不调整的话，会不会把整个数列波动的中线带到很高或者很低的地方，从而使得后面的序列浪费很多代价呢？</p>\r\n<p>那我们假设，一个数列长成这个鬼样：</p>\r\n<figure>\r\n<img\r\nsrc=\"1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>把第一个点当作谷，前四个点都不需要操作。这会让后面的序列都被迫提高，而导致费用过高吗？</p>\r\n<p>显然是<strong>不会</strong>的。</p>\r\n<p>在这里第五个点<strong>不需要</strong>操作。或者假设它需要操作的话——比如它比第四个点更高，我们只把它调到比第四个点小1的位置。那第六个点要调到高于它，也就是和第四个点平齐的位置。那第七个点又<strong>不需要</strong>操作了。</p>\r\n<p>而这里的不用操作的第五个或者第七个后面的点，显然<strong>不关心</strong>前面其他的点到底再什么鬼地方——策略中，<span\r\nclass=\"math inline\">\\(i\\)</span>只需要和<span\r\nclass=\"math inline\">\\(i-1\\)</span>比大小。</p>\r\n<p>并且如果想把高于点团的这部分拉下来，反而浪费了调整它们需要的代价。</p>\r\n<p>那再考虑一下如果在底下的点需要上调的情况：比如在这里第四个点很小。</p>\r\n<p>那么让它比第三个点大的代价是和前一个点的差值+1。和让前面的点来迁就它的代价<strong>没有区别</strong>。并且由于第四个点是”峰“，我们还希望第五个点比它小。如果让前面的第三个点下降来迁就第四个点，让第五个点小于第四个点的<strong>可能性就更小</strong>，或者说本来第五个点就比较大的话，让第五个点小于第四个点的<strong>代价就更大</strong>。</p>\r\n<p>且如果这个差值代价<strong>极大</strong>，大到比其他的费用和还大得多。那么让点1作为峰，点4作为谷的时候，就会因为不用修改点4剩下更多的费用，这个方案的结果就会替代前面的运算。</p>\r\n<p>那么这个方案就是可以尝试的。</p>\r\n<p><del>如果WA了再想别的吧磨叽20分钟就是一个罚时了。</del></p>\r\n<p>关于代码，因为比较的时候只要拿<span\r\nclass=\"math inline\">\\(a_i\\)</span>和前一个数修改后的结果比较，如果用一个变量比如<span\r\nclass=\"math inline\">\\(now\\)</span>来记录这个比较值，就能在读入<span\r\nclass=\"math inline\">\\(a_i\\)</span>的时候直接跑答案，用两个变量分别记录两种方案的结果，最后比较即可。</p>\r\n<p><del>但我懒。</del>要区分谁是谁的<span\r\nclass=\"math inline\">\\(3*n\\)</span>复杂度不如复制粘贴的<span\r\nclass=\"math inline\">\\(n+n+n\\)</span>复杂度。</p>\r\n<p>核心代码be like：</p>\r\n<figure>\r\n<img\r\nsrc=\"1003-Wavy%20Tree%202c07bf1e664b4a83982cb71e1639cfe0/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>剩下的复制粘贴吧！</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">1000010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now=a[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans=<span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;<span class=\"comment\">//大 </span></span><br><span class=\"line\">              <span class=\"comment\">//核心在这↓</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&gt;now)&#123;</span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow+=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tans+=now-a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//小 </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&lt;now)&#123;<span class=\"comment\">//换个符号 </span></span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow-=<span class=\"number\">1</span>;<span class=\"comment\">//加减改一下 </span></span><br><span class=\"line\">\t\t\t\t\tans+=a[i]-now;<span class=\"comment\">//前后翻一下 </span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> anss=ans;<span class=\"comment\">//记录上一个答案 </span></span><br><span class=\"line\">\t\tnow=a[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tans=<span class=\"number\">0</span>; <span class=\"comment\">//两个变量初始化 </span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//整段for复制过来只改了这行 </span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&gt;now)&#123;</span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow+=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tans+=now-a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a[i]&lt;now)&#123;</span><br><span class=\"line\">\t\t\t\t\tnow=a[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tnow-=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tans+=a[i]-now;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tanss=<span class=\"built_in\">min</span>(anss,ans);</span><br><span class=\"line\">\t\tcout&lt;&lt;anss&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"even-tree-split\">1007-Even Tree Split</h1>\r\n<p>来源: 杭电杯超级联赛10 算法: DFS, 图论 题目链接:\r\nhttps://acm.dingbacode.com/contest/problem?cid=1053&amp;pid=1007 补完:\r\nYes 完成时间: August 18, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给含<span class=\"math inline\">\\(n\\)</span>个节点的无向树,\r\n可任意删除边形成不同的分量集.</p>\r\n<p>问删除后各个分量都含偶数个点的划分方案数量.</p>\r\n<p>若有子树含偶数个点, 那么此子树就可以被分离出来.</p>\r\n<p>整个树上有<span class=\"math inline\">\\(num\\)</span>个可分离的位置,\r\n组合就有答案<span class=\"math inline\">\\(2^{num}\\)</span>种方案,\r\n排除不删除的方案就有<span\r\nclass=\"math inline\">\\(ans=2^{num}-1\\)</span>.</p>\r\n<p>DFS过程中会对根结点也判断一次可否分离故<span\r\nclass=\"math inline\">\\(num\\)</span>需要再减<span\r\nclass=\"math inline\">\\(1\\)</span></p>\r\n<p>注意多组数据时需要严格初始化.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">200005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Pow</span><span class=\"params\">(ll a, ll n)</span></span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">Mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">Mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">    cnt[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">        cnt[u] += cnt[v] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt[u]%<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        e[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        e[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">Pow</span>(<span class=\"number\">2</span>,num<span class=\"number\">-1</span>)<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营02","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# D-Link with Game Glitch\n\n来源: 牛客多校训练营2\n算法: 图论\n题目链接: https://ac.nowcoder.com/acm/contest/33187/D\n补完: Yes\n完成时间: July 25, 2022\n\n## 算法\n\n①二分答案+SPFA判负环\n\n②Karp的最小平均权重环路算法\n\n## 题解\n\n这里考虑法②\n\n题目有对于配方$i$有: 以$a_i$个物品 $b_i$为原料,制造$c_i$个物品$d_i$为产品\n\n$$\na_i\\times b_i\\to c_i \\times d_i \n$$\n\n可以理解为对于配方$i$有: 以$\\frac{a_i}{c_i}$个物品 $b_i$为原料,制造$1$个物品$d_i$为产品\n\n$$\n\\frac{a_i}{c_i}\\times b_i \\to d_i\n$$\n\n对于连续$k$个配方可以由配方的系数乘积从原料制造出产品\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i} 原料\\to 产品\n$$\n\n若某物品经过$k$道配方, 最终可以制造自己, 称为一循环配方\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\n$$\n\n以$n$种物品为点, $m$种配方为边, $\\frac{a_i}{c_i}$为边权建立有向图, 循环配方表现为环\n\n设循环配方中任意物品原有数量为$x$,个 则每次循环后可变为为$\\frac {x}{\\prod_{i}^k\\frac{a_i}{c_i}}$个,\n\n要使物品不会变多, 则必须$x≥\\frac {x}{\\prod_{i}^k\\frac{a_i}{c_i}}$, 也即\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i}≥1\n$$\n\n引入生产修正参数$w$\n\n$$\na_i\\times b_i\\to w\\times c_i \\times d_i \n$$\n\n可以理解为\n\n$$\n\\frac{a_i}{wc_i}\\times b_i \\to d_i\n$$\n\n可推得\n\n$$\n\\prod_{i}^k\\frac{a_i}{wc_i} 物品\\to 物品\n$$\n\n将$w$提出有\n\n$$\n\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\n$$\n\n重复上文推论\n\n以$n$种物品为点, $m$种配方为边, $\\frac{a_i}{wc_i}$为边权建立有向图, 循环配方表现为环\n\n设循环配方中任意物品原有数量为$x$,个 则每次循环后可变为为$\\frac {x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}$个,\n\n要使物品不会变多, 则必须$x≥\\frac {x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}$, 也即\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i}≥w^k\n$$\n\n对于不同的环有不同的$\\prod_{i}^k\\frac{a_i}{c_i}$, 即要求在每一个环中都满足上式,即\n\n$$\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})≥w^k\n$$\n\n且要求$w$取最大, 则要求\n\n$$\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})=w^k\n$$\n\n化简得\n\n$$\nw=\\min\\left(\\sqrt[k]{\\prod_{i}^k\\frac{a_i}{c_i}}\\right)\n$$\n\n其中连乘可用对数处理\n\n$$\n\\ln(\\prod_{i}^k\\frac{a_i}{c_i})=\\sum_i^k\\ln(\\frac{a_i}{c_i})\n$$\n\n化简得\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i}=e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}\n$$\n\n即要求\n\n$$\nw^k=e^{\\min(\\sum_i^k\\ln(\\frac{a_i}{c_i}))}\n$$\n\n最终\n\n$$\nw=\\min(\\sqrt[k]{e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}})\n$$\n\n$$\nw=\\exp\\left(\\min(\\frac{\\sum_i^k\\ln(\\frac{a_i}{c_i})}{k})\\right)\n$$\n\n则理解为求环的最小平均权重\n\n以$\\ln(\\frac{a_i}{c_i})$为边权建图$G(V,E)$\n\n有$Karp的最小平均权重环路算法$\n\n让$F[k][v]$为从任意点出发,经过$k$条边到达$v$点的最短距离, 对每条边$u\\to v$ 有\n\n$$\nF[k][v]=\\min_{e\\in E}\\{F[k-1][u]+w[u][v]\\}\n$$\n\n$$\nans = \\min_{v\\in V}\\{\\max_{0≤k≤n-1}\\{\\frac{F[n][v]-F[k][v]}{n-k}\\}\\}\n$$\n\n### 参考\n\n****[有向图中的最小平均权值回路](https://blog.csdn.net/qq_30361651/article/details/107801468)****\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2005;\nint n,m,b,d;\ndouble a,c,ans;\ndouble dp[maxn][maxn];\nstruct edge {\n    int u;\n    int v;\n    double w;\n};\nvector<edge> edges;\nint main(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++){\n        cin>>a>>b>>c>>d;\n        edges.push_back({b,d,log(a/c)});\n    }\n    for (int i=1;i<=n;i++) {\n        for (auto [u,v,w] : edges) {\n            dp[i][v] = min(dp[i][v],dp[i-1][u]+w);\n        }\n    }\n    for(int v=1;v<=n;v++){\n        double t = -INFINITY;\n        for(int k=0;k<n;k++){\n            t = max(t,(dp[n][v]-dp[k][v])/(n-k));\n        }\n        ans = min(t,ans);\n    }\n    printf(\"%.15lf\\n\",exp(ans));\n    return 0;\n}\n```\n# G-Link with Monotonic Subsequence\n\n来源: 牛客多校训练营2\n算法: 构造\n题目链接: https://ac.nowcoder.com/acm/contest/33187/G\n补完: Yes\n完成时间: August 2, 2022\n\n## 题意概括\n\n给定一个整数n，由整数1~n任意排列组成一个序列p\n\n$p的价值=\\max(lis(p),lds(p))$\n\nlis(p)是p的最长递增子序列长度\n\nlds（p)是p的最长递减子序列长度\n\n**求所有排列中价值最小的序列（多个只需输出其中一个即可）**\n\n即：构造出一个由整数1~n组成的序列，使得其 最长递增子序列的长度和最长递减子序列的长度 的最大值最小，输出该序列。\n\n## 解题思路\n\n理解题意后采用逆向思维，想办法怎么破坏子序列的递增和递减性\n\n首先想到，将整个序列分成两部分，使得两段的递减段无法连起来，例如n=8时，4321 8765，开心的交了一发，WA了。。。\n\n再想想，举个大一点的数，n=9时，按上述方式构造应该是：54321 9876，仔细想想。。好像可以分成三段：321 654 987，这样的价值就变成了3\n\n如果是n=10呢？就只能分成4段了：4321 8765 109\n\n总结归纳一下就是：一个序列的价值应该为$[\\sqrt{n} ]$。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n    int n;\n    cin>>n;\n    int a = (int)sqrt(n);\n    if(a*a!=n)a++;\n    for(int j=1;j<=a;j++){\n        for(int i=0;i<a;i++){\n            if(j*a-i<=n)\n                printf(\"%d \",j*a-i);\n        }\n    }\n    printf(\"\\n\");\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n\n# H-Take the Elevator\n\n来源: 牛客多校训练营2\n算法: 前缀和, 离散化\n题目链接: https://ac.nowcoder.com/acm/contest/33187/H\n补完: Yes\n完成时间: July 29, 2022\n\n## 题解\n\n高$k$层的楼用容量为$m$的电梯运$n$人从$a_i$层去$b_i$层. 求电梯最快下班时间. \n\n有人上楼有人下楼, 电梯在从下往上运人和从上往下运人之间不冲突.\n\n设有$up(i)$人需要从第$i$层到第$i+1$层, 有$dn(i)$人需要从第$i+1$层到第$1$层, \n\n则电梯在$i$到$i+1$层之间至少需要从下往上运行$\\lceil \\frac{up(i)}{m} \\rceil$次, 至少需要从上往下运行$\\lceil \\frac{dn(i)}{m} \\rceil$次, \n\n电梯每次工作都对应一次上升和下降, 则在在$i$到$i+1$层之间至少需要运行$\\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil \\frac{dn(i)}{m} \\rceil)$个回合, 即为至少要到达$i+1$层的回合数, 记为 \n\n$$\nneed[i] = \\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil \\frac{dn(i)}{m} \\rceil)\n$$\n\n电梯每次工作都要一次性升到此次任务最高点然后返回第一层, 即在满足高层需求时, 低层需求也会被顺带满足, 故优先考需高层任务. 若高层的任务更多, 低层没有任务却仍会被经过, 因而低层的实际运行次数会被高层的运行次数覆盖, 记实际在$i$到$i+1$层之间运行的回合数为 \n\n$$\ncnt[i] = \\max_{j≥i}\\{need[j]\\}\n$$\n\n统计所有楼层间的运行时间即为最终答案, 每个回合含上下楼两个操作, 每个操作花费$1$时间\n\n$$\nans=2*\\sum_{i=2}^k cnt[i]\n$$\n\n按人流方向差分前缀和处理, 上下累加方向相反可反向差分, 然后从高层开始累计.\n\n本题$k$比较大, 需要离散化处理\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200005;\nint n,m,k,sum;\nint c[2*MAXN];\nint a[MAXN],b[MAXN];\nint up[2*MAXN],dn[2*MAXN];\nint cnt[2*MAXN];\nlong long ans;\nint main(){\n    cin>>n>>m>>k;\n    for(int i = 1;i<=n;i++){\n        cin>>a[i]>>b[i];\n        c[sum++] = a[i];\n        c[sum++] = b[i];\n    }\n    sort(c,c+sum);\n    sum = unique(c,c+sum) - c;\n    for(int i = 1;i<=n;i++){\n        int l = lower_bound(c,c+sum,a[i]) - c;\n        int r = lower_bound(c,c+sum,b[i]) - c;\n        if(l<r){\n            up[l+1]++;\n            up[r+1]--;\n        }\n        else{\n            dn[r+1]++;\n            dn[l+1]--;\n        }\n    }\n    for(int i = 1;i<sum;i++){\n        up[i]+=up[i-1];\n        dn[i]+=dn[i-1];\n        int need = max((up[i]+m-1)/m,(dn[i]+m-1)/m);\n        cnt[need] = max(cnt[need],c[i]-1);\n    }\n    for(int i = n;i>=1;i--){\n        cnt[i] = max(cnt[i+1],cnt[i]);\n        ans+=cnt[i];\n    }\n    cout<<ans*2<<'\\n';\n    return 0;\n}\n```\n# I-let fat tension\n\n来源: 牛客多校训练营2\n算法: 向量, 矩阵乘法\n补完: Yes\n完成时间: August 3, 2022\n\n## 题解\n\n给$n$个练功的大师, 每个大师有$k$种属性值和$d$种技能等级, 定义为\n\n$$\nX_i\\in \\mathbb R^k, Y_i\\in \\mathbb R^d\n$$\n\n大师相互学习, 技能等级得到提升, 其中第$i$个大师向第$j$个大师学习第$o$个技能会有: \n\n$$\ny_{i,o}^{i-j}=\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\n$$\n\n大师同时向所有大师学习,最终有\n\n$$\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\n$$\n\n对于求向量点乘和向量模有\n\n$$\nA\\cdot B=\\sum_{i=1}^La_ib_i\\\\\n|A|=\\sqrt{\\sum_{i=1}^La_i^2}\n$$\n\n代入有\n\n$$\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{\\sum_{p=1}^kx_{i,p}x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}\\sqrt{\\sum_{p=1}^kx_{j,p}^2}} y_{j,o}\n$$\n\n改变求和顺序可以减少复杂度\n\n$$\ny_{i,o}^{new}=\\sum_{p=1}^k\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} \\sum_{j=1}^n\\frac{x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} y_{j,o}\n$$\n\n大师的属性可以预处理\n\n$$\nx_{i,p}'=\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} \n$$\n\n但是直接记录$x_{i,p}'$会出问题, 记录分母即可\n\n最后\n\n$$\ny_{i,o}^{new}=\\sum_{p=1}^kx_{i,p}' \\sum_{j=1}^nx_{j,p}'y_{j,o}\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10005;\nconst int MAXM = 55;\n\ndouble x[MAXN][MAXM],y[MAXN][MAXM],xx[MAXN],op[MAXN][MAXN];\n\nvoid solve(){\n    int n,k,d;\n    cin>>n>>k>>d;\n    for(int i = 1; i <= n; i++){\n        for(int p = 1; p <= k; p++){\n            cin>>x[i][p];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int o = 1; o <= d; o++){\n            cin>>y[i][o];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int p = 1; p <= k; p++){\n            xx[i] += x[i][p]*x[i][p];\n        }\n        xx[i] = sqrt(xx[i]);\n    }\n    for(int o = 1; o <= d; o++){\n        for(int p = 1; p <= k; p++){\n            for(int j = 1; j <= n; j++){\n                op[o][p] += x[j][p]*y[j][o]/xx[j];\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int o = 1; o <= d; o++){\n            double ans = 0;\n            for(int p = 1; p <= k; p++){\n                ans += x[i][p]*op[o][p]/xx[i];\n            }\n            printf(\"%lf \",ans);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# J-Link with Arithmetic Progression\n\n来源: 牛客多校训练营2\n算法: 数论\n题目链接: https://ac.nowcoder.com/acm/contest/33187/J\n补完: Yes\n完成时间: July 31, 2022\n\n## 题解\n\n一元线性回归,套公式即可\n\n$$\nY=kx+a\n$$\n\n$$\nk=\\frac{\\sum(x_i-\\bar x)(y_i-\\bar y)}{\\sum(x_i-\\bar x)^2}\n$$\n\n$$\na=\\bar y - k\\bar x\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nlong double xbar,ybar,x[300005],y[300005],k,k1,k2,a,ans,t;\nvoid solve(){\n    xbar=ybar=0;\n    k1=k2=0;\n    ans=0;\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        x[i]=(long double)i;\n        xbar+=x[i];\n        cin>>y[i];\n        ybar+=y[i];\n    }\n    xbar/=(long double)n;\n    ybar/=(long double)n;\n    for(int i=1;i<=n;i++){\n        k1+=(i-xbar)*(y[i]-ybar);\n        k2+=(i-xbar)*(i-xbar);\n    }\n    k=k1/k2;\n    a=ybar-k*xbar;\n    for(int i=1;i<=n;i++){\n        t=(y[i]-(a+k*x[i]));\n        ans+=t*t;\n    }\n    printf(\"%.15llf\\n\",ans);\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# K-Link with Bracket Sequence I\n\n来源: 牛客多校训练营2\n算法: 动态规划\n题目链接: https://ac.nowcoder.com/acm/contest/33187/K\n补完: Yes\n完成时间: July 26, 2022\n\n## 题解\n\n从子序列构造原序列, 求可满足的原序列数量. \n\n考虑$dp[i][j]$为以子序列的前$j$个字符为子序列能构造出的长度为$i$的原序列数量. \n\n或以长度为$i$的原序列最多可以提取出的以子序列的前$j$个字符为子序列的数量. \n\n对于子序列的第$j+1$个字符, 无法在[原序列的被第$j$个字符匹配的字符之后、第$i$个字符之前]找到. \n\n本题中子序列为可能合法的括号序列, 原序列为合法的括号序列. \n\n在括号序列中, 为使原序列合法, 每个左括号都要有与其匹配的右括号.\n\n增设一维$dp[i][j][k]$, 其中$k$表示原序列中未得到匹配的左括号数量或表示$i$个字符之后还需要$k$个右括号使原序列合法, 仅当$k==0$时原序列为合法括号序列. \n\n- 对$dp[i][j][k]$, 若不为合法序列, 让我们继续构造原序列:\n    - 设原序列的第$i+1$个字符为左括号, 则未匹配的左括号数量增多, 此时\n        \n        若子序列的第$j+1$个字符为左括号则恰好得到对应, 即两序列长度都得到增加, 有\n        \n        $$\n        dp[i+1][j+1][k+1] += dp[i][j][k]\n        $$\n        \n        若子序列的第$j+1$个字符非左括号则无法得到对应, 仅原序列的长度得到增加, 有\n        \n        $$\n        dp[i+1][~~~j~~~][k+1] += dp[i][j][k]\n        $$\n        \n    - 设原序列的第$i+1$个字符为右括号, 则未匹配的左括号数量减少, 此时\n        \n        若子序列的第$j+1$个字符为右括号则恰好得到对应, 即两序列长度都得到增加, 有\n        \n        $$\n        dp[i+1][j+1][k-1] += dp[i][j][k]\n        $$\n        \n        若子序列的第$j+1$个字符非右括号则无法得到对应, 仅原序列的长度得到增加, 有\n        \n        $$\n        dp[i+1][~~~j~~~][k-1] += dp[i][j][k]\n        $$\n        \n\n初始情况, 有空子序列构造空原序列, 为$1$种可能\n\n$$\ndp[0][0][0]=1\n$$\n\n最终答案为\n\n$$\ndp[m][n][0]\n$$\n\n计算过程中子序列长度不会超过原序列长度故有$j<=i$\n\n同时待匹配左括号数量不会超过原序列长度故有$k<=i$\n\n为防止越界,与$k$相关的指针$+1$处理\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int P = 1e9+7;\nint dp[205][205][205];\nint n,m;\nstring a;\nvoid add(int& a,int b){\n    a = (a+b)%P;\n}\nvoid solve(){\n    scanf(\"%d%d%s\",&n,&m,&a[1]);\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0+1] = 1;\n    for(int i=0;i<m;i++){\n        for(int k=0+1;k<=i+1;k++){\n            for(int j=0;j<=i;j++){\n                if(a[j+1]=='('){\n                    add(dp[i+1][j+1][k+1],dp[i][j][k]);\n                }else{\n                    add(dp[i+1][ j ][k+1],dp[i][j][k]);\n                }\n                if(a[j+1]==')'){\n                    add(dp[i+1][j+1][k-1],dp[i][j][k]);\n                }else{\n                    add(dp[i+1][ j ][k-1],dp[i][j][k]);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[m][n][0+1]);\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# L-Link with Level Editor I\n\n来源: 牛客多校训练营2\n算法: 动态规划\n题目链接: https://ac.nowcoder.com/acm/contest/33187/L\n补完: Yes\n完成时间: July 27, 2022\n\n## 题解\n\n给$n$个世界, 每个世界有含$m$个点的有向图, 每个世界可以图上走一步或者不走.\n\n从第一个世界的点$1$出发, 想要走到点$m$, 求最少经过几个世界. 如果走不到就输出$-1$. \n\n要求\n\n事实上整张地图是立体的, 在第$i$个世界时, \n\n对每个点$u_i$, 若不走则到达下个世界的这个点, 化为有向边$<u_i,u_{i+1}>$,  对由这个点发出的有向边$<u_i,v_i>$, 若走一步, 可以化为连向下一个世界的有向边 $<u_{i},v_{i+1}>$. \n\n记$dp[i][j]$为到达第$i$个世界的第$j$个点需要经过的最小步数, 则可通过上述推出到下一个世界的最小步数. \n\n若没有边指向此点, 仅在上一层的此点基础上加一.\n\n$$\ndp[i+1][u_{i+1}]=dp[i][u_{i}]+1\n$$\n\n若有边指向此点, 则选步数最小的一点加一\n\n$$\ndp[i+1][v_{i+1}]=\\min_{u\\to v\\in E} \\{ {dp[i][u_i]+1}\\}\n$$\n\n我们可以选择任意一个世界作为起点, 故第一个点始终求得$1$\n\n$$\ndp[i+1][1]=dp[i][1]+1=1\n$$\n\n故每次循环都要刷新\n\n$$\ndp[i][1]=0\n$$\n\n其他未到达的点设为无穷大表示不能走到\n\n最终答案为\n\n$$\n\\min_{1≤i≤n}\\{dp[i+1][m]\\}\n$$\n\n使用滚动数组. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,l,ans = 0x3f3f3f3f;\nint u,v;\nint dp[2][2005];\nint main(){\n    cin>>n>>m;\n    memset(dp,0x3f3f3f3f,sizeof(dp));\n    for(int i=1;i<=n;i++){\n        cin>>l;\n        dp[i%2][1] = 0 ;\n        dp[(i+1)%2][1] = 0x3f3f3f3f ;\n        for(int u=1;u<=m;u++){\n            dp[(i+1)%2][u] = dp[i%2][u]+1;\n        }\n        for(int j=1;j<=l;j++){\n            cin>>u>>v;\n            dp[(i+1)%2][v] = min(dp[(i+1)%2][v],dp[i%2][u]+1);\n        }\n        ans = min(ans,dp[(i+1)%2][m]);\n    }\n    if(ans==0x3f3f3f3f)cout<<-1;\n    else cout<<ans;\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营02.md","raw":"---\ntitle: 2022牛客多校训练营02\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# D-Link with Game Glitch\n\n来源: 牛客多校训练营2\n算法: 图论\n题目链接: https://ac.nowcoder.com/acm/contest/33187/D\n补完: Yes\n完成时间: July 25, 2022\n\n## 算法\n\n①二分答案+SPFA判负环\n\n②Karp的最小平均权重环路算法\n\n## 题解\n\n这里考虑法②\n\n题目有对于配方$i$有: 以$a_i$个物品 $b_i$为原料,制造$c_i$个物品$d_i$为产品\n\n$$\na_i\\times b_i\\to c_i \\times d_i \n$$\n\n可以理解为对于配方$i$有: 以$\\frac{a_i}{c_i}$个物品 $b_i$为原料,制造$1$个物品$d_i$为产品\n\n$$\n\\frac{a_i}{c_i}\\times b_i \\to d_i\n$$\n\n对于连续$k$个配方可以由配方的系数乘积从原料制造出产品\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i} 原料\\to 产品\n$$\n\n若某物品经过$k$道配方, 最终可以制造自己, 称为一循环配方\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\n$$\n\n以$n$种物品为点, $m$种配方为边, $\\frac{a_i}{c_i}$为边权建立有向图, 循环配方表现为环\n\n设循环配方中任意物品原有数量为$x$,个 则每次循环后可变为为$\\frac {x}{\\prod_{i}^k\\frac{a_i}{c_i}}$个,\n\n要使物品不会变多, 则必须$x≥\\frac {x}{\\prod_{i}^k\\frac{a_i}{c_i}}$, 也即\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i}≥1\n$$\n\n引入生产修正参数$w$\n\n$$\na_i\\times b_i\\to w\\times c_i \\times d_i \n$$\n\n可以理解为\n\n$$\n\\frac{a_i}{wc_i}\\times b_i \\to d_i\n$$\n\n可推得\n\n$$\n\\prod_{i}^k\\frac{a_i}{wc_i} 物品\\to 物品\n$$\n\n将$w$提出有\n\n$$\n\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\n$$\n\n重复上文推论\n\n以$n$种物品为点, $m$种配方为边, $\\frac{a_i}{wc_i}$为边权建立有向图, 循环配方表现为环\n\n设循环配方中任意物品原有数量为$x$,个 则每次循环后可变为为$\\frac {x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}$个,\n\n要使物品不会变多, 则必须$x≥\\frac {x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}$, 也即\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i}≥w^k\n$$\n\n对于不同的环有不同的$\\prod_{i}^k\\frac{a_i}{c_i}$, 即要求在每一个环中都满足上式,即\n\n$$\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})≥w^k\n$$\n\n且要求$w$取最大, 则要求\n\n$$\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})=w^k\n$$\n\n化简得\n\n$$\nw=\\min\\left(\\sqrt[k]{\\prod_{i}^k\\frac{a_i}{c_i}}\\right)\n$$\n\n其中连乘可用对数处理\n\n$$\n\\ln(\\prod_{i}^k\\frac{a_i}{c_i})=\\sum_i^k\\ln(\\frac{a_i}{c_i})\n$$\n\n化简得\n\n$$\n\\prod_{i}^k\\frac{a_i}{c_i}=e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}\n$$\n\n即要求\n\n$$\nw^k=e^{\\min(\\sum_i^k\\ln(\\frac{a_i}{c_i}))}\n$$\n\n最终\n\n$$\nw=\\min(\\sqrt[k]{e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}})\n$$\n\n$$\nw=\\exp\\left(\\min(\\frac{\\sum_i^k\\ln(\\frac{a_i}{c_i})}{k})\\right)\n$$\n\n则理解为求环的最小平均权重\n\n以$\\ln(\\frac{a_i}{c_i})$为边权建图$G(V,E)$\n\n有$Karp的最小平均权重环路算法$\n\n让$F[k][v]$为从任意点出发,经过$k$条边到达$v$点的最短距离, 对每条边$u\\to v$ 有\n\n$$\nF[k][v]=\\min_{e\\in E}\\{F[k-1][u]+w[u][v]\\}\n$$\n\n$$\nans = \\min_{v\\in V}\\{\\max_{0≤k≤n-1}\\{\\frac{F[n][v]-F[k][v]}{n-k}\\}\\}\n$$\n\n### 参考\n\n****[有向图中的最小平均权值回路](https://blog.csdn.net/qq_30361651/article/details/107801468)****\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2005;\nint n,m,b,d;\ndouble a,c,ans;\ndouble dp[maxn][maxn];\nstruct edge {\n    int u;\n    int v;\n    double w;\n};\nvector<edge> edges;\nint main(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++){\n        cin>>a>>b>>c>>d;\n        edges.push_back({b,d,log(a/c)});\n    }\n    for (int i=1;i<=n;i++) {\n        for (auto [u,v,w] : edges) {\n            dp[i][v] = min(dp[i][v],dp[i-1][u]+w);\n        }\n    }\n    for(int v=1;v<=n;v++){\n        double t = -INFINITY;\n        for(int k=0;k<n;k++){\n            t = max(t,(dp[n][v]-dp[k][v])/(n-k));\n        }\n        ans = min(t,ans);\n    }\n    printf(\"%.15lf\\n\",exp(ans));\n    return 0;\n}\n```\n# G-Link with Monotonic Subsequence\n\n来源: 牛客多校训练营2\n算法: 构造\n题目链接: https://ac.nowcoder.com/acm/contest/33187/G\n补完: Yes\n完成时间: August 2, 2022\n\n## 题意概括\n\n给定一个整数n，由整数1~n任意排列组成一个序列p\n\n$p的价值=\\max(lis(p),lds(p))$\n\nlis(p)是p的最长递增子序列长度\n\nlds（p)是p的最长递减子序列长度\n\n**求所有排列中价值最小的序列（多个只需输出其中一个即可）**\n\n即：构造出一个由整数1~n组成的序列，使得其 最长递增子序列的长度和最长递减子序列的长度 的最大值最小，输出该序列。\n\n## 解题思路\n\n理解题意后采用逆向思维，想办法怎么破坏子序列的递增和递减性\n\n首先想到，将整个序列分成两部分，使得两段的递减段无法连起来，例如n=8时，4321 8765，开心的交了一发，WA了。。。\n\n再想想，举个大一点的数，n=9时，按上述方式构造应该是：54321 9876，仔细想想。。好像可以分成三段：321 654 987，这样的价值就变成了3\n\n如果是n=10呢？就只能分成4段了：4321 8765 109\n\n总结归纳一下就是：一个序列的价值应该为$[\\sqrt{n} ]$。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n    int n;\n    cin>>n;\n    int a = (int)sqrt(n);\n    if(a*a!=n)a++;\n    for(int j=1;j<=a;j++){\n        for(int i=0;i<a;i++){\n            if(j*a-i<=n)\n                printf(\"%d \",j*a-i);\n        }\n    }\n    printf(\"\\n\");\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n\n# H-Take the Elevator\n\n来源: 牛客多校训练营2\n算法: 前缀和, 离散化\n题目链接: https://ac.nowcoder.com/acm/contest/33187/H\n补完: Yes\n完成时间: July 29, 2022\n\n## 题解\n\n高$k$层的楼用容量为$m$的电梯运$n$人从$a_i$层去$b_i$层. 求电梯最快下班时间. \n\n有人上楼有人下楼, 电梯在从下往上运人和从上往下运人之间不冲突.\n\n设有$up(i)$人需要从第$i$层到第$i+1$层, 有$dn(i)$人需要从第$i+1$层到第$1$层, \n\n则电梯在$i$到$i+1$层之间至少需要从下往上运行$\\lceil \\frac{up(i)}{m} \\rceil$次, 至少需要从上往下运行$\\lceil \\frac{dn(i)}{m} \\rceil$次, \n\n电梯每次工作都对应一次上升和下降, 则在在$i$到$i+1$层之间至少需要运行$\\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil \\frac{dn(i)}{m} \\rceil)$个回合, 即为至少要到达$i+1$层的回合数, 记为 \n\n$$\nneed[i] = \\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil \\frac{dn(i)}{m} \\rceil)\n$$\n\n电梯每次工作都要一次性升到此次任务最高点然后返回第一层, 即在满足高层需求时, 低层需求也会被顺带满足, 故优先考需高层任务. 若高层的任务更多, 低层没有任务却仍会被经过, 因而低层的实际运行次数会被高层的运行次数覆盖, 记实际在$i$到$i+1$层之间运行的回合数为 \n\n$$\ncnt[i] = \\max_{j≥i}\\{need[j]\\}\n$$\n\n统计所有楼层间的运行时间即为最终答案, 每个回合含上下楼两个操作, 每个操作花费$1$时间\n\n$$\nans=2*\\sum_{i=2}^k cnt[i]\n$$\n\n按人流方向差分前缀和处理, 上下累加方向相反可反向差分, 然后从高层开始累计.\n\n本题$k$比较大, 需要离散化处理\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200005;\nint n,m,k,sum;\nint c[2*MAXN];\nint a[MAXN],b[MAXN];\nint up[2*MAXN],dn[2*MAXN];\nint cnt[2*MAXN];\nlong long ans;\nint main(){\n    cin>>n>>m>>k;\n    for(int i = 1;i<=n;i++){\n        cin>>a[i]>>b[i];\n        c[sum++] = a[i];\n        c[sum++] = b[i];\n    }\n    sort(c,c+sum);\n    sum = unique(c,c+sum) - c;\n    for(int i = 1;i<=n;i++){\n        int l = lower_bound(c,c+sum,a[i]) - c;\n        int r = lower_bound(c,c+sum,b[i]) - c;\n        if(l<r){\n            up[l+1]++;\n            up[r+1]--;\n        }\n        else{\n            dn[r+1]++;\n            dn[l+1]--;\n        }\n    }\n    for(int i = 1;i<sum;i++){\n        up[i]+=up[i-1];\n        dn[i]+=dn[i-1];\n        int need = max((up[i]+m-1)/m,(dn[i]+m-1)/m);\n        cnt[need] = max(cnt[need],c[i]-1);\n    }\n    for(int i = n;i>=1;i--){\n        cnt[i] = max(cnt[i+1],cnt[i]);\n        ans+=cnt[i];\n    }\n    cout<<ans*2<<'\\n';\n    return 0;\n}\n```\n# I-let fat tension\n\n来源: 牛客多校训练营2\n算法: 向量, 矩阵乘法\n补完: Yes\n完成时间: August 3, 2022\n\n## 题解\n\n给$n$个练功的大师, 每个大师有$k$种属性值和$d$种技能等级, 定义为\n\n$$\nX_i\\in \\mathbb R^k, Y_i\\in \\mathbb R^d\n$$\n\n大师相互学习, 技能等级得到提升, 其中第$i$个大师向第$j$个大师学习第$o$个技能会有: \n\n$$\ny_{i,o}^{i-j}=\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\n$$\n\n大师同时向所有大师学习,最终有\n\n$$\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\n$$\n\n对于求向量点乘和向量模有\n\n$$\nA\\cdot B=\\sum_{i=1}^La_ib_i\\\\\n|A|=\\sqrt{\\sum_{i=1}^La_i^2}\n$$\n\n代入有\n\n$$\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{\\sum_{p=1}^kx_{i,p}x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}\\sqrt{\\sum_{p=1}^kx_{j,p}^2}} y_{j,o}\n$$\n\n改变求和顺序可以减少复杂度\n\n$$\ny_{i,o}^{new}=\\sum_{p=1}^k\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} \\sum_{j=1}^n\\frac{x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} y_{j,o}\n$$\n\n大师的属性可以预处理\n\n$$\nx_{i,p}'=\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} \n$$\n\n但是直接记录$x_{i,p}'$会出问题, 记录分母即可\n\n最后\n\n$$\ny_{i,o}^{new}=\\sum_{p=1}^kx_{i,p}' \\sum_{j=1}^nx_{j,p}'y_{j,o}\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10005;\nconst int MAXM = 55;\n\ndouble x[MAXN][MAXM],y[MAXN][MAXM],xx[MAXN],op[MAXN][MAXN];\n\nvoid solve(){\n    int n,k,d;\n    cin>>n>>k>>d;\n    for(int i = 1; i <= n; i++){\n        for(int p = 1; p <= k; p++){\n            cin>>x[i][p];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int o = 1; o <= d; o++){\n            cin>>y[i][o];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int p = 1; p <= k; p++){\n            xx[i] += x[i][p]*x[i][p];\n        }\n        xx[i] = sqrt(xx[i]);\n    }\n    for(int o = 1; o <= d; o++){\n        for(int p = 1; p <= k; p++){\n            for(int j = 1; j <= n; j++){\n                op[o][p] += x[j][p]*y[j][o]/xx[j];\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int o = 1; o <= d; o++){\n            double ans = 0;\n            for(int p = 1; p <= k; p++){\n                ans += x[i][p]*op[o][p]/xx[i];\n            }\n            printf(\"%lf \",ans);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# J-Link with Arithmetic Progression\n\n来源: 牛客多校训练营2\n算法: 数论\n题目链接: https://ac.nowcoder.com/acm/contest/33187/J\n补完: Yes\n完成时间: July 31, 2022\n\n## 题解\n\n一元线性回归,套公式即可\n\n$$\nY=kx+a\n$$\n\n$$\nk=\\frac{\\sum(x_i-\\bar x)(y_i-\\bar y)}{\\sum(x_i-\\bar x)^2}\n$$\n\n$$\na=\\bar y - k\\bar x\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nlong double xbar,ybar,x[300005],y[300005],k,k1,k2,a,ans,t;\nvoid solve(){\n    xbar=ybar=0;\n    k1=k2=0;\n    ans=0;\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        x[i]=(long double)i;\n        xbar+=x[i];\n        cin>>y[i];\n        ybar+=y[i];\n    }\n    xbar/=(long double)n;\n    ybar/=(long double)n;\n    for(int i=1;i<=n;i++){\n        k1+=(i-xbar)*(y[i]-ybar);\n        k2+=(i-xbar)*(i-xbar);\n    }\n    k=k1/k2;\n    a=ybar-k*xbar;\n    for(int i=1;i<=n;i++){\n        t=(y[i]-(a+k*x[i]));\n        ans+=t*t;\n    }\n    printf(\"%.15llf\\n\",ans);\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# K-Link with Bracket Sequence I\n\n来源: 牛客多校训练营2\n算法: 动态规划\n题目链接: https://ac.nowcoder.com/acm/contest/33187/K\n补完: Yes\n完成时间: July 26, 2022\n\n## 题解\n\n从子序列构造原序列, 求可满足的原序列数量. \n\n考虑$dp[i][j]$为以子序列的前$j$个字符为子序列能构造出的长度为$i$的原序列数量. \n\n或以长度为$i$的原序列最多可以提取出的以子序列的前$j$个字符为子序列的数量. \n\n对于子序列的第$j+1$个字符, 无法在[原序列的被第$j$个字符匹配的字符之后、第$i$个字符之前]找到. \n\n本题中子序列为可能合法的括号序列, 原序列为合法的括号序列. \n\n在括号序列中, 为使原序列合法, 每个左括号都要有与其匹配的右括号.\n\n增设一维$dp[i][j][k]$, 其中$k$表示原序列中未得到匹配的左括号数量或表示$i$个字符之后还需要$k$个右括号使原序列合法, 仅当$k==0$时原序列为合法括号序列. \n\n- 对$dp[i][j][k]$, 若不为合法序列, 让我们继续构造原序列:\n    - 设原序列的第$i+1$个字符为左括号, 则未匹配的左括号数量增多, 此时\n        \n        若子序列的第$j+1$个字符为左括号则恰好得到对应, 即两序列长度都得到增加, 有\n        \n        $$\n        dp[i+1][j+1][k+1] += dp[i][j][k]\n        $$\n        \n        若子序列的第$j+1$个字符非左括号则无法得到对应, 仅原序列的长度得到增加, 有\n        \n        $$\n        dp[i+1][~~~j~~~][k+1] += dp[i][j][k]\n        $$\n        \n    - 设原序列的第$i+1$个字符为右括号, 则未匹配的左括号数量减少, 此时\n        \n        若子序列的第$j+1$个字符为右括号则恰好得到对应, 即两序列长度都得到增加, 有\n        \n        $$\n        dp[i+1][j+1][k-1] += dp[i][j][k]\n        $$\n        \n        若子序列的第$j+1$个字符非右括号则无法得到对应, 仅原序列的长度得到增加, 有\n        \n        $$\n        dp[i+1][~~~j~~~][k-1] += dp[i][j][k]\n        $$\n        \n\n初始情况, 有空子序列构造空原序列, 为$1$种可能\n\n$$\ndp[0][0][0]=1\n$$\n\n最终答案为\n\n$$\ndp[m][n][0]\n$$\n\n计算过程中子序列长度不会超过原序列长度故有$j<=i$\n\n同时待匹配左括号数量不会超过原序列长度故有$k<=i$\n\n为防止越界,与$k$相关的指针$+1$处理\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int P = 1e9+7;\nint dp[205][205][205];\nint n,m;\nstring a;\nvoid add(int& a,int b){\n    a = (a+b)%P;\n}\nvoid solve(){\n    scanf(\"%d%d%s\",&n,&m,&a[1]);\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0+1] = 1;\n    for(int i=0;i<m;i++){\n        for(int k=0+1;k<=i+1;k++){\n            for(int j=0;j<=i;j++){\n                if(a[j+1]=='('){\n                    add(dp[i+1][j+1][k+1],dp[i][j][k]);\n                }else{\n                    add(dp[i+1][ j ][k+1],dp[i][j][k]);\n                }\n                if(a[j+1]==')'){\n                    add(dp[i+1][j+1][k-1],dp[i][j][k]);\n                }else{\n                    add(dp[i+1][ j ][k-1],dp[i][j][k]);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[m][n][0+1]);\n}\nint main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# L-Link with Level Editor I\n\n来源: 牛客多校训练营2\n算法: 动态规划\n题目链接: https://ac.nowcoder.com/acm/contest/33187/L\n补完: Yes\n完成时间: July 27, 2022\n\n## 题解\n\n给$n$个世界, 每个世界有含$m$个点的有向图, 每个世界可以图上走一步或者不走.\n\n从第一个世界的点$1$出发, 想要走到点$m$, 求最少经过几个世界. 如果走不到就输出$-1$. \n\n要求\n\n事实上整张地图是立体的, 在第$i$个世界时, \n\n对每个点$u_i$, 若不走则到达下个世界的这个点, 化为有向边$<u_i,u_{i+1}>$,  对由这个点发出的有向边$<u_i,v_i>$, 若走一步, 可以化为连向下一个世界的有向边 $<u_{i},v_{i+1}>$. \n\n记$dp[i][j]$为到达第$i$个世界的第$j$个点需要经过的最小步数, 则可通过上述推出到下一个世界的最小步数. \n\n若没有边指向此点, 仅在上一层的此点基础上加一.\n\n$$\ndp[i+1][u_{i+1}]=dp[i][u_{i}]+1\n$$\n\n若有边指向此点, 则选步数最小的一点加一\n\n$$\ndp[i+1][v_{i+1}]=\\min_{u\\to v\\in E} \\{ {dp[i][u_i]+1}\\}\n$$\n\n我们可以选择任意一个世界作为起点, 故第一个点始终求得$1$\n\n$$\ndp[i+1][1]=dp[i][1]+1=1\n$$\n\n故每次循环都要刷新\n\n$$\ndp[i][1]=0\n$$\n\n其他未到达的点设为无穷大表示不能走到\n\n最终答案为\n\n$$\n\\min_{1≤i≤n}\\{dp[i+1][m]\\}\n$$\n\n使用滚动数组. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,l,ans = 0x3f3f3f3f;\nint u,v;\nint dp[2][2005];\nint main(){\n    cin>>n>>m;\n    memset(dp,0x3f3f3f3f,sizeof(dp));\n    for(int i=1;i<=n;i++){\n        cin>>l;\n        dp[i%2][1] = 0 ;\n        dp[(i+1)%2][1] = 0x3f3f3f3f ;\n        for(int u=1;u<=m;u++){\n            dp[(i+1)%2][u] = dp[i%2][u]+1;\n        }\n        for(int j=1;j<=l;j++){\n            cin>>u>>v;\n            dp[(i+1)%2][v] = min(dp[(i+1)%2][v],dp[i%2][u]+1);\n        }\n        ans = min(ans,dp[(i+1)%2][m]);\n    }\n    if(ans==0x3f3f3f3f)cout<<-1;\n    else cout<<ans;\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营02","published":1,"updated":"2023-10-29T07:14:11.984Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihex9000an0umf5s6frdd","content":"<h1 id=\"d-link-with-game-glitch\">D-Link with Game Glitch</h1>\r\n<p>来源: 牛客多校训练营2 算法: 图论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/D 补完: Yes 完成时间: July 25,\r\n2022</p>\r\n<h2 id=\"算法\">算法</h2>\r\n<p>①二分答案+SPFA判负环</p>\r\n<p>②Karp的最小平均权重环路算法</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>这里考虑法②</p>\r\n<p>题目有对于配方<span class=\"math inline\">\\(i\\)</span>有: 以<span\r\nclass=\"math inline\">\\(a_i\\)</span>个物品 <span\r\nclass=\"math inline\">\\(b_i\\)</span>为原料,制造<span\r\nclass=\"math inline\">\\(c_i\\)</span>个物品<span\r\nclass=\"math inline\">\\(d_i\\)</span>为产品</p>\r\n<p><span class=\"math display\">\\[\r\na_i\\times b_i\\to c_i \\times d_i\r\n\\]</span></p>\r\n<p>可以理解为对于配方<span class=\"math inline\">\\(i\\)</span>有: 以<span\r\nclass=\"math inline\">\\(\\frac{a_i}{c_i}\\)</span>个物品 <span\r\nclass=\"math inline\">\\(b_i\\)</span>为原料,制造<span\r\nclass=\"math inline\">\\(1\\)</span>个物品<span\r\nclass=\"math inline\">\\(d_i\\)</span>为产品</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{a_i}{c_i}\\times b_i \\to d_i\r\n\\]</span></p>\r\n<p>对于连续<span\r\nclass=\"math inline\">\\(k\\)</span>个配方可以由配方的系数乘积从原料制造出产品</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i} 原料\\to 产品\r\n\\]</span></p>\r\n<p>若某物品经过<span class=\"math inline\">\\(k\\)</span>道配方,\r\n最终可以制造自己, 称为一循环配方</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\r\n\\]</span></p>\r\n<p>以<span class=\"math inline\">\\(n\\)</span>种物品为点, <span\r\nclass=\"math inline\">\\(m\\)</span>种配方为边, <span\r\nclass=\"math inline\">\\(\\frac{a_i}{c_i}\\)</span>为边权建立有向图,\r\n循环配方表现为环</p>\r\n<p>设循环配方中任意物品原有数量为<span\r\nclass=\"math inline\">\\(x\\)</span>,个 则每次循环后可变为为<span\r\nclass=\"math inline\">\\(\\frac\r\n{x}{\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>个,</p>\r\n<p>要使物品不会变多, 则必须<span class=\"math inline\">\\(x≥\\frac\r\n{x}{\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>, 也即</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i}≥1\r\n\\]</span></p>\r\n<p>引入生产修正参数<span class=\"math inline\">\\(w\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\na_i\\times b_i\\to w\\times c_i \\times d_i\r\n\\]</span></p>\r\n<p>可以理解为</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{a_i}{wc_i}\\times b_i \\to d_i\r\n\\]</span></p>\r\n<p>可推得</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{wc_i} 物品\\to 物品\r\n\\]</span></p>\r\n<p>将<span class=\"math inline\">\\(w\\)</span>提出有</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\r\n\\]</span></p>\r\n<p>重复上文推论</p>\r\n<p>以<span class=\"math inline\">\\(n\\)</span>种物品为点, <span\r\nclass=\"math inline\">\\(m\\)</span>种配方为边, <span\r\nclass=\"math inline\">\\(\\frac{a_i}{wc_i}\\)</span>为边权建立有向图,\r\n循环配方表现为环</p>\r\n<p>设循环配方中任意物品原有数量为<span\r\nclass=\"math inline\">\\(x\\)</span>,个 则每次循环后可变为为<span\r\nclass=\"math inline\">\\(\\frac\r\n{x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>个,</p>\r\n<p>要使物品不会变多, 则必须<span class=\"math inline\">\\(x≥\\frac\r\n{x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>, 也即</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i}≥w^k\r\n\\]</span></p>\r\n<p>对于不同的环有不同的<span\r\nclass=\"math inline\">\\(\\prod_{i}^k\\frac{a_i}{c_i}\\)</span>,\r\n即要求在每一个环中都满足上式,即</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})≥w^k\r\n\\]</span></p>\r\n<p>且要求<span class=\"math inline\">\\(w\\)</span>取最大, 则要求</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})=w^k\r\n\\]</span></p>\r\n<p>化简得</p>\r\n<p><span class=\"math display\">\\[\r\nw=\\min\\left(\\sqrt[k]{\\prod_{i}^k\\frac{a_i}{c_i}}\\right)\r\n\\]</span></p>\r\n<p>其中连乘可用对数处理</p>\r\n<p><span class=\"math display\">\\[\r\n\\ln(\\prod_{i}^k\\frac{a_i}{c_i})=\\sum_i^k\\ln(\\frac{a_i}{c_i})\r\n\\]</span></p>\r\n<p>化简得</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i}=e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}\r\n\\]</span></p>\r\n<p>即要求</p>\r\n<p><span class=\"math display\">\\[\r\nw^k=e^{\\min(\\sum_i^k\\ln(\\frac{a_i}{c_i}))}\r\n\\]</span></p>\r\n<p>最终</p>\r\n<p><span class=\"math display\">\\[\r\nw=\\min(\\sqrt[k]{e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}})\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nw=\\exp\\left(\\min(\\frac{\\sum_i^k\\ln(\\frac{a_i}{c_i})}{k})\\right)\r\n\\]</span></p>\r\n<p>则理解为求环的最小平均权重</p>\r\n<p>以<span\r\nclass=\"math inline\">\\(\\ln(\\frac{a_i}{c_i})\\)</span>为边权建图<span\r\nclass=\"math inline\">\\(G(V,E)\\)</span></p>\r\n<p>有<span class=\"math inline\">\\(Karp的最小平均权重环路算法\\)</span></p>\r\n<p>让<span\r\nclass=\"math inline\">\\(F[k][v]\\)</span>为从任意点出发,经过<span\r\nclass=\"math inline\">\\(k\\)</span>条边到达<span\r\nclass=\"math inline\">\\(v\\)</span>点的最短距离, 对每条边<span\r\nclass=\"math inline\">\\(u\\to v\\)</span> 有</p>\r\n<p><span class=\"math display\">\\[\r\nF[k][v]=\\min_{e\\in E}\\{F[k-1][u]+w[u][v]\\}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nans = \\min_{v\\in V}\\{\\max_{0≤k≤n-1}\\{\\frac{F[n][v]-F[k][v]}{n-k}\\}\\}\r\n\\]</span></p>\r\n<h3 id=\"参考\">参考</h3>\r\n<p>****<a\r\nhref=\"https://blog.csdn.net/qq_30361651/article/details/107801468\">有向图中的最小平均权值回路</a>****</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">2005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,b,d;</span><br><span class=\"line\"><span class=\"type\">double</span> a,c,ans;</span><br><span class=\"line\"><span class=\"type\">double</span> dp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">edge</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    <span class=\"type\">double</span> w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">vector&lt;edge&gt; edges;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\">        edges.<span class=\"built_in\">push_back</span>(&#123;b,d,<span class=\"built_in\">log</span>(a/c)&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [u,v,w] : edges) &#123;</span><br><span class=\"line\">            dp[i][v] = <span class=\"built_in\">min</span>(dp[i][v],dp[i<span class=\"number\">-1</span>][u]+w);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=<span class=\"number\">1</span>;v&lt;=n;v++)&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> t = -INFINITY;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;n;k++)&#123;</span><br><span class=\"line\">            t = <span class=\"built_in\">max</span>(t,(dp[n][v]-dp[k][v])/(n-k));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">min</span>(t,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf\\n&quot;</span>,<span class=\"built_in\">exp</span>(ans));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-link-with-monotonic-subsequence\">G-Link with Monotonic\r\nSubsequence</h1>\r\n<p>来源: 牛客多校训练营2 算法: 构造 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/G 补完: Yes 完成时间: August\r\n2, 2022</p>\r\n<h2 id=\"题意概括\">题意概括</h2>\r\n<p>给定一个整数n，由整数1~n任意排列组成一个序列p</p>\r\n<p><span class=\"math inline\">\\(p的价值=\\max(lis(p),lds(p))\\)</span></p>\r\n<p>lis(p)是p的最长递增子序列长度</p>\r\n<p>lds（p)是p的最长递减子序列长度</p>\r\n<p><strong>求所有排列中价值最小的序列（多个只需输出其中一个即可）</strong></p>\r\n<p>即：构造出一个由整数1~n组成的序列，使得其\r\n最长递增子序列的长度和最长递减子序列的长度\r\n的最大值最小，输出该序列。</p>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>理解题意后采用逆向思维，想办法怎么破坏子序列的递增和递减性</p>\r\n<p>首先想到，将整个序列分成两部分，使得两段的递减段无法连起来，例如n=8时，4321\r\n8765，开心的交了一发，WA了。。。</p>\r\n<p>再想想，举个大一点的数，n=9时，按上述方式构造应该是：54321\r\n9876，仔细想想。。好像可以分成三段：321 654 987，这样的价值就变成了3</p>\r\n<p>如果是n=10呢？就只能分成4段了：4321 8765 109</p>\r\n<p>总结归纳一下就是：一个序列的价值应该为<span\r\nclass=\"math inline\">\\([\\sqrt{n} ]\\)</span>。</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = (<span class=\"type\">int</span>)<span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a*a!=n)a++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=a;j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;a;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j*a-i&lt;=n)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,j*a-i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"h-take-the-elevator\">H-Take the Elevator</h1>\r\n<p>来源: 牛客多校训练营2 算法: 前缀和, 离散化 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/H 补完: Yes 完成时间: July 29,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>高<span class=\"math inline\">\\(k\\)</span>层的楼用容量为<span\r\nclass=\"math inline\">\\(m\\)</span>的电梯运<span\r\nclass=\"math inline\">\\(n\\)</span>人从<span\r\nclass=\"math inline\">\\(a_i\\)</span>层去<span\r\nclass=\"math inline\">\\(b_i\\)</span>层. 求电梯最快下班时间.</p>\r\n<p>有人上楼有人下楼, 电梯在从下往上运人和从上往下运人之间不冲突.</p>\r\n<p>设有<span class=\"math inline\">\\(up(i)\\)</span>人需要从第<span\r\nclass=\"math inline\">\\(i\\)</span>层到第<span\r\nclass=\"math inline\">\\(i+1\\)</span>层, 有<span\r\nclass=\"math inline\">\\(dn(i)\\)</span>人需要从第<span\r\nclass=\"math inline\">\\(i+1\\)</span>层到第<span\r\nclass=\"math inline\">\\(1\\)</span>层,</p>\r\n<p>则电梯在<span class=\"math inline\">\\(i\\)</span>到<span\r\nclass=\"math inline\">\\(i+1\\)</span>层之间至少需要从下往上运行<span\r\nclass=\"math inline\">\\(\\lceil \\frac{up(i)}{m} \\rceil\\)</span>次,\r\n至少需要从上往下运行<span class=\"math inline\">\\(\\lceil \\frac{dn(i)}{m}\r\n\\rceil\\)</span>次,</p>\r\n<p>电梯每次工作都对应一次上升和下降, 则在在<span\r\nclass=\"math inline\">\\(i\\)</span>到<span\r\nclass=\"math inline\">\\(i+1\\)</span>层之间至少需要运行<span\r\nclass=\"math inline\">\\(\\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil\r\n\\frac{dn(i)}{m} \\rceil)\\)</span>个回合, 即为至少要到达<span\r\nclass=\"math inline\">\\(i+1\\)</span>层的回合数, 记为</p>\r\n<p><span class=\"math display\">\\[\r\nneed[i] = \\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil \\frac{dn(i)}{m}\r\n\\rceil)\r\n\\]</span></p>\r\n<p>电梯每次工作都要一次性升到此次任务最高点然后返回第一层,\r\n即在满足高层需求时, 低层需求也会被顺带满足, 故优先考需高层任务.\r\n若高层的任务更多, 低层没有任务却仍会被经过,\r\n因而低层的实际运行次数会被高层的运行次数覆盖, 记实际在<span\r\nclass=\"math inline\">\\(i\\)</span>到<span\r\nclass=\"math inline\">\\(i+1\\)</span>层之间运行的回合数为</p>\r\n<p><span class=\"math display\">\\[\r\ncnt[i] = \\max_{j≥i}\\{need[j]\\}\r\n\\]</span></p>\r\n<p>统计所有楼层间的运行时间即为最终答案, 每个回合含上下楼两个操作,\r\n每个操作花费<span class=\"math inline\">\\(1\\)</span>时间</p>\r\n<p><span class=\"math display\">\\[\r\nans=2*\\sum_{i=2}^k cnt[i]\r\n\\]</span></p>\r\n<p>按人流方向差分前缀和处理, 上下累加方向相反可反向差分,\r\n然后从高层开始累计.</p>\r\n<p>本题<span class=\"math inline\">\\(k\\)</span>比较大, 需要离散化处理 ##\r\n代码</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">200005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k,sum;</span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">2</span>*MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> a[MAXN],b[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> up[<span class=\"number\">2</span>*MAXN],dn[<span class=\"number\">2</span>*MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[<span class=\"number\">2</span>*MAXN];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class=\"line\">        c[sum++] = a[i];</span><br><span class=\"line\">        c[sum++] = b[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(c,c+sum);</span><br><span class=\"line\">    sum = <span class=\"built_in\">unique</span>(c,c+sum) - c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">lower_bound</span>(c,c+sum,a[i]) - c;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">lower_bound</span>(c,c+sum,b[i]) - c;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&lt;r)&#123;</span><br><span class=\"line\">            up[l<span class=\"number\">+1</span>]++;</span><br><span class=\"line\">            up[r<span class=\"number\">+1</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            dn[r<span class=\"number\">+1</span>]++;</span><br><span class=\"line\">            dn[l<span class=\"number\">+1</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;sum;i++)&#123;</span><br><span class=\"line\">        up[i]+=up[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        dn[i]+=dn[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> need = <span class=\"built_in\">max</span>((up[i]+m<span class=\"number\">-1</span>)/m,(dn[i]+m<span class=\"number\">-1</span>)/m);</span><br><span class=\"line\">        cnt[need] = <span class=\"built_in\">max</span>(cnt[need],c[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">        cnt[i] = <span class=\"built_in\">max</span>(cnt[i<span class=\"number\">+1</span>],cnt[i]);</span><br><span class=\"line\">        ans+=cnt[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans*<span class=\"number\">2</span>&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"i-let-fat-tension\">I-let fat tension</h1>\r\n<p>来源: 牛客多校训练营2 算法: 向量, 矩阵乘法 补完: Yes 完成时间: August\r\n3, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>给<span class=\"math inline\">\\(n\\)</span>个练功的大师, 每个大师有<span\r\nclass=\"math inline\">\\(k\\)</span>种属性值和<span\r\nclass=\"math inline\">\\(d\\)</span>种技能等级, 定义为</p>\r\n<p><span class=\"math display\">\\[\r\nX_i\\in \\mathbb R^k, Y_i\\in \\mathbb R^d\r\n\\]</span></p>\r\n<p>大师相互学习, 技能等级得到提升, 其中第<span\r\nclass=\"math inline\">\\(i\\)</span>个大师向第<span\r\nclass=\"math inline\">\\(j\\)</span>个大师学习第<span\r\nclass=\"math inline\">\\(o\\)</span>个技能会有:</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{i-j}=\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\r\n\\]</span></p>\r\n<p>大师同时向所有大师学习,最终有</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\r\n\\]</span></p>\r\n<p>对于求向量点乘和向量模有</p>\r\n<p><span class=\"math display\">\\[\r\nA\\cdot B=\\sum_{i=1}^La_ib_i\\\\\r\n|A|=\\sqrt{\\sum_{i=1}^La_i^2}\r\n\\]</span></p>\r\n<p>代入有</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{\\sum_{p=1}^kx_{i,p}x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}\\sqrt{\\sum_{p=1}^kx_{j,p}^2}}\r\ny_{j,o}\r\n\\]</span></p>\r\n<p>改变求和顺序可以减少复杂度</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{p=1}^k\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}}\r\n\\sum_{j=1}^n\\frac{x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} y_{j,o}\r\n\\]</span></p>\r\n<p>大师的属性可以预处理</p>\r\n<p><span class=\"math display\">\\[\r\nx_{i,p}&#39;=\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}}\r\n\\]</span></p>\r\n<p>但是直接记录<span\r\nclass=\"math inline\">\\(x_{i,p}&#39;\\)</span>会出问题, 记录分母即可</p>\r\n<p>最后</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{p=1}^kx_{i,p}&#39; \\sum_{j=1}^nx_{j,p}&#39;y_{j,o}\r\n\\]</span></p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">10005</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXM = <span class=\"number\">55</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> x[MAXN][MAXM],y[MAXN][MAXM],xx[MAXN],op[MAXN][MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,k,d;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;d;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;x[i][p];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> o = <span class=\"number\">1</span>; o &lt;= d; o++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;y[i][o];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">            xx[i] += x[i][p]*x[i][p];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        xx[i] = <span class=\"built_in\">sqrt</span>(xx[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> o = <span class=\"number\">1</span>; o &lt;= d; o++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                op[o][p] += x[j][p]*y[j][o]/xx[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> o = <span class=\"number\">1</span>; o &lt;= d; o++)&#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">                ans += x[i][p]*op[o][p]/xx[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lf &quot;</span>,ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-link-with-arithmetic-progression\">J-Link with Arithmetic\r\nProgression</h1>\r\n<p>来源: 牛客多校训练营2 算法: 数论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/J 补完: Yes 完成时间: July 31,\r\n2022</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>一元线性回归,套公式即可</p>\r\n<p><span class=\"math display\">\\[\r\nY=kx+a\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nk=\\frac{\\sum(x_i-\\bar x)(y_i-\\bar y)}{\\sum(x_i-\\bar x)^2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\na=\\bar y - k\\bar x\r\n\\]</span></p>\r\n<h2 id=\"代码-3\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">double</span> xbar,ybar,x[<span class=\"number\">300005</span>],y[<span class=\"number\">300005</span>],k,k1,k2,a,ans,t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    xbar=ybar=<span class=\"number\">0</span>;</span><br><span class=\"line\">    k1=k2=<span class=\"number\">0</span>;</span><br><span class=\"line\">    ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        x[i]=(<span class=\"type\">long</span> <span class=\"type\">double</span>)i;</span><br><span class=\"line\">        xbar+=x[i];</span><br><span class=\"line\">        cin&gt;&gt;y[i];</span><br><span class=\"line\">        ybar+=y[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    xbar/=(<span class=\"type\">long</span> <span class=\"type\">double</span>)n;</span><br><span class=\"line\">    ybar/=(<span class=\"type\">long</span> <span class=\"type\">double</span>)n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        k1+=(i-xbar)*(y[i]-ybar);</span><br><span class=\"line\">        k2+=(i-xbar)*(i-xbar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k=k1/k2;</span><br><span class=\"line\">    a=ybar-k*xbar;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        t=(y[i]-(a+k*x[i]));</span><br><span class=\"line\">        ans+=t*t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15llf\\n&quot;</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"k-link-with-bracket-sequence-i\">K-Link with Bracket Sequence\r\nI</h1>\r\n<p>来源: 牛客多校训练营2 算法: 动态规划 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/K 补完: Yes 完成时间: July 26,\r\n2022</p>\r\n<h2 id=\"题解-4\">题解</h2>\r\n<p>从子序列构造原序列, 求可满足的原序列数量.</p>\r\n<p>考虑<span class=\"math inline\">\\(dp[i][j]\\)</span>为以子序列的前<span\r\nclass=\"math inline\">\\(j\\)</span>个字符为子序列能构造出的长度为<span\r\nclass=\"math inline\">\\(i\\)</span>的原序列数量.</p>\r\n<p>或以长度为<span\r\nclass=\"math inline\">\\(i\\)</span>的原序列最多可以提取出的以子序列的前<span\r\nclass=\"math inline\">\\(j\\)</span>个字符为子序列的数量.</p>\r\n<p>对于子序列的第<span class=\"math inline\">\\(j+1\\)</span>个字符,\r\n无法在[原序列的被第<span\r\nclass=\"math inline\">\\(j\\)</span>个字符匹配的字符之后、第<span\r\nclass=\"math inline\">\\(i\\)</span>个字符之前]找到.</p>\r\n<p>本题中子序列为可能合法的括号序列, 原序列为合法的括号序列.</p>\r\n<p>在括号序列中, 为使原序列合法, 每个左括号都要有与其匹配的右括号.</p>\r\n<p>增设一维<span class=\"math inline\">\\(dp[i][j][k]\\)</span>, 其中<span\r\nclass=\"math inline\">\\(k\\)</span>表示原序列中未得到匹配的左括号数量或表示<span\r\nclass=\"math inline\">\\(i\\)</span>个字符之后还需要<span\r\nclass=\"math inline\">\\(k\\)</span>个右括号使原序列合法, 仅当<span\r\nclass=\"math inline\">\\(k==0\\)</span>时原序列为合法括号序列.</p>\r\n<ul>\r\n<li>对<span class=\"math inline\">\\(dp[i][j][k]\\)</span>, 若不为合法序列,\r\n让我们继续构造原序列:\r\n<ul>\r\n<li><p>设原序列的第<span\r\nclass=\"math inline\">\\(i+1\\)</span>个字符为左括号,\r\n则未匹配的左括号数量增多, 此时</p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符为左括号则恰好得到对应,\r\n即两序列长度都得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][j+1][k+1] += dp[i][j][k]\r\n  \\]</span></p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符非左括号则无法得到对应,\r\n仅原序列的长度得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][~~~j~~~][k+1] += dp[i][j][k]\r\n  \\]</span></p></li>\r\n<li><p>设原序列的第<span\r\nclass=\"math inline\">\\(i+1\\)</span>个字符为右括号,\r\n则未匹配的左括号数量减少, 此时</p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符为右括号则恰好得到对应,\r\n即两序列长度都得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][j+1][k-1] += dp[i][j][k]\r\n  \\]</span></p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符非右括号则无法得到对应,\r\n仅原序列的长度得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][~~~j~~~][k-1] += dp[i][j][k]\r\n  \\]</span></p></li>\r\n</ul></li>\r\n</ul>\r\n<p>初始情况, 有空子序列构造空原序列, 为<span\r\nclass=\"math inline\">\\(1\\)</span>种可能</p>\r\n<p><span class=\"math display\">\\[\r\ndp[0][0][0]=1\r\n\\]</span></p>\r\n<p>最终答案为</p>\r\n<p><span class=\"math display\">\\[\r\ndp[m][n][0]\r\n\\]</span></p>\r\n<p>计算过程中子序列长度不会超过原序列长度故有<span\r\nclass=\"math inline\">\\(j&lt;=i\\)</span></p>\r\n<p>同时待匹配左括号数量不会超过原序列长度故有<span\r\nclass=\"math inline\">\\(k&lt;=i\\)</span></p>\r\n<p>为防止越界,与<span class=\"math inline\">\\(k\\)</span>相关的指针<span\r\nclass=\"math inline\">\\(+1\\)</span>处理</p>\r\n<h2 id=\"代码-4\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> P = <span class=\"number\">1e9</span><span class=\"number\">+7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">205</span>][<span class=\"number\">205</span>][<span class=\"number\">205</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\">string a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    a = (a+b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,&amp;a[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(dp));</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span><span class=\"number\">+1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span><span class=\"number\">+1</span>;k&lt;=i<span class=\"number\">+1</span>;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[j<span class=\"number\">+1</span>]==<span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][j<span class=\"number\">+1</span>][k<span class=\"number\">+1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][ j ][k<span class=\"number\">+1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[j<span class=\"number\">+1</span>]==<span class=\"string\">&#x27;)&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][j<span class=\"number\">+1</span>][k<span class=\"number\">-1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][ j ][k<span class=\"number\">-1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,dp[m][n][<span class=\"number\">0</span><span class=\"number\">+1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"l-link-with-level-editor-i\">L-Link with Level Editor I</h1>\r\n<p>来源: 牛客多校训练营2 算法: 动态规划 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/L 补完: Yes 完成时间: July 27,\r\n2022</p>\r\n<h2 id=\"题解-5\">题解</h2>\r\n<p>给<span class=\"math inline\">\\(n\\)</span>个世界, 每个世界有含<span\r\nclass=\"math inline\">\\(m\\)</span>个点的有向图,\r\n每个世界可以图上走一步或者不走.</p>\r\n<p>从第一个世界的点<span class=\"math inline\">\\(1\\)</span>出发,\r\n想要走到点<span class=\"math inline\">\\(m\\)</span>, 求最少经过几个世界.\r\n如果走不到就输出<span class=\"math inline\">\\(-1\\)</span>.</p>\r\n<p>要求</p>\r\n<p>事实上整张地图是立体的, 在第<span\r\nclass=\"math inline\">\\(i\\)</span>个世界时,</p>\r\n<p>对每个点<span class=\"math inline\">\\(u_i\\)</span>,\r\n若不走则到达下个世界的这个点, 化为有向边<span\r\nclass=\"math inline\">\\(&lt;u_i,u_{i+1}&gt;\\)</span>,\r\n对由这个点发出的有向边<span\r\nclass=\"math inline\">\\(&lt;u_i,v_i&gt;\\)</span>, 若走一步,\r\n可以化为连向下一个世界的有向边 <span\r\nclass=\"math inline\">\\(&lt;u_{i},v_{i+1}&gt;\\)</span>.</p>\r\n<p>记<span class=\"math inline\">\\(dp[i][j]\\)</span>为到达第<span\r\nclass=\"math inline\">\\(i\\)</span>个世界的第<span\r\nclass=\"math inline\">\\(j\\)</span>个点需要经过的最小步数,\r\n则可通过上述推出到下一个世界的最小步数.</p>\r\n<p>若没有边指向此点, 仅在上一层的此点基础上加一.</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i+1][u_{i+1}]=dp[i][u_{i}]+1\r\n\\]</span></p>\r\n<p>若有边指向此点, 则选步数最小的一点加一</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i+1][v_{i+1}]=\\min_{u\\to v\\in E} \\{ {dp[i][u_i]+1}\\}\r\n\\]</span></p>\r\n<p>我们可以选择任意一个世界作为起点, 故第一个点始终求得<span\r\nclass=\"math inline\">\\(1\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\ndp[i+1][1]=dp[i][1]+1=1\r\n\\]</span></p>\r\n<p>故每次循环都要刷新</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i][1]=0\r\n\\]</span></p>\r\n<p>其他未到达的点设为无穷大表示不能走到</p>\r\n<p>最终答案为</p>\r\n<p><span class=\"math display\">\\[\r\n\\min_{1≤i≤n}\\{dp[i+1][m]\\}\r\n\\]</span></p>\r\n<p>使用滚动数组.</p>\r\n<h2 id=\"代码-5\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,l,ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> u,v;</span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">2</span>][<span class=\"number\">2005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp,<span class=\"number\">0x3f3f3f3f</span>,<span class=\"built_in\">sizeof</span>(dp));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;l;</span><br><span class=\"line\">        dp[i%<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">0x3f3f3f3f</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> u=<span class=\"number\">1</span>;u&lt;=m;u++)&#123;</span><br><span class=\"line\">            dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][u] = dp[i%<span class=\"number\">2</span>][u]<span class=\"number\">+1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=l;j++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">            dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][v] = <span class=\"built_in\">min</span>(dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][v],dp[i%<span class=\"number\">2</span>][u]<span class=\"number\">+1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">min</span>(ans,dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][m]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans==<span class=\"number\">0x3f3f3f3f</span>)cout&lt;&lt;<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"d-link-with-game-glitch\">D-Link with Game Glitch</h1>\r\n<p>来源: 牛客多校训练营2 算法: 图论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/D 补完: Yes 完成时间: July 25,\r\n2022</p>\r\n<h2 id=\"算法\">算法</h2>\r\n<p>①二分答案+SPFA判负环</p>\r\n<p>②Karp的最小平均权重环路算法</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>这里考虑法②</p>\r\n<p>题目有对于配方<span class=\"math inline\">\\(i\\)</span>有: 以<span\r\nclass=\"math inline\">\\(a_i\\)</span>个物品 <span\r\nclass=\"math inline\">\\(b_i\\)</span>为原料,制造<span\r\nclass=\"math inline\">\\(c_i\\)</span>个物品<span\r\nclass=\"math inline\">\\(d_i\\)</span>为产品</p>\r\n<p><span class=\"math display\">\\[\r\na_i\\times b_i\\to c_i \\times d_i\r\n\\]</span></p>\r\n<p>可以理解为对于配方<span class=\"math inline\">\\(i\\)</span>有: 以<span\r\nclass=\"math inline\">\\(\\frac{a_i}{c_i}\\)</span>个物品 <span\r\nclass=\"math inline\">\\(b_i\\)</span>为原料,制造<span\r\nclass=\"math inline\">\\(1\\)</span>个物品<span\r\nclass=\"math inline\">\\(d_i\\)</span>为产品</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{a_i}{c_i}\\times b_i \\to d_i\r\n\\]</span></p>\r\n<p>对于连续<span\r\nclass=\"math inline\">\\(k\\)</span>个配方可以由配方的系数乘积从原料制造出产品</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i} 原料\\to 产品\r\n\\]</span></p>\r\n<p>若某物品经过<span class=\"math inline\">\\(k\\)</span>道配方,\r\n最终可以制造自己, 称为一循环配方</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\r\n\\]</span></p>\r\n<p>以<span class=\"math inline\">\\(n\\)</span>种物品为点, <span\r\nclass=\"math inline\">\\(m\\)</span>种配方为边, <span\r\nclass=\"math inline\">\\(\\frac{a_i}{c_i}\\)</span>为边权建立有向图,\r\n循环配方表现为环</p>\r\n<p>设循环配方中任意物品原有数量为<span\r\nclass=\"math inline\">\\(x\\)</span>,个 则每次循环后可变为为<span\r\nclass=\"math inline\">\\(\\frac\r\n{x}{\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>个,</p>\r\n<p>要使物品不会变多, 则必须<span class=\"math inline\">\\(x≥\\frac\r\n{x}{\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>, 也即</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i}≥1\r\n\\]</span></p>\r\n<p>引入生产修正参数<span class=\"math inline\">\\(w\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\na_i\\times b_i\\to w\\times c_i \\times d_i\r\n\\]</span></p>\r\n<p>可以理解为</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{a_i}{wc_i}\\times b_i \\to d_i\r\n\\]</span></p>\r\n<p>可推得</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{wc_i} 物品\\to 物品\r\n\\]</span></p>\r\n<p>将<span class=\"math inline\">\\(w\\)</span>提出有</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i} 物品\\to 物品\r\n\\]</span></p>\r\n<p>重复上文推论</p>\r\n<p>以<span class=\"math inline\">\\(n\\)</span>种物品为点, <span\r\nclass=\"math inline\">\\(m\\)</span>种配方为边, <span\r\nclass=\"math inline\">\\(\\frac{a_i}{wc_i}\\)</span>为边权建立有向图,\r\n循环配方表现为环</p>\r\n<p>设循环配方中任意物品原有数量为<span\r\nclass=\"math inline\">\\(x\\)</span>,个 则每次循环后可变为为<span\r\nclass=\"math inline\">\\(\\frac\r\n{x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>个,</p>\r\n<p>要使物品不会变多, 则必须<span class=\"math inline\">\\(x≥\\frac\r\n{x}{\\frac1{w^k}\\prod_{i}^k\\frac{a_i}{c_i}}\\)</span>, 也即</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i}≥w^k\r\n\\]</span></p>\r\n<p>对于不同的环有不同的<span\r\nclass=\"math inline\">\\(\\prod_{i}^k\\frac{a_i}{c_i}\\)</span>,\r\n即要求在每一个环中都满足上式,即</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})≥w^k\r\n\\]</span></p>\r\n<p>且要求<span class=\"math inline\">\\(w\\)</span>取最大, 则要求</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(\\prod_{i}^k\\frac{a_i}{c_i})=w^k\r\n\\]</span></p>\r\n<p>化简得</p>\r\n<p><span class=\"math display\">\\[\r\nw=\\min\\left(\\sqrt[k]{\\prod_{i}^k\\frac{a_i}{c_i}}\\right)\r\n\\]</span></p>\r\n<p>其中连乘可用对数处理</p>\r\n<p><span class=\"math display\">\\[\r\n\\ln(\\prod_{i}^k\\frac{a_i}{c_i})=\\sum_i^k\\ln(\\frac{a_i}{c_i})\r\n\\]</span></p>\r\n<p>化简得</p>\r\n<p><span class=\"math display\">\\[\r\n\\prod_{i}^k\\frac{a_i}{c_i}=e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}\r\n\\]</span></p>\r\n<p>即要求</p>\r\n<p><span class=\"math display\">\\[\r\nw^k=e^{\\min(\\sum_i^k\\ln(\\frac{a_i}{c_i}))}\r\n\\]</span></p>\r\n<p>最终</p>\r\n<p><span class=\"math display\">\\[\r\nw=\\min(\\sqrt[k]{e^{\\sum_i^k\\ln(\\frac{a_i}{c_i})}})\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nw=\\exp\\left(\\min(\\frac{\\sum_i^k\\ln(\\frac{a_i}{c_i})}{k})\\right)\r\n\\]</span></p>\r\n<p>则理解为求环的最小平均权重</p>\r\n<p>以<span\r\nclass=\"math inline\">\\(\\ln(\\frac{a_i}{c_i})\\)</span>为边权建图<span\r\nclass=\"math inline\">\\(G(V,E)\\)</span></p>\r\n<p>有<span class=\"math inline\">\\(Karp的最小平均权重环路算法\\)</span></p>\r\n<p>让<span\r\nclass=\"math inline\">\\(F[k][v]\\)</span>为从任意点出发,经过<span\r\nclass=\"math inline\">\\(k\\)</span>条边到达<span\r\nclass=\"math inline\">\\(v\\)</span>点的最短距离, 对每条边<span\r\nclass=\"math inline\">\\(u\\to v\\)</span> 有</p>\r\n<p><span class=\"math display\">\\[\r\nF[k][v]=\\min_{e\\in E}\\{F[k-1][u]+w[u][v]\\}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nans = \\min_{v\\in V}\\{\\max_{0≤k≤n-1}\\{\\frac{F[n][v]-F[k][v]}{n-k}\\}\\}\r\n\\]</span></p>\r\n<h3 id=\"参考\">参考</h3>\r\n<p>****<a\r\nhref=\"https://blog.csdn.net/qq_30361651/article/details/107801468\">有向图中的最小平均权值回路</a>****</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">2005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,b,d;</span><br><span class=\"line\"><span class=\"type\">double</span> a,c,ans;</span><br><span class=\"line\"><span class=\"type\">double</span> dp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">edge</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    <span class=\"type\">double</span> w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">vector&lt;edge&gt; edges;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\">        edges.<span class=\"built_in\">push_back</span>(&#123;b,d,<span class=\"built_in\">log</span>(a/c)&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [u,v,w] : edges) &#123;</span><br><span class=\"line\">            dp[i][v] = <span class=\"built_in\">min</span>(dp[i][v],dp[i<span class=\"number\">-1</span>][u]+w);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=<span class=\"number\">1</span>;v&lt;=n;v++)&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> t = -INFINITY;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;n;k++)&#123;</span><br><span class=\"line\">            t = <span class=\"built_in\">max</span>(t,(dp[n][v]-dp[k][v])/(n-k));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">min</span>(t,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf\\n&quot;</span>,<span class=\"built_in\">exp</span>(ans));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-link-with-monotonic-subsequence\">G-Link with Monotonic\r\nSubsequence</h1>\r\n<p>来源: 牛客多校训练营2 算法: 构造 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/G 补完: Yes 完成时间: August\r\n2, 2022</p>\r\n<h2 id=\"题意概括\">题意概括</h2>\r\n<p>给定一个整数n，由整数1~n任意排列组成一个序列p</p>\r\n<p><span class=\"math inline\">\\(p的价值=\\max(lis(p),lds(p))\\)</span></p>\r\n<p>lis(p)是p的最长递增子序列长度</p>\r\n<p>lds（p)是p的最长递减子序列长度</p>\r\n<p><strong>求所有排列中价值最小的序列（多个只需输出其中一个即可）</strong></p>\r\n<p>即：构造出一个由整数1~n组成的序列，使得其\r\n最长递增子序列的长度和最长递减子序列的长度\r\n的最大值最小，输出该序列。</p>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>理解题意后采用逆向思维，想办法怎么破坏子序列的递增和递减性</p>\r\n<p>首先想到，将整个序列分成两部分，使得两段的递减段无法连起来，例如n=8时，4321\r\n8765，开心的交了一发，WA了。。。</p>\r\n<p>再想想，举个大一点的数，n=9时，按上述方式构造应该是：54321\r\n9876，仔细想想。。好像可以分成三段：321 654 987，这样的价值就变成了3</p>\r\n<p>如果是n=10呢？就只能分成4段了：4321 8765 109</p>\r\n<p>总结归纳一下就是：一个序列的价值应该为<span\r\nclass=\"math inline\">\\([\\sqrt{n} ]\\)</span>。</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = (<span class=\"type\">int</span>)<span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a*a!=n)a++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=a;j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;a;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j*a-i&lt;=n)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,j*a-i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"h-take-the-elevator\">H-Take the Elevator</h1>\r\n<p>来源: 牛客多校训练营2 算法: 前缀和, 离散化 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/H 补完: Yes 完成时间: July 29,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>高<span class=\"math inline\">\\(k\\)</span>层的楼用容量为<span\r\nclass=\"math inline\">\\(m\\)</span>的电梯运<span\r\nclass=\"math inline\">\\(n\\)</span>人从<span\r\nclass=\"math inline\">\\(a_i\\)</span>层去<span\r\nclass=\"math inline\">\\(b_i\\)</span>层. 求电梯最快下班时间.</p>\r\n<p>有人上楼有人下楼, 电梯在从下往上运人和从上往下运人之间不冲突.</p>\r\n<p>设有<span class=\"math inline\">\\(up(i)\\)</span>人需要从第<span\r\nclass=\"math inline\">\\(i\\)</span>层到第<span\r\nclass=\"math inline\">\\(i+1\\)</span>层, 有<span\r\nclass=\"math inline\">\\(dn(i)\\)</span>人需要从第<span\r\nclass=\"math inline\">\\(i+1\\)</span>层到第<span\r\nclass=\"math inline\">\\(1\\)</span>层,</p>\r\n<p>则电梯在<span class=\"math inline\">\\(i\\)</span>到<span\r\nclass=\"math inline\">\\(i+1\\)</span>层之间至少需要从下往上运行<span\r\nclass=\"math inline\">\\(\\lceil \\frac{up(i)}{m} \\rceil\\)</span>次,\r\n至少需要从上往下运行<span class=\"math inline\">\\(\\lceil \\frac{dn(i)}{m}\r\n\\rceil\\)</span>次,</p>\r\n<p>电梯每次工作都对应一次上升和下降, 则在在<span\r\nclass=\"math inline\">\\(i\\)</span>到<span\r\nclass=\"math inline\">\\(i+1\\)</span>层之间至少需要运行<span\r\nclass=\"math inline\">\\(\\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil\r\n\\frac{dn(i)}{m} \\rceil)\\)</span>个回合, 即为至少要到达<span\r\nclass=\"math inline\">\\(i+1\\)</span>层的回合数, 记为</p>\r\n<p><span class=\"math display\">\\[\r\nneed[i] = \\max(\\lceil \\frac{up(i)}{m} \\rceil,\\lceil \\frac{dn(i)}{m}\r\n\\rceil)\r\n\\]</span></p>\r\n<p>电梯每次工作都要一次性升到此次任务最高点然后返回第一层,\r\n即在满足高层需求时, 低层需求也会被顺带满足, 故优先考需高层任务.\r\n若高层的任务更多, 低层没有任务却仍会被经过,\r\n因而低层的实际运行次数会被高层的运行次数覆盖, 记实际在<span\r\nclass=\"math inline\">\\(i\\)</span>到<span\r\nclass=\"math inline\">\\(i+1\\)</span>层之间运行的回合数为</p>\r\n<p><span class=\"math display\">\\[\r\ncnt[i] = \\max_{j≥i}\\{need[j]\\}\r\n\\]</span></p>\r\n<p>统计所有楼层间的运行时间即为最终答案, 每个回合含上下楼两个操作,\r\n每个操作花费<span class=\"math inline\">\\(1\\)</span>时间</p>\r\n<p><span class=\"math display\">\\[\r\nans=2*\\sum_{i=2}^k cnt[i]\r\n\\]</span></p>\r\n<p>按人流方向差分前缀和处理, 上下累加方向相反可反向差分,\r\n然后从高层开始累计.</p>\r\n<p>本题<span class=\"math inline\">\\(k\\)</span>比较大, 需要离散化处理 ##\r\n代码</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">200005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k,sum;</span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">2</span>*MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> a[MAXN],b[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> up[<span class=\"number\">2</span>*MAXN],dn[<span class=\"number\">2</span>*MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[<span class=\"number\">2</span>*MAXN];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class=\"line\">        c[sum++] = a[i];</span><br><span class=\"line\">        c[sum++] = b[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(c,c+sum);</span><br><span class=\"line\">    sum = <span class=\"built_in\">unique</span>(c,c+sum) - c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">lower_bound</span>(c,c+sum,a[i]) - c;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">lower_bound</span>(c,c+sum,b[i]) - c;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&lt;r)&#123;</span><br><span class=\"line\">            up[l<span class=\"number\">+1</span>]++;</span><br><span class=\"line\">            up[r<span class=\"number\">+1</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            dn[r<span class=\"number\">+1</span>]++;</span><br><span class=\"line\">            dn[l<span class=\"number\">+1</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i&lt;sum;i++)&#123;</span><br><span class=\"line\">        up[i]+=up[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        dn[i]+=dn[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> need = <span class=\"built_in\">max</span>((up[i]+m<span class=\"number\">-1</span>)/m,(dn[i]+m<span class=\"number\">-1</span>)/m);</span><br><span class=\"line\">        cnt[need] = <span class=\"built_in\">max</span>(cnt[need],c[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">        cnt[i] = <span class=\"built_in\">max</span>(cnt[i<span class=\"number\">+1</span>],cnt[i]);</span><br><span class=\"line\">        ans+=cnt[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans*<span class=\"number\">2</span>&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"i-let-fat-tension\">I-let fat tension</h1>\r\n<p>来源: 牛客多校训练营2 算法: 向量, 矩阵乘法 补完: Yes 完成时间: August\r\n3, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>给<span class=\"math inline\">\\(n\\)</span>个练功的大师, 每个大师有<span\r\nclass=\"math inline\">\\(k\\)</span>种属性值和<span\r\nclass=\"math inline\">\\(d\\)</span>种技能等级, 定义为</p>\r\n<p><span class=\"math display\">\\[\r\nX_i\\in \\mathbb R^k, Y_i\\in \\mathbb R^d\r\n\\]</span></p>\r\n<p>大师相互学习, 技能等级得到提升, 其中第<span\r\nclass=\"math inline\">\\(i\\)</span>个大师向第<span\r\nclass=\"math inline\">\\(j\\)</span>个大师学习第<span\r\nclass=\"math inline\">\\(o\\)</span>个技能会有:</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{i-j}=\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\r\n\\]</span></p>\r\n<p>大师同时向所有大师学习,最终有</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{X_i\\cdot X_j}{|X_i||X_j|} y_{j,o}\r\n\\]</span></p>\r\n<p>对于求向量点乘和向量模有</p>\r\n<p><span class=\"math display\">\\[\r\nA\\cdot B=\\sum_{i=1}^La_ib_i\\\\\r\n|A|=\\sqrt{\\sum_{i=1}^La_i^2}\r\n\\]</span></p>\r\n<p>代入有</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{j=1}^n\\frac{\\sum_{p=1}^kx_{i,p}x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}\\sqrt{\\sum_{p=1}^kx_{j,p}^2}}\r\ny_{j,o}\r\n\\]</span></p>\r\n<p>改变求和顺序可以减少复杂度</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{p=1}^k\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}}\r\n\\sum_{j=1}^n\\frac{x_{j,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}} y_{j,o}\r\n\\]</span></p>\r\n<p>大师的属性可以预处理</p>\r\n<p><span class=\"math display\">\\[\r\nx_{i,p}&#39;=\\frac{x_{i,p}}{\\sqrt{\\sum_{p=1}^kx_{i,p}^2}}\r\n\\]</span></p>\r\n<p>但是直接记录<span\r\nclass=\"math inline\">\\(x_{i,p}&#39;\\)</span>会出问题, 记录分母即可</p>\r\n<p>最后</p>\r\n<p><span class=\"math display\">\\[\r\ny_{i,o}^{new}=\\sum_{p=1}^kx_{i,p}&#39; \\sum_{j=1}^nx_{j,p}&#39;y_{j,o}\r\n\\]</span></p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">10005</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXM = <span class=\"number\">55</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> x[MAXN][MAXM],y[MAXN][MAXM],xx[MAXN],op[MAXN][MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,k,d;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;d;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;x[i][p];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> o = <span class=\"number\">1</span>; o &lt;= d; o++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;y[i][o];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">            xx[i] += x[i][p]*x[i][p];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        xx[i] = <span class=\"built_in\">sqrt</span>(xx[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> o = <span class=\"number\">1</span>; o &lt;= d; o++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                op[o][p] += x[j][p]*y[j][o]/xx[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> o = <span class=\"number\">1</span>; o &lt;= d; o++)&#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= k; p++)&#123;</span><br><span class=\"line\">                ans += x[i][p]*op[o][p]/xx[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lf &quot;</span>,ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-link-with-arithmetic-progression\">J-Link with Arithmetic\r\nProgression</h1>\r\n<p>来源: 牛客多校训练营2 算法: 数论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/J 补完: Yes 完成时间: July 31,\r\n2022</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>一元线性回归,套公式即可</p>\r\n<p><span class=\"math display\">\\[\r\nY=kx+a\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nk=\\frac{\\sum(x_i-\\bar x)(y_i-\\bar y)}{\\sum(x_i-\\bar x)^2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\na=\\bar y - k\\bar x\r\n\\]</span></p>\r\n<h2 id=\"代码-3\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">double</span> xbar,ybar,x[<span class=\"number\">300005</span>],y[<span class=\"number\">300005</span>],k,k1,k2,a,ans,t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    xbar=ybar=<span class=\"number\">0</span>;</span><br><span class=\"line\">    k1=k2=<span class=\"number\">0</span>;</span><br><span class=\"line\">    ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        x[i]=(<span class=\"type\">long</span> <span class=\"type\">double</span>)i;</span><br><span class=\"line\">        xbar+=x[i];</span><br><span class=\"line\">        cin&gt;&gt;y[i];</span><br><span class=\"line\">        ybar+=y[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    xbar/=(<span class=\"type\">long</span> <span class=\"type\">double</span>)n;</span><br><span class=\"line\">    ybar/=(<span class=\"type\">long</span> <span class=\"type\">double</span>)n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        k1+=(i-xbar)*(y[i]-ybar);</span><br><span class=\"line\">        k2+=(i-xbar)*(i-xbar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k=k1/k2;</span><br><span class=\"line\">    a=ybar-k*xbar;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        t=(y[i]-(a+k*x[i]));</span><br><span class=\"line\">        ans+=t*t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15llf\\n&quot;</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"k-link-with-bracket-sequence-i\">K-Link with Bracket Sequence\r\nI</h1>\r\n<p>来源: 牛客多校训练营2 算法: 动态规划 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/K 补完: Yes 完成时间: July 26,\r\n2022</p>\r\n<h2 id=\"题解-4\">题解</h2>\r\n<p>从子序列构造原序列, 求可满足的原序列数量.</p>\r\n<p>考虑<span class=\"math inline\">\\(dp[i][j]\\)</span>为以子序列的前<span\r\nclass=\"math inline\">\\(j\\)</span>个字符为子序列能构造出的长度为<span\r\nclass=\"math inline\">\\(i\\)</span>的原序列数量.</p>\r\n<p>或以长度为<span\r\nclass=\"math inline\">\\(i\\)</span>的原序列最多可以提取出的以子序列的前<span\r\nclass=\"math inline\">\\(j\\)</span>个字符为子序列的数量.</p>\r\n<p>对于子序列的第<span class=\"math inline\">\\(j+1\\)</span>个字符,\r\n无法在[原序列的被第<span\r\nclass=\"math inline\">\\(j\\)</span>个字符匹配的字符之后、第<span\r\nclass=\"math inline\">\\(i\\)</span>个字符之前]找到.</p>\r\n<p>本题中子序列为可能合法的括号序列, 原序列为合法的括号序列.</p>\r\n<p>在括号序列中, 为使原序列合法, 每个左括号都要有与其匹配的右括号.</p>\r\n<p>增设一维<span class=\"math inline\">\\(dp[i][j][k]\\)</span>, 其中<span\r\nclass=\"math inline\">\\(k\\)</span>表示原序列中未得到匹配的左括号数量或表示<span\r\nclass=\"math inline\">\\(i\\)</span>个字符之后还需要<span\r\nclass=\"math inline\">\\(k\\)</span>个右括号使原序列合法, 仅当<span\r\nclass=\"math inline\">\\(k==0\\)</span>时原序列为合法括号序列.</p>\r\n<ul>\r\n<li>对<span class=\"math inline\">\\(dp[i][j][k]\\)</span>, 若不为合法序列,\r\n让我们继续构造原序列:\r\n<ul>\r\n<li><p>设原序列的第<span\r\nclass=\"math inline\">\\(i+1\\)</span>个字符为左括号,\r\n则未匹配的左括号数量增多, 此时</p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符为左括号则恰好得到对应,\r\n即两序列长度都得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][j+1][k+1] += dp[i][j][k]\r\n  \\]</span></p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符非左括号则无法得到对应,\r\n仅原序列的长度得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][~~~j~~~][k+1] += dp[i][j][k]\r\n  \\]</span></p></li>\r\n<li><p>设原序列的第<span\r\nclass=\"math inline\">\\(i+1\\)</span>个字符为右括号,\r\n则未匹配的左括号数量减少, 此时</p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符为右括号则恰好得到对应,\r\n即两序列长度都得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][j+1][k-1] += dp[i][j][k]\r\n  \\]</span></p>\r\n<p>若子序列的第<span\r\nclass=\"math inline\">\\(j+1\\)</span>个字符非右括号则无法得到对应,\r\n仅原序列的长度得到增加, 有</p>\r\n<p><span class=\"math display\">\\[\r\n  dp[i+1][~~~j~~~][k-1] += dp[i][j][k]\r\n  \\]</span></p></li>\r\n</ul></li>\r\n</ul>\r\n<p>初始情况, 有空子序列构造空原序列, 为<span\r\nclass=\"math inline\">\\(1\\)</span>种可能</p>\r\n<p><span class=\"math display\">\\[\r\ndp[0][0][0]=1\r\n\\]</span></p>\r\n<p>最终答案为</p>\r\n<p><span class=\"math display\">\\[\r\ndp[m][n][0]\r\n\\]</span></p>\r\n<p>计算过程中子序列长度不会超过原序列长度故有<span\r\nclass=\"math inline\">\\(j&lt;=i\\)</span></p>\r\n<p>同时待匹配左括号数量不会超过原序列长度故有<span\r\nclass=\"math inline\">\\(k&lt;=i\\)</span></p>\r\n<p>为防止越界,与<span class=\"math inline\">\\(k\\)</span>相关的指针<span\r\nclass=\"math inline\">\\(+1\\)</span>处理</p>\r\n<h2 id=\"代码-4\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> P = <span class=\"number\">1e9</span><span class=\"number\">+7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">205</span>][<span class=\"number\">205</span>][<span class=\"number\">205</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\">string a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    a = (a+b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,&amp;a[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(dp));</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span><span class=\"number\">+1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span><span class=\"number\">+1</span>;k&lt;=i<span class=\"number\">+1</span>;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[j<span class=\"number\">+1</span>]==<span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][j<span class=\"number\">+1</span>][k<span class=\"number\">+1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][ j ][k<span class=\"number\">+1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[j<span class=\"number\">+1</span>]==<span class=\"string\">&#x27;)&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][j<span class=\"number\">+1</span>][k<span class=\"number\">-1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">add</span>(dp[i<span class=\"number\">+1</span>][ j ][k<span class=\"number\">-1</span>],dp[i][j][k]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,dp[m][n][<span class=\"number\">0</span><span class=\"number\">+1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"l-link-with-level-editor-i\">L-Link with Level Editor I</h1>\r\n<p>来源: 牛客多校训练营2 算法: 动态规划 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33187/L 补完: Yes 完成时间: July 27,\r\n2022</p>\r\n<h2 id=\"题解-5\">题解</h2>\r\n<p>给<span class=\"math inline\">\\(n\\)</span>个世界, 每个世界有含<span\r\nclass=\"math inline\">\\(m\\)</span>个点的有向图,\r\n每个世界可以图上走一步或者不走.</p>\r\n<p>从第一个世界的点<span class=\"math inline\">\\(1\\)</span>出发,\r\n想要走到点<span class=\"math inline\">\\(m\\)</span>, 求最少经过几个世界.\r\n如果走不到就输出<span class=\"math inline\">\\(-1\\)</span>.</p>\r\n<p>要求</p>\r\n<p>事实上整张地图是立体的, 在第<span\r\nclass=\"math inline\">\\(i\\)</span>个世界时,</p>\r\n<p>对每个点<span class=\"math inline\">\\(u_i\\)</span>,\r\n若不走则到达下个世界的这个点, 化为有向边<span\r\nclass=\"math inline\">\\(&lt;u_i,u_{i+1}&gt;\\)</span>,\r\n对由这个点发出的有向边<span\r\nclass=\"math inline\">\\(&lt;u_i,v_i&gt;\\)</span>, 若走一步,\r\n可以化为连向下一个世界的有向边 <span\r\nclass=\"math inline\">\\(&lt;u_{i},v_{i+1}&gt;\\)</span>.</p>\r\n<p>记<span class=\"math inline\">\\(dp[i][j]\\)</span>为到达第<span\r\nclass=\"math inline\">\\(i\\)</span>个世界的第<span\r\nclass=\"math inline\">\\(j\\)</span>个点需要经过的最小步数,\r\n则可通过上述推出到下一个世界的最小步数.</p>\r\n<p>若没有边指向此点, 仅在上一层的此点基础上加一.</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i+1][u_{i+1}]=dp[i][u_{i}]+1\r\n\\]</span></p>\r\n<p>若有边指向此点, 则选步数最小的一点加一</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i+1][v_{i+1}]=\\min_{u\\to v\\in E} \\{ {dp[i][u_i]+1}\\}\r\n\\]</span></p>\r\n<p>我们可以选择任意一个世界作为起点, 故第一个点始终求得<span\r\nclass=\"math inline\">\\(1\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\ndp[i+1][1]=dp[i][1]+1=1\r\n\\]</span></p>\r\n<p>故每次循环都要刷新</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i][1]=0\r\n\\]</span></p>\r\n<p>其他未到达的点设为无穷大表示不能走到</p>\r\n<p>最终答案为</p>\r\n<p><span class=\"math display\">\\[\r\n\\min_{1≤i≤n}\\{dp[i+1][m]\\}\r\n\\]</span></p>\r\n<p>使用滚动数组.</p>\r\n<h2 id=\"代码-5\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,l,ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> u,v;</span><br><span class=\"line\"><span class=\"type\">int</span> dp[<span class=\"number\">2</span>][<span class=\"number\">2005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dp,<span class=\"number\">0x3f3f3f3f</span>,<span class=\"built_in\">sizeof</span>(dp));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;l;</span><br><span class=\"line\">        dp[i%<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">0x3f3f3f3f</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> u=<span class=\"number\">1</span>;u&lt;=m;u++)&#123;</span><br><span class=\"line\">            dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][u] = dp[i%<span class=\"number\">2</span>][u]<span class=\"number\">+1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=l;j++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">            dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][v] = <span class=\"built_in\">min</span>(dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][v],dp[i%<span class=\"number\">2</span>][u]<span class=\"number\">+1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">min</span>(ans,dp[(i<span class=\"number\">+1</span>)%<span class=\"number\">2</span>][m]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans==<span class=\"number\">0x3f3f3f3f</span>)cout&lt;&lt;<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营01","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# A-Villages: Landlines\n\n来源: 牛客多校训练营1\n算法: 区间合并\n题目链接: https://ac.nowcoder.com/acm/contest/33186/A\n补完: Yes\n完成时间: August 19, 2022\n\n## 题解\n\n本题求各个区间之间的空隙, 第五场F题同样使用到了这种操作, 可以抽象化保存一下. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n// 区间\nstruct Interval{\n    int start;\n    int finish;\n    bool operator<(const Interval other) const {\n        return start<other.start||(start==other.start&&finish>other.finish);\n    }\n};\n\n// 给区间数组, 返回区间间隙\nint rest(vector<Interval> intervals){\n    // 若域边界大于始末区间, 可再加两区间扩充边界\n    // intervals.pop_back({left , left });\n    // intervals.pop_back({right, right});\n    sort(intervals.begin(),intervals.end());\n    int lim = intervals[0].start, temp = 0;\n    for (auto interval : intervals) {\n        if (lim < interval.start) {\n            temp += interval.start - lim;\n        }\n        lim = max(lim, interval.finish);\n    }\n    return temp;\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    vector<Interval> build;\n    int center, radius;\n    for (int i = 1; i <= n; i++) {\n        cin>>center>>radius;\n        build.push_back({center-radius,center+radius});\n    }\n    cout<<rest(build);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# C-Grab the Seat!\n\n来源: 牛客多校训练营1\n算法: 计算几何, 贪心\n补完: Yes\n完成时间: August 25, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33186/C)\n\n## 题意简述\n\n一间教室，有$n*m$个座位，即座位在整数点坐标$（i,j）$上，$i$的取值是$[1,n]$，$j$的取值是$[1,m]$。\n\n$(0,1)−(0,m)$（包含边界）区域是屏幕。\n\n一个能清楚地看见整块屏幕，即到屏幕所有连线构成区域里没有其他人的座位的位置是好座位。\n\n每个人都可能换座位，求每次有人改变座位后的好座位数量。\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled.png)\n\n（黑色粗线是屏幕，绿色点是好座位，红色点是有人的座位。）\n\n## 题目分析\n\n本题很关键的一个思考方向是转换参考对象（是这么说吗）\n\n总之，每个好座位到$（0，1）$和$（0，m）$点连成的**三角区域**里没有被占用的座位，这是很好理解到的。但凭借这个做题会非常复杂。~~所以赛时很不聪明的我跑路了。~~\n\n我们把目光移动到，每次询问会变化的被占用座位。类似好座位的连线连一下，靠近屏幕那侧的三角区域是会挡住视线的区域，**换个方向**看，远离屏幕那侧的自然是能挡住别人的区域。\n\n在每次变动之后处理（或者更新）被占用座位的占用数量，显然比每次遮挡者变化后处理每个位置是否被遮挡容易得多。\n\n那么我们开始考虑处理这个遮挡区域：\n\n一个位置正后方的所有位置会被遮挡是很显然的。我们面向屏幕看。那么在座位**左后方**的位置可能看不见部分的**偏右**的屏幕，**右后方**的位置可能看不见部分**偏左**的屏幕。左右侧后关心的屏幕范围是可以比较**独立**的来看的。\n\n画一画图，大概是这样：三角遮挡区被**正后方**这条线割裂开。可以看出不同区域关心的范围是不一样的。（题目的图，旋转了）\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%201.png)\n\n并且，一个很朴素的认知：在非阶梯教室里，**越前面**的位置能挡住越多人。\n\n这在这里依然适用。在进行了区域分割后更加明显。\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%202.png)\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%203.png)\n\n两个方向上，靠前的点的覆盖区域都能把同一行靠后的点的覆盖区域包含。\n\n而在**不同的行**上，大概表现出了一个**补充**的关系：\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%204.png)\n\n对于从$（0，1）$点连线考虑的情况，处在更上方的点，虽然可能**相对更靠后**，但它的覆盖区域在它那行以上的地方，对原来的点的覆盖区域有一个**补充**的范围。\n\n也就是我们处理这部分答案的时候，**从下向上**跑是可以获得**更新**的。\n\n同理，处理另一个部分的时候，从$（0，m）$连来的点也表现出了类似的性质，不过是下方的点可能对上方的点进行补充，所以这部分答案**从上往下**跑可能获得答案更新。\n\n即，我们在预先存好初始的占有座位的点情况之后，对于每次询问，先更新点，然后再找到每一行**最前面**的点（也就是对于每个y最小的x），每行记录被遮住的点的数量，**从下向上**更新一次$（0，1）$点的答案，**从上向下**更新一次$（0，m）$的答案即可。\n\n每行覆盖了多少点可以使用**斜率**计算获得。但注意，由于屏幕**边界**也要看见，所以**正好**被屏幕边缘连线覆盖的点是**不作数**的，也就是类似**开区间**那个意思。\n\n在处理这个问题的时候，如果使用的是$double$类型计算，可以在答案里扣掉一个很小的数字来进行**补正**后，再转换成int类型。（比如2.000000转int是2，1.9999999转int是1）\n\n本题评测环境里，这个数字的范围在$1e-6$到$1e-10$均可。这里使用了$1e-9$。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nstruct point{\n\tint x;\n\tint y;\n}pt[200005];\nint min_x[200005];\nint ans[200010];\nint main(){\n\tint n,m,k,q;\n\tcin>>n>>m>>k>>q;\n\tfor(int i=1;i<=k;++i) cin>>pt[i].x>>pt[i].y;\n\twhile(q--){\n\t\tint p;\n\t\tcin>>p;\n\t\tcin>>pt[p].x>>pt[p].y;\n\t\tfor(int i=1;i<=m;++i) min_x[i]=n+1;\n\t\tfor(int i=1;i<=k;++i) min_x[pt[i].y]=min(min_x[pt[i].y],pt[i].x); \n\t\tdouble EPS=1e-9;\n\t\tdouble k=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tk=max(k,double(i-1)/min_x[i]); \n\t\t\tif(k==0) ans[i]=min_x[i]-1; \n\t\t\telse ans[i]=(int)(i-1)/k-EPS; \n\t\t} \n\t\tk=0;\n\t\tfor(int i=m;i>=1;i--){\n\t\t\tk=min(k,double(i-m)/min_x[i]); \n            int cmp1=(int)(min_x[i]-1);\n\t\t\tint cmp2=(int)((i-m)/k-EPS); \n\t\t\tif(k==0) ans[i]=min(ans[i],cmp1);\n\t\t\telse ans[i]=min(ans[i],cmp2); \n\t\t}\n\t\tlong long anss=0;\n\t\tfor(int i=0;i<=m;i++)anss+=ans[i];\n\t\tcout<<anss<<'\\n';\n\t}\n}\n```\n# D-Mocha and Railgun\n\n来源: 牛客多校训练营1\n算法: 计算几何\n题目链接: https://ac.nowcoder.com/acm/contest/33186/D\n补完: Yes\n完成时间: July 18, 2022\n\n## 题解\n\n### 找最长弧\n\n![动画.gif](D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%25E5%258A%25A8%25E7%2594%25BB.gif)\n\n发现当发射方向垂直于发射点与圆心的连线时,破坏圆弧最长\n\n### 分类讨论\n\n每个样例给发射点$Q$点坐标$(x,y)$,发射半径$d$\n\n可求得发射点到圆心的圆心距$L=\\sqrt{x^2+y^2}$\n\n[几何画板](https://www.geogebra.org/geometry/eyxavj6u)\n\n### 当原点在发射半径外时\n\n$L>d$\n\n![外.JPG](D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%A4%96.jpg)\n\n在三角形$AOE$上,可求得$\\alpha=\\arcsin(L+d)$\n\n在三角形$IOJ$上,可求得$\\beta=\\arcsin(L-d)$\n\n对所求圆弧有$弧长=r*(\\alpha-\\beta)$\n\n### 当原点在发射半径内时\n\n$L<d$\n\n![内.JPG](D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%86%85.jpg)\n\n在三角形$AOE$上,可求得$\\alpha=\\arcsin(d+L)$\n\n在三角形$IOJ$上,可求得$\\beta=\\arcsin(d-L)$\n\n对所求圆弧有$弧长=r*(\\alpha+\\beta)$\n\n## 代码\n\n由上述逻辑得\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main(){\n    cin>>T;\n    double r,x,y,d,L;\n    while(T--){\n        cin>>r>>x>>y>>d;\n        L=sqrt(x*x+y*y);\n        if(L>d){\n            printf(\"%.8lf\\n\",r*(asin((L+d)/r)-asin((L-d)/r)));\n        }\n        else{\n            printf(\"%.8lf\\n\",r*(asin((d+L)/r)+asin((d-L)/r)));\n        }\n    }\n    return 0;\n}\n```\n\n然而其实有$\\arcsin(-x)=-\\arcsin(x)$,故可以化简\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main(){\n    cin>>T;\n    double r,x,y,d,L;\n    while(T--){\n        cin>>r>>x>>y>>d;\n        L=sqrt(x*x+y*y);\n        printf(\"%.8lf\\n\",r*(asin((L+d)/r)-asin((L-d)/r)));\n    }\n    return 0;\n}\n```\n# G-Lexicographical Max\n\n来源: 牛客多校训练营1\n算法: 字典序\n题目链接: https://ac.nowcoder.com/acm/contest/33186/G\n补完: Yes\n完成时间: July 28, 2022\n\n## 题意\n\n给定一个整数n， 输出1到这个数字中所有数字字符串中字典序最大值；\n**容易知道：**\n\n字典序排序是先比最高位再比第二位，因此字典序中9比19大，90比9大；\n**因此我们可以：**\n\n求出n的长度len，并判断n的数字组成，若除了个位数都是9，则直接输出n；否则输出len-1个9\n\n## 代码如下\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string a;\n    cin>>a;\n    int len = a.size();\n    int flag=0;\n    for(int i=0;i<len-1;i++){\n        if(a[i]!='9'){\n            flag=1;\n            break;\n        }\n    }\n    if(flag==0)cout<<a;\n    else{\n        for(int i=0;i<len-1;i++)printf(\"9\");\n    }\n    return 0;\n}\n```\n# I-Chiitoitsu\n\n来源: 牛客多校训练营1\n算法: 动态规划, 概率DP\n题目链接: https://ac.nowcoder.com/acm/contest/33186/I\n补完: Yes\n完成时间: July 22, 2022\n\n## 解题\n\n最优策略相当于开了透视,保留的手牌一定是最快凑成对子的,把第二张牌来得晚的丢掉.\n\n所以我们具体手牌是什么不重要,只要知道已经凑齐了几个对子就好了\n\n此时对于保留在手上的待匹配牌,还有三张牌在牌池里.\n\n设牌池还剩$i$张牌,还有$j$张牌需要凑对子,$f[i][j]$为距结束步数\n\n则有摸下一张牌时,可以匹配的概率为$\\frac{3*j}{i}$,不可以匹配的概率为$\\frac{i-3*j}{i}$\n\n因为初始手牌为$13$张,其中有$13-j$张牌是对子,则在游戏结束前$j$只能为奇数\n\n当$j=0$时,\n\n所有牌都得到匹配,游戏结束,距游戏结束还有 $0$回合\n\n$$\n\\begin{align}\nf[i][0]=0\n\\end{align}\n$$\n\n当$j=1$时,\n\n摸完一张牌之后牌池还剩$i-1$张牌,\n\n若匹配则消不匹配的牌,还有$j-1$张待匹配的牌,\n\n若不可以匹配则丢摸到的这张牌,还有$j$张待匹配的牌\n\n$$\n\\begin{align}\nf[i][j]&=1\\\\\n&+\\frac{3*j}{i}*f[i-1][j-1]&匹配\\\\\n&+\\frac{i-3*j}{i}*f[i-1][j]&不匹配\n\\end{align}\n$$\n\n当$j>1$时,\n\n摸完一张牌之后牌池还剩$i-1$张牌,\n\n若匹配则消不匹配的牌同时丢一张不能匹配的牌,还有$j-2$张待匹配的牌,\n\n若不可以匹配则丢摸到的这张牌,还有$j$张待匹配的牌\n\n$$\n\\begin{align}\nf[i][j]&=1\\\\\n&+\\frac{3*j}{i}*f[i-1][j-2]&匹配\\\\\n&+\\frac{i-3*j}{i}*f[i-1][j]&不匹配\n\\end{align}\n$$\n\n跑完之后直接拿数据访问$f[i][j]$即可\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll P = 1e9+7;\nint t=1;\nll f[137][14];\nll qpow(ll x,ll a){\n    ll res=1;\n    while(a){\n        if(a&1)res=res*x%P;\n        x= x*x%P;\n        a>>=1;\n    }\n    return res;\n}\nvoid Init() {\n    for(int j=1;j<=13;j+=2){\n        for(int i=1;i<=136;i++){\n            if(j==1)f[i][j]=(1+(3*j)*qpow(i,P-2)%P*f[i-1][j-1]%P+(i-3*j)*qpow(i,P-2)%P*f[i-1][j]%P)%P;\n            else    f[i][j]=(1+(3*j)*qpow(i,P-2)%P*f[i-1][j-2]%P+(i-3*j)*qpow(i,P-2)%P*f[i-1][j]%P)%P;\n        }\n    }\n}\nvoid solve(){\n    char s[26];\n    scanf(\"%s\",&s);\n    int pp[5][10];\n    for(int i=1;i<5;i++){\n        for(int j=1;j<10;j++){\n            pp[i][j]=0;\n        }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i+=2){\n        switch(s[i+1]){\n        case 'm':pp[1][s[i]-'0']++;break;\n        case 'p':pp[2][s[i]-'0']++;break;\n        case 's':pp[3][s[i]-'0']++;break;\n        case 'z':pp[4][s[i]-'0']++;break;\n        default:break;\n        }\n    }\n    for(int i=1;i<5;i++){\n        for(int j=1;j<10;j++){\n            if(pp[i][j]>1)cnt++;\n        }\n    }\n    printf(\"Case #%d: %lld\\n\",t++,f[123][13-cnt*2]);\n}\nint main(){\n    Init();\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# J-Serval and Essay\n\n来源: 牛客多校训练营1\n算法: set, 启发式合并, 并查集, 数论\n题目链接: https://ac.nowcoder.com/acm/contest/33186/J\n补完: Yes\n完成时间: August 23, 2022\n\n完完全全的补题，题解参考雨巨的讲解\n\n## 题意\n\n- 有一张$n$ 个点$m$条边的无重边无自环的有向图\n- 初始时可以选择一个点染黑，其余均为白点\n- 若某个点所有入边的起点均为黑点，则该点可以被染黑\n- 选择一点染黑使得图中黑点数量最大化\n\n## 解\n\n从图中所有没有访问过的点出发，把所有入度为1的点和它的前面的那一部分合并，合并后要把重复的边去掉。对于可以合成一堆的块来说，只需要把起始点染黑，那么这个整块都会变成黑的，而我们要找的就是经过合并操作之后，哪一整块会最大，然后这块是多大。\n\n### 处理\n\n用set存储集合连出去的边指向的点，再将另一个集合连出去的边放置在set，所形成的新集合继续与其他集合合并。\n\n如果一个点的入度是1，就以此为起点搜索前部分，把前部分和此点所在集合进行合并，把边数小的集合合并到边数大的集合上，在这个过程中入度也要处理。\n## 代码\n```cpp\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nset<int>to[N],from[N];\nint fa[N],sz[N];\nint find(int i)\n{\n\tif(i==fa[i]){\n\t\treturn i;\n\t}\n\telse {\n\t\tfa[i]=find(fa[i]);\n\t\treturn fa[i];\n\t}\n}\n\nvoid _Merge(int x,int y){\n\t//得到这两点的并查集 \n\tx=find(x);\n\ty=find(y);\n\tif(x==y)   //已经在一个集合里了，说明已经被合并过 \n\t\treturn;\n\tif(to[x].size()<to[y].size())  //找指出去少的边来遍历 \n\t\tswap(x,y);\n\tfa[y]=x;  //合并 \n\tsz[x]+=sz[y];  //大小更新 \n\tvector<pair<int,int> >mg; \n\tfor(auto t : to[y]){      // 把y指出去的边都遍历一遍 \n\t\tto[x].insert(t);  //让x指向t \n\t\tfrom[t].erase(y); //消去t从y连过来的边 \n\t\tfrom[t].insert(x);//加上x指向t的边 \n\t\tif(from[t].size()==1){\n\t\t\tmg.push_back(make_pair(t,x));  //可合并 \n\t\t}\n\t} \n\tfor(auto [x,y]:mg){\n\t\t_Merge(x,y);\n\t}\n}\n\nint main(){\n\tint t;\n\tcin>>t;\n\tint p=1;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfa[i]=i;  //并查集的父亲 \n\t\t\tsz[i]=1;  // 表示集合大小的数组 \n\t\t}\n\t\tfor(int i=1;i<=n;i++){  //读入边 \n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j=1;j<=k;j++){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tto[a].insert(i);\n\t\t\t\tfrom[i].insert(a);\n\t\t\t}  //建立双向边 \n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(from[i].size()==1){  //遍历所有size等于1的点 \n\t\t\t\t_Merge(*from[i].begin(),i);   //把它和前部分合并 \n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++){   //找到最大块集合\n\t\t\tans=max(ans,sz[i]);\n\t\t} \n\t\tprintf(\"Case #%d: %d\\n\",p++,ans);\n\t\tfor(int i=1;i<=n;i++){    //清空\n\t\t\tto[i].clear();\n\t\t\tfrom[i].clear();\n\t\t}\n\t}\n\treturn 0; \n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营01.md","raw":"---\ntitle: 2022牛客多校训练营01\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# A-Villages: Landlines\n\n来源: 牛客多校训练营1\n算法: 区间合并\n题目链接: https://ac.nowcoder.com/acm/contest/33186/A\n补完: Yes\n完成时间: August 19, 2022\n\n## 题解\n\n本题求各个区间之间的空隙, 第五场F题同样使用到了这种操作, 可以抽象化保存一下. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n// 区间\nstruct Interval{\n    int start;\n    int finish;\n    bool operator<(const Interval other) const {\n        return start<other.start||(start==other.start&&finish>other.finish);\n    }\n};\n\n// 给区间数组, 返回区间间隙\nint rest(vector<Interval> intervals){\n    // 若域边界大于始末区间, 可再加两区间扩充边界\n    // intervals.pop_back({left , left });\n    // intervals.pop_back({right, right});\n    sort(intervals.begin(),intervals.end());\n    int lim = intervals[0].start, temp = 0;\n    for (auto interval : intervals) {\n        if (lim < interval.start) {\n            temp += interval.start - lim;\n        }\n        lim = max(lim, interval.finish);\n    }\n    return temp;\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    vector<Interval> build;\n    int center, radius;\n    for (int i = 1; i <= n; i++) {\n        cin>>center>>radius;\n        build.push_back({center-radius,center+radius});\n    }\n    cout<<rest(build);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# C-Grab the Seat!\n\n来源: 牛客多校训练营1\n算法: 计算几何, 贪心\n补完: Yes\n完成时间: August 25, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33186/C)\n\n## 题意简述\n\n一间教室，有$n*m$个座位，即座位在整数点坐标$（i,j）$上，$i$的取值是$[1,n]$，$j$的取值是$[1,m]$。\n\n$(0,1)−(0,m)$（包含边界）区域是屏幕。\n\n一个能清楚地看见整块屏幕，即到屏幕所有连线构成区域里没有其他人的座位的位置是好座位。\n\n每个人都可能换座位，求每次有人改变座位后的好座位数量。\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled.png)\n\n（黑色粗线是屏幕，绿色点是好座位，红色点是有人的座位。）\n\n## 题目分析\n\n本题很关键的一个思考方向是转换参考对象（是这么说吗）\n\n总之，每个好座位到$（0，1）$和$（0，m）$点连成的**三角区域**里没有被占用的座位，这是很好理解到的。但凭借这个做题会非常复杂。~~所以赛时很不聪明的我跑路了。~~\n\n我们把目光移动到，每次询问会变化的被占用座位。类似好座位的连线连一下，靠近屏幕那侧的三角区域是会挡住视线的区域，**换个方向**看，远离屏幕那侧的自然是能挡住别人的区域。\n\n在每次变动之后处理（或者更新）被占用座位的占用数量，显然比每次遮挡者变化后处理每个位置是否被遮挡容易得多。\n\n那么我们开始考虑处理这个遮挡区域：\n\n一个位置正后方的所有位置会被遮挡是很显然的。我们面向屏幕看。那么在座位**左后方**的位置可能看不见部分的**偏右**的屏幕，**右后方**的位置可能看不见部分**偏左**的屏幕。左右侧后关心的屏幕范围是可以比较**独立**的来看的。\n\n画一画图，大概是这样：三角遮挡区被**正后方**这条线割裂开。可以看出不同区域关心的范围是不一样的。（题目的图，旋转了）\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%201.png)\n\n并且，一个很朴素的认知：在非阶梯教室里，**越前面**的位置能挡住越多人。\n\n这在这里依然适用。在进行了区域分割后更加明显。\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%202.png)\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%203.png)\n\n两个方向上，靠前的点的覆盖区域都能把同一行靠后的点的覆盖区域包含。\n\n而在**不同的行**上，大概表现出了一个**补充**的关系：\n\n![Untitled](C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%204.png)\n\n对于从$（0，1）$点连线考虑的情况，处在更上方的点，虽然可能**相对更靠后**，但它的覆盖区域在它那行以上的地方，对原来的点的覆盖区域有一个**补充**的范围。\n\n也就是我们处理这部分答案的时候，**从下向上**跑是可以获得**更新**的。\n\n同理，处理另一个部分的时候，从$（0，m）$连来的点也表现出了类似的性质，不过是下方的点可能对上方的点进行补充，所以这部分答案**从上往下**跑可能获得答案更新。\n\n即，我们在预先存好初始的占有座位的点情况之后，对于每次询问，先更新点，然后再找到每一行**最前面**的点（也就是对于每个y最小的x），每行记录被遮住的点的数量，**从下向上**更新一次$（0，1）$点的答案，**从上向下**更新一次$（0，m）$的答案即可。\n\n每行覆盖了多少点可以使用**斜率**计算获得。但注意，由于屏幕**边界**也要看见，所以**正好**被屏幕边缘连线覆盖的点是**不作数**的，也就是类似**开区间**那个意思。\n\n在处理这个问题的时候，如果使用的是$double$类型计算，可以在答案里扣掉一个很小的数字来进行**补正**后，再转换成int类型。（比如2.000000转int是2，1.9999999转int是1）\n\n本题评测环境里，这个数字的范围在$1e-6$到$1e-10$均可。这里使用了$1e-9$。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nstruct point{\n\tint x;\n\tint y;\n}pt[200005];\nint min_x[200005];\nint ans[200010];\nint main(){\n\tint n,m,k,q;\n\tcin>>n>>m>>k>>q;\n\tfor(int i=1;i<=k;++i) cin>>pt[i].x>>pt[i].y;\n\twhile(q--){\n\t\tint p;\n\t\tcin>>p;\n\t\tcin>>pt[p].x>>pt[p].y;\n\t\tfor(int i=1;i<=m;++i) min_x[i]=n+1;\n\t\tfor(int i=1;i<=k;++i) min_x[pt[i].y]=min(min_x[pt[i].y],pt[i].x); \n\t\tdouble EPS=1e-9;\n\t\tdouble k=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tk=max(k,double(i-1)/min_x[i]); \n\t\t\tif(k==0) ans[i]=min_x[i]-1; \n\t\t\telse ans[i]=(int)(i-1)/k-EPS; \n\t\t} \n\t\tk=0;\n\t\tfor(int i=m;i>=1;i--){\n\t\t\tk=min(k,double(i-m)/min_x[i]); \n            int cmp1=(int)(min_x[i]-1);\n\t\t\tint cmp2=(int)((i-m)/k-EPS); \n\t\t\tif(k==0) ans[i]=min(ans[i],cmp1);\n\t\t\telse ans[i]=min(ans[i],cmp2); \n\t\t}\n\t\tlong long anss=0;\n\t\tfor(int i=0;i<=m;i++)anss+=ans[i];\n\t\tcout<<anss<<'\\n';\n\t}\n}\n```\n# D-Mocha and Railgun\n\n来源: 牛客多校训练营1\n算法: 计算几何\n题目链接: https://ac.nowcoder.com/acm/contest/33186/D\n补完: Yes\n完成时间: July 18, 2022\n\n## 题解\n\n### 找最长弧\n\n![动画.gif](D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%25E5%258A%25A8%25E7%2594%25BB.gif)\n\n发现当发射方向垂直于发射点与圆心的连线时,破坏圆弧最长\n\n### 分类讨论\n\n每个样例给发射点$Q$点坐标$(x,y)$,发射半径$d$\n\n可求得发射点到圆心的圆心距$L=\\sqrt{x^2+y^2}$\n\n[几何画板](https://www.geogebra.org/geometry/eyxavj6u)\n\n### 当原点在发射半径外时\n\n$L>d$\n\n![外.JPG](D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%A4%96.jpg)\n\n在三角形$AOE$上,可求得$\\alpha=\\arcsin(L+d)$\n\n在三角形$IOJ$上,可求得$\\beta=\\arcsin(L-d)$\n\n对所求圆弧有$弧长=r*(\\alpha-\\beta)$\n\n### 当原点在发射半径内时\n\n$L<d$\n\n![内.JPG](D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%86%85.jpg)\n\n在三角形$AOE$上,可求得$\\alpha=\\arcsin(d+L)$\n\n在三角形$IOJ$上,可求得$\\beta=\\arcsin(d-L)$\n\n对所求圆弧有$弧长=r*(\\alpha+\\beta)$\n\n## 代码\n\n由上述逻辑得\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main(){\n    cin>>T;\n    double r,x,y,d,L;\n    while(T--){\n        cin>>r>>x>>y>>d;\n        L=sqrt(x*x+y*y);\n        if(L>d){\n            printf(\"%.8lf\\n\",r*(asin((L+d)/r)-asin((L-d)/r)));\n        }\n        else{\n            printf(\"%.8lf\\n\",r*(asin((d+L)/r)+asin((d-L)/r)));\n        }\n    }\n    return 0;\n}\n```\n\n然而其实有$\\arcsin(-x)=-\\arcsin(x)$,故可以化简\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main(){\n    cin>>T;\n    double r,x,y,d,L;\n    while(T--){\n        cin>>r>>x>>y>>d;\n        L=sqrt(x*x+y*y);\n        printf(\"%.8lf\\n\",r*(asin((L+d)/r)-asin((L-d)/r)));\n    }\n    return 0;\n}\n```\n# G-Lexicographical Max\n\n来源: 牛客多校训练营1\n算法: 字典序\n题目链接: https://ac.nowcoder.com/acm/contest/33186/G\n补完: Yes\n完成时间: July 28, 2022\n\n## 题意\n\n给定一个整数n， 输出1到这个数字中所有数字字符串中字典序最大值；\n**容易知道：**\n\n字典序排序是先比最高位再比第二位，因此字典序中9比19大，90比9大；\n**因此我们可以：**\n\n求出n的长度len，并判断n的数字组成，若除了个位数都是9，则直接输出n；否则输出len-1个9\n\n## 代码如下\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string a;\n    cin>>a;\n    int len = a.size();\n    int flag=0;\n    for(int i=0;i<len-1;i++){\n        if(a[i]!='9'){\n            flag=1;\n            break;\n        }\n    }\n    if(flag==0)cout<<a;\n    else{\n        for(int i=0;i<len-1;i++)printf(\"9\");\n    }\n    return 0;\n}\n```\n# I-Chiitoitsu\n\n来源: 牛客多校训练营1\n算法: 动态规划, 概率DP\n题目链接: https://ac.nowcoder.com/acm/contest/33186/I\n补完: Yes\n完成时间: July 22, 2022\n\n## 解题\n\n最优策略相当于开了透视,保留的手牌一定是最快凑成对子的,把第二张牌来得晚的丢掉.\n\n所以我们具体手牌是什么不重要,只要知道已经凑齐了几个对子就好了\n\n此时对于保留在手上的待匹配牌,还有三张牌在牌池里.\n\n设牌池还剩$i$张牌,还有$j$张牌需要凑对子,$f[i][j]$为距结束步数\n\n则有摸下一张牌时,可以匹配的概率为$\\frac{3*j}{i}$,不可以匹配的概率为$\\frac{i-3*j}{i}$\n\n因为初始手牌为$13$张,其中有$13-j$张牌是对子,则在游戏结束前$j$只能为奇数\n\n当$j=0$时,\n\n所有牌都得到匹配,游戏结束,距游戏结束还有 $0$回合\n\n$$\n\\begin{align}\nf[i][0]=0\n\\end{align}\n$$\n\n当$j=1$时,\n\n摸完一张牌之后牌池还剩$i-1$张牌,\n\n若匹配则消不匹配的牌,还有$j-1$张待匹配的牌,\n\n若不可以匹配则丢摸到的这张牌,还有$j$张待匹配的牌\n\n$$\n\\begin{align}\nf[i][j]&=1\\\\\n&+\\frac{3*j}{i}*f[i-1][j-1]&匹配\\\\\n&+\\frac{i-3*j}{i}*f[i-1][j]&不匹配\n\\end{align}\n$$\n\n当$j>1$时,\n\n摸完一张牌之后牌池还剩$i-1$张牌,\n\n若匹配则消不匹配的牌同时丢一张不能匹配的牌,还有$j-2$张待匹配的牌,\n\n若不可以匹配则丢摸到的这张牌,还有$j$张待匹配的牌\n\n$$\n\\begin{align}\nf[i][j]&=1\\\\\n&+\\frac{3*j}{i}*f[i-1][j-2]&匹配\\\\\n&+\\frac{i-3*j}{i}*f[i-1][j]&不匹配\n\\end{align}\n$$\n\n跑完之后直接拿数据访问$f[i][j]$即可\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll P = 1e9+7;\nint t=1;\nll f[137][14];\nll qpow(ll x,ll a){\n    ll res=1;\n    while(a){\n        if(a&1)res=res*x%P;\n        x= x*x%P;\n        a>>=1;\n    }\n    return res;\n}\nvoid Init() {\n    for(int j=1;j<=13;j+=2){\n        for(int i=1;i<=136;i++){\n            if(j==1)f[i][j]=(1+(3*j)*qpow(i,P-2)%P*f[i-1][j-1]%P+(i-3*j)*qpow(i,P-2)%P*f[i-1][j]%P)%P;\n            else    f[i][j]=(1+(3*j)*qpow(i,P-2)%P*f[i-1][j-2]%P+(i-3*j)*qpow(i,P-2)%P*f[i-1][j]%P)%P;\n        }\n    }\n}\nvoid solve(){\n    char s[26];\n    scanf(\"%s\",&s);\n    int pp[5][10];\n    for(int i=1;i<5;i++){\n        for(int j=1;j<10;j++){\n            pp[i][j]=0;\n        }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i+=2){\n        switch(s[i+1]){\n        case 'm':pp[1][s[i]-'0']++;break;\n        case 'p':pp[2][s[i]-'0']++;break;\n        case 's':pp[3][s[i]-'0']++;break;\n        case 'z':pp[4][s[i]-'0']++;break;\n        default:break;\n        }\n    }\n    for(int i=1;i<5;i++){\n        for(int j=1;j<10;j++){\n            if(pp[i][j]>1)cnt++;\n        }\n    }\n    printf(\"Case #%d: %lld\\n\",t++,f[123][13-cnt*2]);\n}\nint main(){\n    Init();\n    int T;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# J-Serval and Essay\n\n来源: 牛客多校训练营1\n算法: set, 启发式合并, 并查集, 数论\n题目链接: https://ac.nowcoder.com/acm/contest/33186/J\n补完: Yes\n完成时间: August 23, 2022\n\n完完全全的补题，题解参考雨巨的讲解\n\n## 题意\n\n- 有一张$n$ 个点$m$条边的无重边无自环的有向图\n- 初始时可以选择一个点染黑，其余均为白点\n- 若某个点所有入边的起点均为黑点，则该点可以被染黑\n- 选择一点染黑使得图中黑点数量最大化\n\n## 解\n\n从图中所有没有访问过的点出发，把所有入度为1的点和它的前面的那一部分合并，合并后要把重复的边去掉。对于可以合成一堆的块来说，只需要把起始点染黑，那么这个整块都会变成黑的，而我们要找的就是经过合并操作之后，哪一整块会最大，然后这块是多大。\n\n### 处理\n\n用set存储集合连出去的边指向的点，再将另一个集合连出去的边放置在set，所形成的新集合继续与其他集合合并。\n\n如果一个点的入度是1，就以此为起点搜索前部分，把前部分和此点所在集合进行合并，把边数小的集合合并到边数大的集合上，在这个过程中入度也要处理。\n## 代码\n```cpp\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nset<int>to[N],from[N];\nint fa[N],sz[N];\nint find(int i)\n{\n\tif(i==fa[i]){\n\t\treturn i;\n\t}\n\telse {\n\t\tfa[i]=find(fa[i]);\n\t\treturn fa[i];\n\t}\n}\n\nvoid _Merge(int x,int y){\n\t//得到这两点的并查集 \n\tx=find(x);\n\ty=find(y);\n\tif(x==y)   //已经在一个集合里了，说明已经被合并过 \n\t\treturn;\n\tif(to[x].size()<to[y].size())  //找指出去少的边来遍历 \n\t\tswap(x,y);\n\tfa[y]=x;  //合并 \n\tsz[x]+=sz[y];  //大小更新 \n\tvector<pair<int,int> >mg; \n\tfor(auto t : to[y]){      // 把y指出去的边都遍历一遍 \n\t\tto[x].insert(t);  //让x指向t \n\t\tfrom[t].erase(y); //消去t从y连过来的边 \n\t\tfrom[t].insert(x);//加上x指向t的边 \n\t\tif(from[t].size()==1){\n\t\t\tmg.push_back(make_pair(t,x));  //可合并 \n\t\t}\n\t} \n\tfor(auto [x,y]:mg){\n\t\t_Merge(x,y);\n\t}\n}\n\nint main(){\n\tint t;\n\tcin>>t;\n\tint p=1;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfa[i]=i;  //并查集的父亲 \n\t\t\tsz[i]=1;  // 表示集合大小的数组 \n\t\t}\n\t\tfor(int i=1;i<=n;i++){  //读入边 \n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j=1;j<=k;j++){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tto[a].insert(i);\n\t\t\t\tfrom[i].insert(a);\n\t\t\t}  //建立双向边 \n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(from[i].size()==1){  //遍历所有size等于1的点 \n\t\t\t\t_Merge(*from[i].begin(),i);   //把它和前部分合并 \n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++){   //找到最大块集合\n\t\t\tans=max(ans,sz[i]);\n\t\t} \n\t\tprintf(\"Case #%d: %d\\n\",p++,ans);\n\t\tfor(int i=1;i<=n;i++){    //清空\n\t\t\tto[i].clear();\n\t\t\tfrom[i].clear();\n\t\t}\n\t}\n\treturn 0; \n}\n```\n","slug":"2022牛客多校训练营01","published":1,"updated":"2023-10-29T06:36:11.237Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexa000bn0umgktde53f","content":"<h1 id=\"a-villages-landlines\">A-Villages: Landlines</h1>\r\n<p>来源: 牛客多校训练营1 算法: 区间合并 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/A 补完: Yes 完成时间: August\r\n19, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>本题求各个区间之间的空隙, 第五场F题同样使用到了这种操作,\r\n可以抽象化保存一下.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 区间</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Interval</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> finish;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Interval other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start&lt;other.start||(start==other.start&amp;&amp;finish&gt;other.finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给区间数组, 返回区间间隙</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rest</span><span class=\"params\">(vector&lt;Interval&gt; intervals)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若域边界大于始末区间, 可再加两区间扩充边界</span></span><br><span class=\"line\">    <span class=\"comment\">// intervals.pop_back(&#123;left , left &#125;);</span></span><br><span class=\"line\">    <span class=\"comment\">// intervals.pop_back(&#123;right, right&#125;);</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(),intervals.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> lim = intervals[<span class=\"number\">0</span>].start, temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> interval : intervals) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lim &lt; interval.start) &#123;</span><br><span class=\"line\">            temp += interval.start - lim;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lim = <span class=\"built_in\">max</span>(lim, interval.finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;Interval&gt; build;</span><br><span class=\"line\">    <span class=\"type\">int</span> center, radius;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;center&gt;&gt;radius;</span><br><span class=\"line\">        build.<span class=\"built_in\">push_back</span>(&#123;center-radius,center+radius&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">rest</span>(build);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"c-grab-the-seat\">C-Grab the Seat!</h1>\r\n<p>来源: 牛客多校训练营1 算法: 计算几何, 贪心 补完: Yes 完成时间: August\r\n25, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33186/C\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>一间教室，有<span\r\nclass=\"math inline\">\\(n*m\\)</span>个座位，即座位在整数点坐标<span\r\nclass=\"math inline\">\\(（i,j）\\)</span>上，<span\r\nclass=\"math inline\">\\(i\\)</span>的取值是<span\r\nclass=\"math inline\">\\([1,n]\\)</span>，<span\r\nclass=\"math inline\">\\(j\\)</span>的取值是<span\r\nclass=\"math inline\">\\([1,m]\\)</span>。</p>\r\n<p><span\r\nclass=\"math inline\">\\((0,1)−(0,m)\\)</span>（包含边界）区域是屏幕。</p>\r\n<p>一个能清楚地看见整块屏幕，即到屏幕所有连线构成区域里没有其他人的座位的位置是好座位。</p>\r\n<p>每个人都可能换座位，求每次有人改变座位后的好座位数量。</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>（黑色粗线是屏幕，绿色点是好座位，红色点是有人的座位。）</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>本题很关键的一个思考方向是转换参考对象（是这么说吗）</p>\r\n<p>总之，每个好座位到<span\r\nclass=\"math inline\">\\(（0，1）\\)</span>和<span\r\nclass=\"math inline\">\\(（0，m）\\)</span>点连成的<strong>三角区域</strong>里没有被占用的座位，这是很好理解到的。但凭借这个做题会非常复杂。<del>所以赛时很不聪明的我跑路了。</del></p>\r\n<p>我们把目光移动到，每次询问会变化的被占用座位。类似好座位的连线连一下，靠近屏幕那侧的三角区域是会挡住视线的区域，<strong>换个方向</strong>看，远离屏幕那侧的自然是能挡住别人的区域。</p>\r\n<p>在每次变动之后处理（或者更新）被占用座位的占用数量，显然比每次遮挡者变化后处理每个位置是否被遮挡容易得多。</p>\r\n<p>那么我们开始考虑处理这个遮挡区域：</p>\r\n<p>一个位置正后方的所有位置会被遮挡是很显然的。我们面向屏幕看。那么在座位<strong>左后方</strong>的位置可能看不见部分的<strong>偏右</strong>的屏幕，<strong>右后方</strong>的位置可能看不见部分<strong>偏左</strong>的屏幕。左右侧后关心的屏幕范围是可以比较<strong>独立</strong>的来看的。</p>\r\n<p>画一画图，大概是这样：三角遮挡区被<strong>正后方</strong>这条线割裂开。可以看出不同区域关心的范围是不一样的。（题目的图，旋转了）</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>并且，一个很朴素的认知：在非阶梯教室里，<strong>越前面</strong>的位置能挡住越多人。</p>\r\n<p>这在这里依然适用。在进行了区域分割后更加明显。</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%202.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%203.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>两个方向上，靠前的点的覆盖区域都能把同一行靠后的点的覆盖区域包含。</p>\r\n<p>而在<strong>不同的行</strong>上，大概表现出了一个<strong>补充</strong>的关系：</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%204.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>对于从<span\r\nclass=\"math inline\">\\(（0，1）\\)</span>点连线考虑的情况，处在更上方的点，虽然可能<strong>相对更靠后</strong>，但它的覆盖区域在它那行以上的地方，对原来的点的覆盖区域有一个<strong>补充</strong>的范围。</p>\r\n<p>也就是我们处理这部分答案的时候，<strong>从下向上</strong>跑是可以获得<strong>更新</strong>的。</p>\r\n<p>同理，处理另一个部分的时候，从<span\r\nclass=\"math inline\">\\(（0，m）\\)</span>连来的点也表现出了类似的性质，不过是下方的点可能对上方的点进行补充，所以这部分答案<strong>从上往下</strong>跑可能获得答案更新。</p>\r\n<p>即，我们在预先存好初始的占有座位的点情况之后，对于每次询问，先更新点，然后再找到每一行<strong>最前面</strong>的点（也就是对于每个y最小的x），每行记录被遮住的点的数量，<strong>从下向上</strong>更新一次<span\r\nclass=\"math inline\">\\(（0，1）\\)</span>点的答案，<strong>从上向下</strong>更新一次<span\r\nclass=\"math inline\">\\(（0，m）\\)</span>的答案即可。</p>\r\n<p>每行覆盖了多少点可以使用<strong>斜率</strong>计算获得。但注意，由于屏幕<strong>边界</strong>也要看见，所以<strong>正好</strong>被屏幕边缘连线覆盖的点是<strong>不作数</strong>的，也就是类似<strong>开区间</strong>那个意思。</p>\r\n<p>在处理这个问题的时候，如果使用的是<span\r\nclass=\"math inline\">\\(double\\)</span>类型计算，可以在答案里扣掉一个很小的数字来进行<strong>补正</strong>后，再转换成int类型。（比如2.000000转int是2，1.9999999转int是1）</p>\r\n<p>本题评测环境里，这个数字的范围在<span\r\nclass=\"math inline\">\\(1e-6\\)</span>到<span\r\nclass=\"math inline\">\\(1e-10\\)</span>均可。这里使用了<span\r\nclass=\"math inline\">\\(1e-9\\)</span>。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">point</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">&#125;pt[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> min_x[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">200010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,m,k,q;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;++i) cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> p;</span><br><span class=\"line\">\t\tcin&gt;&gt;p;</span><br><span class=\"line\">\t\tcin&gt;&gt;pt[p].x&gt;&gt;pt[p].y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i) min_x[i]=n<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;++i) min_x[pt[i].y]=<span class=\"built_in\">min</span>(min_x[pt[i].y],pt[i].x); </span><br><span class=\"line\">\t\t<span class=\"type\">double</span> EPS=<span class=\"number\">1e-9</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">double</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\tk=<span class=\"built_in\">max</span>(k,<span class=\"built_in\">double</span>(i<span class=\"number\">-1</span>)/min_x[i]); </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>) ans[i]=min_x[i]<span class=\"number\">-1</span>; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ans[i]=(<span class=\"type\">int</span>)(i<span class=\"number\">-1</span>)/k-EPS; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\tk=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\tk=<span class=\"built_in\">min</span>(k,<span class=\"built_in\">double</span>(i-m)/min_x[i]); </span><br><span class=\"line\">            <span class=\"type\">int</span> cmp1=(<span class=\"type\">int</span>)(min_x[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cmp2=(<span class=\"type\">int</span>)((i-m)/k-EPS); </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>) ans[i]=<span class=\"built_in\">min</span>(ans[i],cmp1);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ans[i]=<span class=\"built_in\">min</span>(ans[i],cmp2); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> anss=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++)anss+=ans[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;anss&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"d-mocha-and-railgun\">D-Mocha and Railgun</h1>\r\n<p>来源: 牛客多校训练营1 算法: 计算几何 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/D 补完: Yes 完成时间: July 18,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<h3 id=\"找最长弧\">找最长弧</h3>\r\n<figure>\r\n<img\r\nsrc=\"D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%25E5%258A%25A8%25E7%2594%25BB.gif\"\r\nalt=\"动画.gif\" />\r\n<figcaption aria-hidden=\"true\">动画.gif</figcaption>\r\n</figure>\r\n<p>发现当发射方向垂直于发射点与圆心的连线时,破坏圆弧最长</p>\r\n<h3 id=\"分类讨论\">分类讨论</h3>\r\n<p>每个样例给发射点<span class=\"math inline\">\\(Q\\)</span>点坐标<span\r\nclass=\"math inline\">\\((x,y)\\)</span>,发射半径<span\r\nclass=\"math inline\">\\(d\\)</span></p>\r\n<p>可求得发射点到圆心的圆心距<span\r\nclass=\"math inline\">\\(L=\\sqrt{x^2+y^2}\\)</span></p>\r\n<p><a href=\"https://www.geogebra.org/geometry/eyxavj6u\">几何画板</a></p>\r\n<h3 id=\"当原点在发射半径外时\">当原点在发射半径外时</h3>\r\n<p><span class=\"math inline\">\\(L&gt;d\\)</span></p>\r\n<figure>\r\n<img\r\nsrc=\"D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%A4%96.jpg\"\r\nalt=\"外.JPG\" />\r\n<figcaption aria-hidden=\"true\">外.JPG</figcaption>\r\n</figure>\r\n<p>在三角形<span class=\"math inline\">\\(AOE\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\alpha=\\arcsin(L+d)\\)</span></p>\r\n<p>在三角形<span class=\"math inline\">\\(IOJ\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\beta=\\arcsin(L-d)\\)</span></p>\r\n<p>对所求圆弧有<span\r\nclass=\"math inline\">\\(弧长=r*(\\alpha-\\beta)\\)</span></p>\r\n<h3 id=\"当原点在发射半径内时\">当原点在发射半径内时</h3>\r\n<p><span class=\"math inline\">\\(L&lt;d\\)</span></p>\r\n<figure>\r\n<img\r\nsrc=\"D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%86%85.jpg\"\r\nalt=\"内.JPG\" />\r\n<figcaption aria-hidden=\"true\">内.JPG</figcaption>\r\n</figure>\r\n<p>在三角形<span class=\"math inline\">\\(AOE\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\alpha=\\arcsin(d+L)\\)</span></p>\r\n<p>在三角形<span class=\"math inline\">\\(IOJ\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\beta=\\arcsin(d-L)\\)</span></p>\r\n<p>对所求圆弧有<span\r\nclass=\"math inline\">\\(弧长=r*(\\alpha+\\beta)\\)</span></p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<p>由上述逻辑得</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"type\">double</span> r,x,y,d,L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;d;</span><br><span class=\"line\">        L=<span class=\"built_in\">sqrt</span>(x*x+y*y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L&gt;d)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8lf\\n&quot;</span>,r*(<span class=\"built_in\">asin</span>((L+d)/r)-<span class=\"built_in\">asin</span>((L-d)/r)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8lf\\n&quot;</span>,r*(<span class=\"built_in\">asin</span>((d+L)/r)+<span class=\"built_in\">asin</span>((d-L)/r)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然而其实有<span\r\nclass=\"math inline\">\\(\\arcsin(-x)=-\\arcsin(x)\\)</span>,故可以化简</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"type\">double</span> r,x,y,d,L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;d;</span><br><span class=\"line\">        L=<span class=\"built_in\">sqrt</span>(x*x+y*y);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8lf\\n&quot;</span>,r*(<span class=\"built_in\">asin</span>((L+d)/r)-<span class=\"built_in\">asin</span>((L-d)/r)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-lexicographical-max\">G-Lexicographical Max</h1>\r\n<p>来源: 牛客多校训练营1 算法: 字典序 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/G 补完: Yes 完成时间: July 28,\r\n2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>给定一个整数n， 输出1到这个数字中所有数字字符串中字典序最大值；\r\n<strong>容易知道：</strong></p>\r\n<p>字典序排序是先比最高位再比第二位，因此字典序中9比19大，90比9大；\r\n<strong>因此我们可以：</strong></p>\r\n<p>求出n的长度len，并判断n的数字组成，若除了个位数都是9，则直接输出n；否则输出len-1个9</p>\r\n<h2 id=\"代码如下\">代码如下</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]!=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">            flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)cout&lt;&lt;a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len<span class=\"number\">-1</span>;i++)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;9&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"i-chiitoitsu\">I-Chiitoitsu</h1>\r\n<p>来源: 牛客多校训练营1 算法: 动态规划, 概率DP 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/I 补完: Yes 完成时间: July 22,\r\n2022</p>\r\n<h2 id=\"解题\">解题</h2>\r\n<p>最优策略相当于开了透视,保留的手牌一定是最快凑成对子的,把第二张牌来得晚的丢掉.</p>\r\n<p>所以我们具体手牌是什么不重要,只要知道已经凑齐了几个对子就好了</p>\r\n<p>此时对于保留在手上的待匹配牌,还有三张牌在牌池里.</p>\r\n<p>设牌池还剩<span class=\"math inline\">\\(i\\)</span>张牌,还有<span\r\nclass=\"math inline\">\\(j\\)</span>张牌需要凑对子,<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span>为距结束步数</p>\r\n<p>则有摸下一张牌时,可以匹配的概率为<span\r\nclass=\"math inline\">\\(\\frac{3*j}{i}\\)</span>,不可以匹配的概率为<span\r\nclass=\"math inline\">\\(\\frac{i-3*j}{i}\\)</span></p>\r\n<p>因为初始手牌为<span class=\"math inline\">\\(13\\)</span>张,其中有<span\r\nclass=\"math inline\">\\(13-j\\)</span>张牌是对子,则在游戏结束前<span\r\nclass=\"math inline\">\\(j\\)</span>只能为奇数</p>\r\n<p>当<span class=\"math inline\">\\(j=0\\)</span>时,</p>\r\n<p>所有牌都得到匹配,游戏结束,距游戏结束还有 <span\r\nclass=\"math inline\">\\(0\\)</span>回合</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nf[i][0]=0\r\n\\end{align}\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(j=1\\)</span>时,</p>\r\n<p>摸完一张牌之后牌池还剩<span\r\nclass=\"math inline\">\\(i-1\\)</span>张牌,</p>\r\n<p>若匹配则消不匹配的牌,还有<span\r\nclass=\"math inline\">\\(j-1\\)</span>张待匹配的牌,</p>\r\n<p>若不可以匹配则丢摸到的这张牌,还有<span\r\nclass=\"math inline\">\\(j\\)</span>张待匹配的牌</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nf[i][j]&amp;=1\\\\\r\n&amp;+\\frac{3*j}{i}*f[i-1][j-1]&amp;匹配\\\\\r\n&amp;+\\frac{i-3*j}{i}*f[i-1][j]&amp;不匹配\r\n\\end{align}\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(j&gt;1\\)</span>时,</p>\r\n<p>摸完一张牌之后牌池还剩<span\r\nclass=\"math inline\">\\(i-1\\)</span>张牌,</p>\r\n<p>若匹配则消不匹配的牌同时丢一张不能匹配的牌,还有<span\r\nclass=\"math inline\">\\(j-2\\)</span>张待匹配的牌,</p>\r\n<p>若不可以匹配则丢摸到的这张牌,还有<span\r\nclass=\"math inline\">\\(j\\)</span>张待匹配的牌</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nf[i][j]&amp;=1\\\\\r\n&amp;+\\frac{3*j}{i}*f[i-1][j-2]&amp;匹配\\\\\r\n&amp;+\\frac{i-3*j}{i}*f[i-1][j]&amp;不匹配\r\n\\end{align}\r\n\\]</span></p>\r\n<p>跑完之后直接拿数据访问<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span>即可</p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">1e9</span><span class=\"number\">+7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t=<span class=\"number\">1</span>;</span><br><span class=\"line\">ll f[<span class=\"number\">137</span>][<span class=\"number\">14</span>];</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll x,ll a)</span></span>&#123;</span><br><span class=\"line\">    ll res=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a&amp;<span class=\"number\">1</span>)res=res*x%P;</span><br><span class=\"line\">        x= x*x%P;</span><br><span class=\"line\">        a&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">13</span>;j+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">136</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j==<span class=\"number\">1</span>)f[i][j]=(<span class=\"number\">1</span>+(<span class=\"number\">3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]%P+(i<span class=\"number\">-3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j]%P)%P;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>    f[i][j]=(<span class=\"number\">1</span>+(<span class=\"number\">3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j<span class=\"number\">-2</span>]%P+(i<span class=\"number\">-3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j]%P)%P;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> s[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,&amp;s);</span><br><span class=\"line\">    <span class=\"type\">int</span> pp[<span class=\"number\">5</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">            pp[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(s[i<span class=\"number\">+1</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;m&#x27;</span>:pp[<span class=\"number\">1</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;p&#x27;</span>:pp[<span class=\"number\">2</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;s&#x27;</span>:pp[<span class=\"number\">3</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;z&#x27;</span>:pp[<span class=\"number\">4</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pp[i][j]&gt;<span class=\"number\">1</span>)cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Case #%d: %lld\\n&quot;</span>,t++,f[<span class=\"number\">123</span>][<span class=\"number\">13</span>-cnt*<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Init</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-serval-and-essay\">J-Serval and Essay</h1>\r\n<p>来源: 牛客多校训练营1 算法: set, 启发式合并, 并查集, 数论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/J 补完: Yes 完成时间: August\r\n23, 2022</p>\r\n<p>完完全全的补题，题解参考雨巨的讲解</p>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<ul>\r\n<li>有一张<span class=\"math inline\">\\(n\\)</span> 个点<span\r\nclass=\"math inline\">\\(m\\)</span>条边的无重边无自环的有向图</li>\r\n<li>初始时可以选择一个点染黑，其余均为白点</li>\r\n<li>若某个点所有入边的起点均为黑点，则该点可以被染黑</li>\r\n<li>选择一点染黑使得图中黑点数量最大化</li>\r\n</ul>\r\n<h2 id=\"解\">解</h2>\r\n<p>从图中所有没有访问过的点出发，把所有入度为1的点和它的前面的那一部分合并，合并后要把重复的边去掉。对于可以合成一堆的块来说，只需要把起始点染黑，那么这个整块都会变成黑的，而我们要找的就是经过合并操作之后，哪一整块会最大，然后这块是多大。</p>\r\n<h3 id=\"处理\">处理</h3>\r\n<p>用set存储集合连出去的边指向的点，再将另一个集合连出去的边放置在set，所形成的新集合继续与其他集合合并。</p>\r\n<p>如果一个点的入度是1，就以此为起点搜索前部分，把前部分和此点所在集合进行合并，把边数小的集合合并到边数大的集合上，在这个过程中入度也要处理。\r\n## 代码 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e6</span><span class=\"number\">+10</span>;</span><br><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt;to[N],from[N];</span><br><span class=\"line\"><span class=\"type\">int</span> fa[N],sz[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i==fa[i])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfa[i]=<span class=\"built_in\">find</span>(fa[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fa[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _Merge(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//得到这两点的并查集 </span></span><br><span class=\"line\">\tx=<span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">\ty=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==y)   <span class=\"comment\">//已经在一个集合里了，说明已经被合并过 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to[x].<span class=\"built_in\">size</span>()&lt;to[y].<span class=\"built_in\">size</span>())  <span class=\"comment\">//找指出去少的边来遍历 </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\tfa[y]=x;  <span class=\"comment\">//合并 </span></span><br><span class=\"line\">\tsz[x]+=sz[y];  <span class=\"comment\">//大小更新 </span></span><br><span class=\"line\">\tvector&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt;mg; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> t : to[y])&#123;      <span class=\"comment\">// 把y指出去的边都遍历一遍 </span></span><br><span class=\"line\">\t\tto[x].<span class=\"built_in\">insert</span>(t);  <span class=\"comment\">//让x指向t </span></span><br><span class=\"line\">\t\tfrom[t].<span class=\"built_in\">erase</span>(y); <span class=\"comment\">//消去t从y连过来的边 </span></span><br><span class=\"line\">\t\tfrom[t].<span class=\"built_in\">insert</span>(x);<span class=\"comment\">//加上x指向t的边 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(from[t].<span class=\"built_in\">size</span>()==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tmg.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(t,x));  <span class=\"comment\">//可合并 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> [x,y]:mg)&#123;</span><br><span class=\"line\">\t\t_Merge(x,y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tfa[i]=i;  <span class=\"comment\">//并查集的父亲 </span></span><br><span class=\"line\">\t\t\tsz[i]=<span class=\"number\">1</span>;  <span class=\"comment\">// 表示集合大小的数组 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;  <span class=\"comment\">//读入边 </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> k;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;k;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;a;</span><br><span class=\"line\">\t\t\t\tto[a].<span class=\"built_in\">insert</span>(i);</span><br><span class=\"line\">\t\t\t\tfrom[i].<span class=\"built_in\">insert</span>(a);</span><br><span class=\"line\">\t\t\t&#125;  <span class=\"comment\">//建立双向边 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(from[i].<span class=\"built_in\">size</span>()==<span class=\"number\">1</span>)&#123;  <span class=\"comment\">//遍历所有size等于1的点 </span></span><br><span class=\"line\">\t\t\t\t_Merge(*from[i].<span class=\"built_in\">begin</span>(),i);   <span class=\"comment\">//把它和前部分合并 </span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;   <span class=\"comment\">//找到最大块集合</span></span><br><span class=\"line\">\t\t\tans=<span class=\"built_in\">max</span>(ans,sz[i]);</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Case #%d: %d\\n&quot;</span>,p++,ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;    <span class=\"comment\">//清空</span></span><br><span class=\"line\">\t\t\tto[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t\tfrom[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n","excerpt":"","more":"<h1 id=\"a-villages-landlines\">A-Villages: Landlines</h1>\r\n<p>来源: 牛客多校训练营1 算法: 区间合并 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/A 补完: Yes 完成时间: August\r\n19, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>本题求各个区间之间的空隙, 第五场F题同样使用到了这种操作,\r\n可以抽象化保存一下.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 区间</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Interval</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> finish;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Interval other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start&lt;other.start||(start==other.start&amp;&amp;finish&gt;other.finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给区间数组, 返回区间间隙</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rest</span><span class=\"params\">(vector&lt;Interval&gt; intervals)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若域边界大于始末区间, 可再加两区间扩充边界</span></span><br><span class=\"line\">    <span class=\"comment\">// intervals.pop_back(&#123;left , left &#125;);</span></span><br><span class=\"line\">    <span class=\"comment\">// intervals.pop_back(&#123;right, right&#125;);</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(),intervals.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> lim = intervals[<span class=\"number\">0</span>].start, temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> interval : intervals) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lim &lt; interval.start) &#123;</span><br><span class=\"line\">            temp += interval.start - lim;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lim = <span class=\"built_in\">max</span>(lim, interval.finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;Interval&gt; build;</span><br><span class=\"line\">    <span class=\"type\">int</span> center, radius;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;center&gt;&gt;radius;</span><br><span class=\"line\">        build.<span class=\"built_in\">push_back</span>(&#123;center-radius,center+radius&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">rest</span>(build);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"c-grab-the-seat\">C-Grab the Seat!</h1>\r\n<p>来源: 牛客多校训练营1 算法: 计算几何, 贪心 补完: Yes 完成时间: August\r\n25, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33186/C\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>一间教室，有<span\r\nclass=\"math inline\">\\(n*m\\)</span>个座位，即座位在整数点坐标<span\r\nclass=\"math inline\">\\(（i,j）\\)</span>上，<span\r\nclass=\"math inline\">\\(i\\)</span>的取值是<span\r\nclass=\"math inline\">\\([1,n]\\)</span>，<span\r\nclass=\"math inline\">\\(j\\)</span>的取值是<span\r\nclass=\"math inline\">\\([1,m]\\)</span>。</p>\r\n<p><span\r\nclass=\"math inline\">\\((0,1)−(0,m)\\)</span>（包含边界）区域是屏幕。</p>\r\n<p>一个能清楚地看见整块屏幕，即到屏幕所有连线构成区域里没有其他人的座位的位置是好座位。</p>\r\n<p>每个人都可能换座位，求每次有人改变座位后的好座位数量。</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>（黑色粗线是屏幕，绿色点是好座位，红色点是有人的座位。）</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>本题很关键的一个思考方向是转换参考对象（是这么说吗）</p>\r\n<p>总之，每个好座位到<span\r\nclass=\"math inline\">\\(（0，1）\\)</span>和<span\r\nclass=\"math inline\">\\(（0，m）\\)</span>点连成的<strong>三角区域</strong>里没有被占用的座位，这是很好理解到的。但凭借这个做题会非常复杂。<del>所以赛时很不聪明的我跑路了。</del></p>\r\n<p>我们把目光移动到，每次询问会变化的被占用座位。类似好座位的连线连一下，靠近屏幕那侧的三角区域是会挡住视线的区域，<strong>换个方向</strong>看，远离屏幕那侧的自然是能挡住别人的区域。</p>\r\n<p>在每次变动之后处理（或者更新）被占用座位的占用数量，显然比每次遮挡者变化后处理每个位置是否被遮挡容易得多。</p>\r\n<p>那么我们开始考虑处理这个遮挡区域：</p>\r\n<p>一个位置正后方的所有位置会被遮挡是很显然的。我们面向屏幕看。那么在座位<strong>左后方</strong>的位置可能看不见部分的<strong>偏右</strong>的屏幕，<strong>右后方</strong>的位置可能看不见部分<strong>偏左</strong>的屏幕。左右侧后关心的屏幕范围是可以比较<strong>独立</strong>的来看的。</p>\r\n<p>画一画图，大概是这样：三角遮挡区被<strong>正后方</strong>这条线割裂开。可以看出不同区域关心的范围是不一样的。（题目的图，旋转了）</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>并且，一个很朴素的认知：在非阶梯教室里，<strong>越前面</strong>的位置能挡住越多人。</p>\r\n<p>这在这里依然适用。在进行了区域分割后更加明显。</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%202.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%203.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>两个方向上，靠前的点的覆盖区域都能把同一行靠后的点的覆盖区域包含。</p>\r\n<p>而在<strong>不同的行</strong>上，大概表现出了一个<strong>补充</strong>的关系：</p>\r\n<figure>\r\n<img\r\nsrc=\"C-Grab%20the%20Seat!%2003866a538a6e476fa9afb5c0331a4bc6/Untitled%204.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<p>对于从<span\r\nclass=\"math inline\">\\(（0，1）\\)</span>点连线考虑的情况，处在更上方的点，虽然可能<strong>相对更靠后</strong>，但它的覆盖区域在它那行以上的地方，对原来的点的覆盖区域有一个<strong>补充</strong>的范围。</p>\r\n<p>也就是我们处理这部分答案的时候，<strong>从下向上</strong>跑是可以获得<strong>更新</strong>的。</p>\r\n<p>同理，处理另一个部分的时候，从<span\r\nclass=\"math inline\">\\(（0，m）\\)</span>连来的点也表现出了类似的性质，不过是下方的点可能对上方的点进行补充，所以这部分答案<strong>从上往下</strong>跑可能获得答案更新。</p>\r\n<p>即，我们在预先存好初始的占有座位的点情况之后，对于每次询问，先更新点，然后再找到每一行<strong>最前面</strong>的点（也就是对于每个y最小的x），每行记录被遮住的点的数量，<strong>从下向上</strong>更新一次<span\r\nclass=\"math inline\">\\(（0，1）\\)</span>点的答案，<strong>从上向下</strong>更新一次<span\r\nclass=\"math inline\">\\(（0，m）\\)</span>的答案即可。</p>\r\n<p>每行覆盖了多少点可以使用<strong>斜率</strong>计算获得。但注意，由于屏幕<strong>边界</strong>也要看见，所以<strong>正好</strong>被屏幕边缘连线覆盖的点是<strong>不作数</strong>的，也就是类似<strong>开区间</strong>那个意思。</p>\r\n<p>在处理这个问题的时候，如果使用的是<span\r\nclass=\"math inline\">\\(double\\)</span>类型计算，可以在答案里扣掉一个很小的数字来进行<strong>补正</strong>后，再转换成int类型。（比如2.000000转int是2，1.9999999转int是1）</p>\r\n<p>本题评测环境里，这个数字的范围在<span\r\nclass=\"math inline\">\\(1e-6\\)</span>到<span\r\nclass=\"math inline\">\\(1e-10\\)</span>均可。这里使用了<span\r\nclass=\"math inline\">\\(1e-9\\)</span>。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">point</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">&#125;pt[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> min_x[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">200010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,m,k,q;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;++i) cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> p;</span><br><span class=\"line\">\t\tcin&gt;&gt;p;</span><br><span class=\"line\">\t\tcin&gt;&gt;pt[p].x&gt;&gt;pt[p].y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i) min_x[i]=n<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;++i) min_x[pt[i].y]=<span class=\"built_in\">min</span>(min_x[pt[i].y],pt[i].x); </span><br><span class=\"line\">\t\t<span class=\"type\">double</span> EPS=<span class=\"number\">1e-9</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">double</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\tk=<span class=\"built_in\">max</span>(k,<span class=\"built_in\">double</span>(i<span class=\"number\">-1</span>)/min_x[i]); </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>) ans[i]=min_x[i]<span class=\"number\">-1</span>; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ans[i]=(<span class=\"type\">int</span>)(i<span class=\"number\">-1</span>)/k-EPS; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\tk=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\tk=<span class=\"built_in\">min</span>(k,<span class=\"built_in\">double</span>(i-m)/min_x[i]); </span><br><span class=\"line\">            <span class=\"type\">int</span> cmp1=(<span class=\"type\">int</span>)(min_x[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cmp2=(<span class=\"type\">int</span>)((i-m)/k-EPS); </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>) ans[i]=<span class=\"built_in\">min</span>(ans[i],cmp1);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ans[i]=<span class=\"built_in\">min</span>(ans[i],cmp2); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> anss=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++)anss+=ans[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;anss&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"d-mocha-and-railgun\">D-Mocha and Railgun</h1>\r\n<p>来源: 牛客多校训练营1 算法: 计算几何 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/D 补完: Yes 完成时间: July 18,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<h3 id=\"找最长弧\">找最长弧</h3>\r\n<figure>\r\n<img\r\nsrc=\"D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%25E5%258A%25A8%25E7%2594%25BB.gif\"\r\nalt=\"动画.gif\" />\r\n<figcaption aria-hidden=\"true\">动画.gif</figcaption>\r\n</figure>\r\n<p>发现当发射方向垂直于发射点与圆心的连线时,破坏圆弧最长</p>\r\n<h3 id=\"分类讨论\">分类讨论</h3>\r\n<p>每个样例给发射点<span class=\"math inline\">\\(Q\\)</span>点坐标<span\r\nclass=\"math inline\">\\((x,y)\\)</span>,发射半径<span\r\nclass=\"math inline\">\\(d\\)</span></p>\r\n<p>可求得发射点到圆心的圆心距<span\r\nclass=\"math inline\">\\(L=\\sqrt{x^2+y^2}\\)</span></p>\r\n<p><a href=\"https://www.geogebra.org/geometry/eyxavj6u\">几何画板</a></p>\r\n<h3 id=\"当原点在发射半径外时\">当原点在发射半径外时</h3>\r\n<p><span class=\"math inline\">\\(L&gt;d\\)</span></p>\r\n<figure>\r\n<img\r\nsrc=\"D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%A4%96.jpg\"\r\nalt=\"外.JPG\" />\r\n<figcaption aria-hidden=\"true\">外.JPG</figcaption>\r\n</figure>\r\n<p>在三角形<span class=\"math inline\">\\(AOE\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\alpha=\\arcsin(L+d)\\)</span></p>\r\n<p>在三角形<span class=\"math inline\">\\(IOJ\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\beta=\\arcsin(L-d)\\)</span></p>\r\n<p>对所求圆弧有<span\r\nclass=\"math inline\">\\(弧长=r*(\\alpha-\\beta)\\)</span></p>\r\n<h3 id=\"当原点在发射半径内时\">当原点在发射半径内时</h3>\r\n<p><span class=\"math inline\">\\(L&lt;d\\)</span></p>\r\n<figure>\r\n<img\r\nsrc=\"D-Mocha%20and%20Railgun%200b435c7011d34cdd8ca58dcd5b4d03a3/%E5%86%85.jpg\"\r\nalt=\"内.JPG\" />\r\n<figcaption aria-hidden=\"true\">内.JPG</figcaption>\r\n</figure>\r\n<p>在三角形<span class=\"math inline\">\\(AOE\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\alpha=\\arcsin(d+L)\\)</span></p>\r\n<p>在三角形<span class=\"math inline\">\\(IOJ\\)</span>上,可求得<span\r\nclass=\"math inline\">\\(\\beta=\\arcsin(d-L)\\)</span></p>\r\n<p>对所求圆弧有<span\r\nclass=\"math inline\">\\(弧长=r*(\\alpha+\\beta)\\)</span></p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<p>由上述逻辑得</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"type\">double</span> r,x,y,d,L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;d;</span><br><span class=\"line\">        L=<span class=\"built_in\">sqrt</span>(x*x+y*y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L&gt;d)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8lf\\n&quot;</span>,r*(<span class=\"built_in\">asin</span>((L+d)/r)-<span class=\"built_in\">asin</span>((L-d)/r)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8lf\\n&quot;</span>,r*(<span class=\"built_in\">asin</span>((d+L)/r)+<span class=\"built_in\">asin</span>((d-L)/r)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然而其实有<span\r\nclass=\"math inline\">\\(\\arcsin(-x)=-\\arcsin(x)\\)</span>,故可以化简</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"type\">double</span> r,x,y,d,L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;d;</span><br><span class=\"line\">        L=<span class=\"built_in\">sqrt</span>(x*x+y*y);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8lf\\n&quot;</span>,r*(<span class=\"built_in\">asin</span>((L+d)/r)-<span class=\"built_in\">asin</span>((L-d)/r)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-lexicographical-max\">G-Lexicographical Max</h1>\r\n<p>来源: 牛客多校训练营1 算法: 字典序 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/G 补完: Yes 完成时间: July 28,\r\n2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>给定一个整数n， 输出1到这个数字中所有数字字符串中字典序最大值；\r\n<strong>容易知道：</strong></p>\r\n<p>字典序排序是先比最高位再比第二位，因此字典序中9比19大，90比9大；\r\n<strong>因此我们可以：</strong></p>\r\n<p>求出n的长度len，并判断n的数字组成，若除了个位数都是9，则直接输出n；否则输出len-1个9</p>\r\n<h2 id=\"代码如下\">代码如下</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    cin&gt;&gt;a;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]!=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">            flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)cout&lt;&lt;a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len<span class=\"number\">-1</span>;i++)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;9&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"i-chiitoitsu\">I-Chiitoitsu</h1>\r\n<p>来源: 牛客多校训练营1 算法: 动态规划, 概率DP 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/I 补完: Yes 完成时间: July 22,\r\n2022</p>\r\n<h2 id=\"解题\">解题</h2>\r\n<p>最优策略相当于开了透视,保留的手牌一定是最快凑成对子的,把第二张牌来得晚的丢掉.</p>\r\n<p>所以我们具体手牌是什么不重要,只要知道已经凑齐了几个对子就好了</p>\r\n<p>此时对于保留在手上的待匹配牌,还有三张牌在牌池里.</p>\r\n<p>设牌池还剩<span class=\"math inline\">\\(i\\)</span>张牌,还有<span\r\nclass=\"math inline\">\\(j\\)</span>张牌需要凑对子,<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span>为距结束步数</p>\r\n<p>则有摸下一张牌时,可以匹配的概率为<span\r\nclass=\"math inline\">\\(\\frac{3*j}{i}\\)</span>,不可以匹配的概率为<span\r\nclass=\"math inline\">\\(\\frac{i-3*j}{i}\\)</span></p>\r\n<p>因为初始手牌为<span class=\"math inline\">\\(13\\)</span>张,其中有<span\r\nclass=\"math inline\">\\(13-j\\)</span>张牌是对子,则在游戏结束前<span\r\nclass=\"math inline\">\\(j\\)</span>只能为奇数</p>\r\n<p>当<span class=\"math inline\">\\(j=0\\)</span>时,</p>\r\n<p>所有牌都得到匹配,游戏结束,距游戏结束还有 <span\r\nclass=\"math inline\">\\(0\\)</span>回合</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nf[i][0]=0\r\n\\end{align}\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(j=1\\)</span>时,</p>\r\n<p>摸完一张牌之后牌池还剩<span\r\nclass=\"math inline\">\\(i-1\\)</span>张牌,</p>\r\n<p>若匹配则消不匹配的牌,还有<span\r\nclass=\"math inline\">\\(j-1\\)</span>张待匹配的牌,</p>\r\n<p>若不可以匹配则丢摸到的这张牌,还有<span\r\nclass=\"math inline\">\\(j\\)</span>张待匹配的牌</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nf[i][j]&amp;=1\\\\\r\n&amp;+\\frac{3*j}{i}*f[i-1][j-1]&amp;匹配\\\\\r\n&amp;+\\frac{i-3*j}{i}*f[i-1][j]&amp;不匹配\r\n\\end{align}\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(j&gt;1\\)</span>时,</p>\r\n<p>摸完一张牌之后牌池还剩<span\r\nclass=\"math inline\">\\(i-1\\)</span>张牌,</p>\r\n<p>若匹配则消不匹配的牌同时丢一张不能匹配的牌,还有<span\r\nclass=\"math inline\">\\(j-2\\)</span>张待匹配的牌,</p>\r\n<p>若不可以匹配则丢摸到的这张牌,还有<span\r\nclass=\"math inline\">\\(j\\)</span>张待匹配的牌</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\nf[i][j]&amp;=1\\\\\r\n&amp;+\\frac{3*j}{i}*f[i-1][j-2]&amp;匹配\\\\\r\n&amp;+\\frac{i-3*j}{i}*f[i-1][j]&amp;不匹配\r\n\\end{align}\r\n\\]</span></p>\r\n<p>跑完之后直接拿数据访问<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span>即可</p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">1e9</span><span class=\"number\">+7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t=<span class=\"number\">1</span>;</span><br><span class=\"line\">ll f[<span class=\"number\">137</span>][<span class=\"number\">14</span>];</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll x,ll a)</span></span>&#123;</span><br><span class=\"line\">    ll res=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a&amp;<span class=\"number\">1</span>)res=res*x%P;</span><br><span class=\"line\">        x= x*x%P;</span><br><span class=\"line\">        a&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">13</span>;j+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">136</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j==<span class=\"number\">1</span>)f[i][j]=(<span class=\"number\">1</span>+(<span class=\"number\">3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]%P+(i<span class=\"number\">-3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j]%P)%P;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>    f[i][j]=(<span class=\"number\">1</span>+(<span class=\"number\">3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j<span class=\"number\">-2</span>]%P+(i<span class=\"number\">-3</span>*j)*<span class=\"built_in\">qpow</span>(i,P<span class=\"number\">-2</span>)%P*f[i<span class=\"number\">-1</span>][j]%P)%P;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> s[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,&amp;s);</span><br><span class=\"line\">    <span class=\"type\">int</span> pp[<span class=\"number\">5</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">            pp[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(s[i<span class=\"number\">+1</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;m&#x27;</span>:pp[<span class=\"number\">1</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;p&#x27;</span>:pp[<span class=\"number\">2</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;s&#x27;</span>:pp[<span class=\"number\">3</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;z&#x27;</span>:pp[<span class=\"number\">4</span>][s[i]-<span class=\"string\">&#x27;0&#x27;</span>]++;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pp[i][j]&gt;<span class=\"number\">1</span>)cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Case #%d: %lld\\n&quot;</span>,t++,f[<span class=\"number\">123</span>][<span class=\"number\">13</span>-cnt*<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Init</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-serval-and-essay\">J-Serval and Essay</h1>\r\n<p>来源: 牛客多校训练营1 算法: set, 启发式合并, 并查集, 数论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33186/J 补完: Yes 完成时间: August\r\n23, 2022</p>\r\n<p>完完全全的补题，题解参考雨巨的讲解</p>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<ul>\r\n<li>有一张<span class=\"math inline\">\\(n\\)</span> 个点<span\r\nclass=\"math inline\">\\(m\\)</span>条边的无重边无自环的有向图</li>\r\n<li>初始时可以选择一个点染黑，其余均为白点</li>\r\n<li>若某个点所有入边的起点均为黑点，则该点可以被染黑</li>\r\n<li>选择一点染黑使得图中黑点数量最大化</li>\r\n</ul>\r\n<h2 id=\"解\">解</h2>\r\n<p>从图中所有没有访问过的点出发，把所有入度为1的点和它的前面的那一部分合并，合并后要把重复的边去掉。对于可以合成一堆的块来说，只需要把起始点染黑，那么这个整块都会变成黑的，而我们要找的就是经过合并操作之后，哪一整块会最大，然后这块是多大。</p>\r\n<h3 id=\"处理\">处理</h3>\r\n<p>用set存储集合连出去的边指向的点，再将另一个集合连出去的边放置在set，所形成的新集合继续与其他集合合并。</p>\r\n<p>如果一个点的入度是1，就以此为起点搜索前部分，把前部分和此点所在集合进行合并，把边数小的集合合并到边数大的集合上，在这个过程中入度也要处理。\r\n## 代码 <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">1e6</span><span class=\"number\">+10</span>;</span><br><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt;to[N],from[N];</span><br><span class=\"line\"><span class=\"type\">int</span> fa[N],sz[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i==fa[i])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfa[i]=<span class=\"built_in\">find</span>(fa[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fa[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _Merge(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//得到这两点的并查集 </span></span><br><span class=\"line\">\tx=<span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">\ty=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x==y)   <span class=\"comment\">//已经在一个集合里了，说明已经被合并过 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(to[x].<span class=\"built_in\">size</span>()&lt;to[y].<span class=\"built_in\">size</span>())  <span class=\"comment\">//找指出去少的边来遍历 </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\tfa[y]=x;  <span class=\"comment\">//合并 </span></span><br><span class=\"line\">\tsz[x]+=sz[y];  <span class=\"comment\">//大小更新 </span></span><br><span class=\"line\">\tvector&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt;mg; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> t : to[y])&#123;      <span class=\"comment\">// 把y指出去的边都遍历一遍 </span></span><br><span class=\"line\">\t\tto[x].<span class=\"built_in\">insert</span>(t);  <span class=\"comment\">//让x指向t </span></span><br><span class=\"line\">\t\tfrom[t].<span class=\"built_in\">erase</span>(y); <span class=\"comment\">//消去t从y连过来的边 </span></span><br><span class=\"line\">\t\tfrom[t].<span class=\"built_in\">insert</span>(x);<span class=\"comment\">//加上x指向t的边 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(from[t].<span class=\"built_in\">size</span>()==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tmg.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(t,x));  <span class=\"comment\">//可合并 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> [x,y]:mg)&#123;</span><br><span class=\"line\">\t\t_Merge(x,y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tfa[i]=i;  <span class=\"comment\">//并查集的父亲 </span></span><br><span class=\"line\">\t\t\tsz[i]=<span class=\"number\">1</span>;  <span class=\"comment\">// 表示集合大小的数组 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;  <span class=\"comment\">//读入边 </span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> k;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;k;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;a;</span><br><span class=\"line\">\t\t\t\tto[a].<span class=\"built_in\">insert</span>(i);</span><br><span class=\"line\">\t\t\t\tfrom[i].<span class=\"built_in\">insert</span>(a);</span><br><span class=\"line\">\t\t\t&#125;  <span class=\"comment\">//建立双向边 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(from[i].<span class=\"built_in\">size</span>()==<span class=\"number\">1</span>)&#123;  <span class=\"comment\">//遍历所有size等于1的点 </span></span><br><span class=\"line\">\t\t\t\t_Merge(*from[i].<span class=\"built_in\">begin</span>(),i);   <span class=\"comment\">//把它和前部分合并 </span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;   <span class=\"comment\">//找到最大块集合</span></span><br><span class=\"line\">\t\t\tans=<span class=\"built_in\">max</span>(ans,sz[i]);</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Case #%d: %d\\n&quot;</span>,p++,ans);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;    <span class=\"comment\">//清空</span></span><br><span class=\"line\">\t\t\tto[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t\tfrom[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n"},{"title":"2022牛客多校训练营03","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# C-Concatenation\n\n来源: 牛客多校训练营3\n算法: 字符串\n题目链接: https://ac.nowcoder.com/acm/contest/33188/C\n补完: Yes\n完成时间: August 25, 2022\n\n## 题意\n\n- 给定$n$个五进制的数字\n- 将这$n$个数字串起来\n- 求串起来的数字字典序最小是多少？\n\n## 解法\n\n（按照赛时过的写法）~~凭运气过题~~\n\n比较$a+b$和$b+a$的字典序大小，小的放前面\n\n## 代码\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\nstring a[2000010];\nbool cmp(string c,string d){\n\tstring ai=c+d,bi=d+c;\n\treturn ai<bi;\n}\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n,cmp);\n\tfor(int i=0;i<n;i++)cout<<a[i];\n\treturn 0; \n}\n```\n\n# J-Journey\n\n来源: 牛客多校训练营3\n算法: 图论, 最短路\n题目链接: https://ac.nowcoder.com/acm/contest/33188/J\n补完: Yes\n完成时间: August 9, 2022\n\n## 题解\n\n得一个城市有若干十字路口, 每次进入一个十字路口, 右转出路口不需要等红灯, 左转/掉头/直行都要等红灯, 求从起点到终点最少要等几次红灯.\n\n可以整理成以路为点, 以行驶方向为边, 等红灯为权建图, 以一个东西南北四向十字路口有例:\n\n右转[0]: 南→东, 东→北, 北→西, 西→南. \n\n左转[1]: 南→西, 东→南, 北→东, 西→北.\n\n掉头[1]: 南→南, 东→东, 北→北, 西→西. \n\n直行[1]: 南→北, 东→西, 北→南, 西→东. \n\n---\n\n建图跑最短路\n\n题目给数据以十字路口标号$c_{i,j}$, \n\n表示从第$i$个路口出发的第$j$条路驶向第$c_{i,j}$个路口, 记为点$c[i][j]$, \n\n则若存在从第$i$个路口出发的第$j_1$条路$u$驶入路口$k$, 则存在$c[i][j_1]==k$, \n\n同时对于此第$k$个个路口来说第$j_2$条路$\\overline u$返回路口$i$, 则存在$c[k][j_2] ==i$, \n\n确定$i,k$后可遍历四条边找到$j_2$. \n\n则若存在从第$k$个路口出发的第$j_3$条路$v$驶入路口$l$, 则存在$c[k][j_3] ==l$ , \n\n则有从第$i$个路口出发前往第$l$个路口的路在第$k$个路口经过了一次从$j_2$来, 往$j_3$去的一次转弯. 记为边$<u,v>$\n\n题目给数据为逆时针出现路, 意为从第$j$条路驶入路口, 第$j\\%4+1$条路驶出路口时为右转, 此时不用等红灯. \n\n则若$j_2\\%4+1==j_3$, 此此转弯不用等红灯, 若$j_2\\%4+1!=j_3$,此次转弯要等红灯\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 500005;\n\nint c[MAXN][5];\nint n, s1, s2, t1, t2;\nmap<int, bool> st[MAXN];\n\nstruct Node {\n    int u;\n    int v;\n    int d;\n    bool operator<(const Node &next) const {\n        return d > next.d;\n    }\n};\n\nint dijkstra(Node start) {\n    priority_queue<Node> que;\n    que.push(start);\n    while (que.size()) {\n        auto t = que.top();\n        que.pop();\n        if (st[t.u][t.v])continue;\n        st[t.u][t.v] = true;\n        if (t.u == t1 && t.v ==t2)return t.d;\n        int from = 0;\n        for (int j = 1; j <= 4; j++) {\n            if (c[t.v][j] == t.u)\n                from = j%4+1;\n        }\n        for (int j = 1; j <= 4; j++) {\n            if (st[t.v][c[t.v][j]])continue;\n            else que.push({t.v,c[t.v][j],t.d+(from != j)});\n        }\n    }\n    return -1;\n}\n\nint main() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j<=4; j++) {\n            cin>>c[i][j];\n        }\n    }\n    cin>>s1>>s2>>t1>>t2;\n    cout<<dijkstra({s1, s2, 0});\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营03.md","raw":"---\ntitle: 2022牛客多校训练营03\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# C-Concatenation\n\n来源: 牛客多校训练营3\n算法: 字符串\n题目链接: https://ac.nowcoder.com/acm/contest/33188/C\n补完: Yes\n完成时间: August 25, 2022\n\n## 题意\n\n- 给定$n$个五进制的数字\n- 将这$n$个数字串起来\n- 求串起来的数字字典序最小是多少？\n\n## 解法\n\n（按照赛时过的写法）~~凭运气过题~~\n\n比较$a+b$和$b+a$的字典序大小，小的放前面\n\n## 代码\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\nstring a[2000010];\nbool cmp(string c,string d){\n\tstring ai=c+d,bi=d+c;\n\treturn ai<bi;\n}\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n,cmp);\n\tfor(int i=0;i<n;i++)cout<<a[i];\n\treturn 0; \n}\n```\n\n# J-Journey\n\n来源: 牛客多校训练营3\n算法: 图论, 最短路\n题目链接: https://ac.nowcoder.com/acm/contest/33188/J\n补完: Yes\n完成时间: August 9, 2022\n\n## 题解\n\n得一个城市有若干十字路口, 每次进入一个十字路口, 右转出路口不需要等红灯, 左转/掉头/直行都要等红灯, 求从起点到终点最少要等几次红灯.\n\n可以整理成以路为点, 以行驶方向为边, 等红灯为权建图, 以一个东西南北四向十字路口有例:\n\n右转[0]: 南→东, 东→北, 北→西, 西→南. \n\n左转[1]: 南→西, 东→南, 北→东, 西→北.\n\n掉头[1]: 南→南, 东→东, 北→北, 西→西. \n\n直行[1]: 南→北, 东→西, 北→南, 西→东. \n\n---\n\n建图跑最短路\n\n题目给数据以十字路口标号$c_{i,j}$, \n\n表示从第$i$个路口出发的第$j$条路驶向第$c_{i,j}$个路口, 记为点$c[i][j]$, \n\n则若存在从第$i$个路口出发的第$j_1$条路$u$驶入路口$k$, 则存在$c[i][j_1]==k$, \n\n同时对于此第$k$个个路口来说第$j_2$条路$\\overline u$返回路口$i$, 则存在$c[k][j_2] ==i$, \n\n确定$i,k$后可遍历四条边找到$j_2$. \n\n则若存在从第$k$个路口出发的第$j_3$条路$v$驶入路口$l$, 则存在$c[k][j_3] ==l$ , \n\n则有从第$i$个路口出发前往第$l$个路口的路在第$k$个路口经过了一次从$j_2$来, 往$j_3$去的一次转弯. 记为边$<u,v>$\n\n题目给数据为逆时针出现路, 意为从第$j$条路驶入路口, 第$j\\%4+1$条路驶出路口时为右转, 此时不用等红灯. \n\n则若$j_2\\%4+1==j_3$, 此此转弯不用等红灯, 若$j_2\\%4+1!=j_3$,此次转弯要等红灯\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 500005;\n\nint c[MAXN][5];\nint n, s1, s2, t1, t2;\nmap<int, bool> st[MAXN];\n\nstruct Node {\n    int u;\n    int v;\n    int d;\n    bool operator<(const Node &next) const {\n        return d > next.d;\n    }\n};\n\nint dijkstra(Node start) {\n    priority_queue<Node> que;\n    que.push(start);\n    while (que.size()) {\n        auto t = que.top();\n        que.pop();\n        if (st[t.u][t.v])continue;\n        st[t.u][t.v] = true;\n        if (t.u == t1 && t.v ==t2)return t.d;\n        int from = 0;\n        for (int j = 1; j <= 4; j++) {\n            if (c[t.v][j] == t.u)\n                from = j%4+1;\n        }\n        for (int j = 1; j <= 4; j++) {\n            if (st[t.v][c[t.v][j]])continue;\n            else que.push({t.v,c[t.v][j],t.d+(from != j)});\n        }\n    }\n    return -1;\n}\n\nint main() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j<=4; j++) {\n            cin>>c[i][j];\n        }\n    }\n    cin>>s1>>s2>>t1>>t2;\n    cout<<dijkstra({s1, s2, 0});\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营03","published":1,"updated":"2023-10-29T06:42:15.911Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexa000cn0um05zi594y","content":"<h1 id=\"c-concatenation\">C-Concatenation</h1>\r\n<p>来源: 牛客多校训练营3 算法: 字符串 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33188/C 补完: Yes 完成时间: August\r\n25, 2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<ul>\r\n<li>给定<span class=\"math inline\">\\(n\\)</span>个五进制的数字</li>\r\n<li>将这<span class=\"math inline\">\\(n\\)</span>个数字串起来</li>\r\n<li>求串起来的数字字典序最小是多少？</li>\r\n</ul>\r\n<h2 id=\"解法\">解法</h2>\r\n<p>（按照赛时过的写法）<del>凭运气过题</del></p>\r\n<p>比较<span class=\"math inline\">\\(a+b\\)</span>和<span\r\nclass=\"math inline\">\\(b+a\\)</span>的字典序大小，小的放前面</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">string a[<span class=\"number\">2000010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(string c,string d)</span></span>&#123;</span><br><span class=\"line\">\tstring ai=c+d,bi=d+c;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ai&lt;bi;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tstd::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a+n,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cout&lt;&lt;a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-journey\">J-Journey</h1>\r\n<p>来源: 牛客多校训练营3 算法: 图论, 最短路 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33188/J 补完: Yes 完成时间: August\r\n9, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>得一个城市有若干十字路口, 每次进入一个十字路口,\r\n右转出路口不需要等红灯, 左转/掉头/直行都要等红灯,\r\n求从起点到终点最少要等几次红灯.</p>\r\n<p>可以整理成以路为点, 以行驶方向为边, 等红灯为权建图,\r\n以一个东西南北四向十字路口有例:</p>\r\n<p>右转[0]: 南→东, 东→北, 北→西, 西→南.</p>\r\n<p>左转[1]: 南→西, 东→南, 北→东, 西→北.</p>\r\n<p>掉头[1]: 南→南, 东→东, 北→北, 西→西.</p>\r\n<p>直行[1]: 南→北, 东→西, 北→南, 西→东.</p>\r\n<hr />\r\n<p>建图跑最短路</p>\r\n<p>题目给数据以十字路口标号<span\r\nclass=\"math inline\">\\(c_{i,j}\\)</span>,</p>\r\n<p>表示从第<span class=\"math inline\">\\(i\\)</span>个路口出发的第<span\r\nclass=\"math inline\">\\(j\\)</span>条路驶向第<span\r\nclass=\"math inline\">\\(c_{i,j}\\)</span>个路口, 记为点<span\r\nclass=\"math inline\">\\(c[i][j]\\)</span>,</p>\r\n<p>则若存在从第<span class=\"math inline\">\\(i\\)</span>个路口出发的第<span\r\nclass=\"math inline\">\\(j_1\\)</span>条路<span\r\nclass=\"math inline\">\\(u\\)</span>驶入路口<span\r\nclass=\"math inline\">\\(k\\)</span>, 则存在<span\r\nclass=\"math inline\">\\(c[i][j_1]==k\\)</span>,</p>\r\n<p>同时对于此第<span class=\"math inline\">\\(k\\)</span>个个路口来说第<span\r\nclass=\"math inline\">\\(j_2\\)</span>条路<span\r\nclass=\"math inline\">\\(\\overline u\\)</span>返回路口<span\r\nclass=\"math inline\">\\(i\\)</span>, 则存在<span\r\nclass=\"math inline\">\\(c[k][j_2] ==i\\)</span>,</p>\r\n<p>确定<span class=\"math inline\">\\(i,k\\)</span>后可遍历四条边找到<span\r\nclass=\"math inline\">\\(j_2\\)</span>.</p>\r\n<p>则若存在从第<span class=\"math inline\">\\(k\\)</span>个路口出发的第<span\r\nclass=\"math inline\">\\(j_3\\)</span>条路<span\r\nclass=\"math inline\">\\(v\\)</span>驶入路口<span\r\nclass=\"math inline\">\\(l\\)</span>, 则存在<span\r\nclass=\"math inline\">\\(c[k][j_3] ==l\\)</span> ,</p>\r\n<p>则有从第<span class=\"math inline\">\\(i\\)</span>个路口出发前往第<span\r\nclass=\"math inline\">\\(l\\)</span>个路口的路在第<span\r\nclass=\"math inline\">\\(k\\)</span>个路口经过了一次从<span\r\nclass=\"math inline\">\\(j_2\\)</span>来, 往<span\r\nclass=\"math inline\">\\(j_3\\)</span>去的一次转弯. 记为边<span\r\nclass=\"math inline\">\\(&lt;u,v&gt;\\)</span></p>\r\n<p>题目给数据为逆时针出现路, 意为从第<span\r\nclass=\"math inline\">\\(j\\)</span>条路驶入路口, 第<span\r\nclass=\"math inline\">\\(j\\%4+1\\)</span>条路驶出路口时为右转,\r\n此时不用等红灯.</p>\r\n<p>则若<span class=\"math inline\">\\(j_2\\%4+1==j_3\\)</span>,\r\n此此转弯不用等红灯, 若<span\r\nclass=\"math inline\">\\(j_2\\%4+1!=j_3\\)</span>,此次转弯要等红灯</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">500005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> c[MAXN][<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n, s1, s2, t1, t2;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, <span class=\"type\">bool</span>&gt; st[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    <span class=\"type\">int</span> d;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Node &amp;next) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d &gt; next.d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">(Node start)</span> </span>&#123;</span><br><span class=\"line\">    priority_queue&lt;Node&gt; que;</span><br><span class=\"line\">    que.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (que.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = que.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[t.u][t.v])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        st[t.u][t.v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.u == t1 &amp;&amp; t.v ==t2)<span class=\"keyword\">return</span> t.d;</span><br><span class=\"line\">        <span class=\"type\">int</span> from = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c[t.v][j] == t.u)</span><br><span class=\"line\">                from = j%<span class=\"number\">4</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (st[t.v][c[t.v][j]])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> que.<span class=\"built_in\">push</span>(&#123;t.v,c[t.v][j],t.d+(from != j)&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j&lt;=<span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            cin&gt;&gt;c[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;t1&gt;&gt;t2;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">dijkstra</span>(&#123;s1, s2, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"c-concatenation\">C-Concatenation</h1>\r\n<p>来源: 牛客多校训练营3 算法: 字符串 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33188/C 补完: Yes 完成时间: August\r\n25, 2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<ul>\r\n<li>给定<span class=\"math inline\">\\(n\\)</span>个五进制的数字</li>\r\n<li>将这<span class=\"math inline\">\\(n\\)</span>个数字串起来</li>\r\n<li>求串起来的数字字典序最小是多少？</li>\r\n</ul>\r\n<h2 id=\"解法\">解法</h2>\r\n<p>（按照赛时过的写法）<del>凭运气过题</del></p>\r\n<p>比较<span class=\"math inline\">\\(a+b\\)</span>和<span\r\nclass=\"math inline\">\\(b+a\\)</span>的字典序大小，小的放前面</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">string a[<span class=\"number\">2000010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(string c,string d)</span></span>&#123;</span><br><span class=\"line\">\tstring ai=c+d,bi=d+c;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ai&lt;bi;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tstd::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a,a+n,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)cout&lt;&lt;a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-journey\">J-Journey</h1>\r\n<p>来源: 牛客多校训练营3 算法: 图论, 最短路 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33188/J 补完: Yes 完成时间: August\r\n9, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>得一个城市有若干十字路口, 每次进入一个十字路口,\r\n右转出路口不需要等红灯, 左转/掉头/直行都要等红灯,\r\n求从起点到终点最少要等几次红灯.</p>\r\n<p>可以整理成以路为点, 以行驶方向为边, 等红灯为权建图,\r\n以一个东西南北四向十字路口有例:</p>\r\n<p>右转[0]: 南→东, 东→北, 北→西, 西→南.</p>\r\n<p>左转[1]: 南→西, 东→南, 北→东, 西→北.</p>\r\n<p>掉头[1]: 南→南, 东→东, 北→北, 西→西.</p>\r\n<p>直行[1]: 南→北, 东→西, 北→南, 西→东.</p>\r\n<hr />\r\n<p>建图跑最短路</p>\r\n<p>题目给数据以十字路口标号<span\r\nclass=\"math inline\">\\(c_{i,j}\\)</span>,</p>\r\n<p>表示从第<span class=\"math inline\">\\(i\\)</span>个路口出发的第<span\r\nclass=\"math inline\">\\(j\\)</span>条路驶向第<span\r\nclass=\"math inline\">\\(c_{i,j}\\)</span>个路口, 记为点<span\r\nclass=\"math inline\">\\(c[i][j]\\)</span>,</p>\r\n<p>则若存在从第<span class=\"math inline\">\\(i\\)</span>个路口出发的第<span\r\nclass=\"math inline\">\\(j_1\\)</span>条路<span\r\nclass=\"math inline\">\\(u\\)</span>驶入路口<span\r\nclass=\"math inline\">\\(k\\)</span>, 则存在<span\r\nclass=\"math inline\">\\(c[i][j_1]==k\\)</span>,</p>\r\n<p>同时对于此第<span class=\"math inline\">\\(k\\)</span>个个路口来说第<span\r\nclass=\"math inline\">\\(j_2\\)</span>条路<span\r\nclass=\"math inline\">\\(\\overline u\\)</span>返回路口<span\r\nclass=\"math inline\">\\(i\\)</span>, 则存在<span\r\nclass=\"math inline\">\\(c[k][j_2] ==i\\)</span>,</p>\r\n<p>确定<span class=\"math inline\">\\(i,k\\)</span>后可遍历四条边找到<span\r\nclass=\"math inline\">\\(j_2\\)</span>.</p>\r\n<p>则若存在从第<span class=\"math inline\">\\(k\\)</span>个路口出发的第<span\r\nclass=\"math inline\">\\(j_3\\)</span>条路<span\r\nclass=\"math inline\">\\(v\\)</span>驶入路口<span\r\nclass=\"math inline\">\\(l\\)</span>, 则存在<span\r\nclass=\"math inline\">\\(c[k][j_3] ==l\\)</span> ,</p>\r\n<p>则有从第<span class=\"math inline\">\\(i\\)</span>个路口出发前往第<span\r\nclass=\"math inline\">\\(l\\)</span>个路口的路在第<span\r\nclass=\"math inline\">\\(k\\)</span>个路口经过了一次从<span\r\nclass=\"math inline\">\\(j_2\\)</span>来, 往<span\r\nclass=\"math inline\">\\(j_3\\)</span>去的一次转弯. 记为边<span\r\nclass=\"math inline\">\\(&lt;u,v&gt;\\)</span></p>\r\n<p>题目给数据为逆时针出现路, 意为从第<span\r\nclass=\"math inline\">\\(j\\)</span>条路驶入路口, 第<span\r\nclass=\"math inline\">\\(j\\%4+1\\)</span>条路驶出路口时为右转,\r\n此时不用等红灯.</p>\r\n<p>则若<span class=\"math inline\">\\(j_2\\%4+1==j_3\\)</span>,\r\n此此转弯不用等红灯, 若<span\r\nclass=\"math inline\">\\(j_2\\%4+1!=j_3\\)</span>,此次转弯要等红灯</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">500005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> c[MAXN][<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n, s1, s2, t1, t2;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, <span class=\"type\">bool</span>&gt; st[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    <span class=\"type\">int</span> d;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Node &amp;next) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d &gt; next.d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">(Node start)</span> </span>&#123;</span><br><span class=\"line\">    priority_queue&lt;Node&gt; que;</span><br><span class=\"line\">    que.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (que.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = que.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[t.u][t.v])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        st[t.u][t.v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.u == t1 &amp;&amp; t.v ==t2)<span class=\"keyword\">return</span> t.d;</span><br><span class=\"line\">        <span class=\"type\">int</span> from = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c[t.v][j] == t.u)</span><br><span class=\"line\">                from = j%<span class=\"number\">4</span><span class=\"number\">+1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (st[t.v][c[t.v][j]])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> que.<span class=\"built_in\">push</span>(&#123;t.v,c[t.v][j],t.d+(from != j)&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j&lt;=<span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            cin&gt;&gt;c[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;t1&gt;&gt;t2;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">dijkstra</span>(&#123;s1, s2, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营04","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# L-Black Hole\n\n来源: 牛客多校训练营4\n算法: 模拟, 计算几何\n补完: Yes\n完成时间: August 16, 2022\n\n## 题解\n\n有一个正$n$面体, 初始边长为$a$, 做$k$次操作:\n\n取正$n$面体的中心, 求它们的凸包, 得到新的正$n'$面体.\n\n求最终正$n'$面体的面数$n'$和边长$a'$.\n\n正$n$面体一共只有五种, 且有以下性质\n\n| 名称       | 面       | 对偶多面体 |\n| ---------- | -------- | ---------- |\n| 正四面体   | 正三角形 | 正四面体   |\n| 正六面体   | 正方形   | 正八面体   |\n| 正八面体   | 正三角形 | 正六面体   |\n| 正十二面体 | 正五边形 | 正二十面体 |\n| 正二十面体 | 正三角形 | 正十二面体 |\n\n当知道多面体的中心到棱长的距离$l$和二面角$\\alpha$时, 可以求得对偶多面体的棱长$a'$\n\n$$\na'=\\sqrt{2l^2(1-\\cos\\alpha)}\n$$\n\n已知多面体的面时, 就可求$l$\n\n对正方形\n\n$$\nl=\\frac 12 a\n$$\n\n对正三角形\n\n$$\nl=\\frac{\\sqrt 3}{6}a\n$$\n\n对正五边形\n\n$$\nl=\\frac{\\sqrt{25+10\\sqrt{5}}}{10}a\n$$\n\n多面体二面角查资料得,\n\n| 名称       | 二面角                         |\n| ---------- | ------------------------------ |\n| 正四面体   | $\\arccos{\\frac{1}{3}}$         |\n| 正六面体   | $\\arccos{0}$                   |\n| 正八面体   | $\\arccos{-\\frac{1}{3}}$        |\n| 正十二面体 | $\\arccos{-\\frac{\\sqrt{5}}{5}}$ |\n| 正二十面体 | $\\arccos{-\\frac{\\sqrt{5}}{3}}$ |\n\n最终有\n\n| 名称       | 对偶多面体 | 对偶多面体棱长棱长        |\n| ---------- | ---------- | ------------------------- |\n| 正四面体   | 正四面体   | $\\frac{1}{3}a$            |\n| 正六面体   | 正八面体   | $\\frac{1}{\\sqrt{2}}a$     |\n| 正八面体   | 正六面体   | $\\frac{\\sqrt{2}}{3}a$     |\n| 正十二面体 | 正二十面体 | $\\frac{5+3\\sqrt{5}}{10}a$ |\n| 正二十面体 | 正十二面体 | $\\frac{1+\\sqrt{5}}{6}a$   |\n\n### 参考\n\n**[高度对称的多面体和它们的对偶多面体](http://www.matrix67.com/blog/archives/6161)**\n\n****[五种正多面体的二面角以及体积的计算](https://zhuanlan.zhihu.com/p/455979279)****\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ndouble a;\nint n,k;\n\nbool duiou(){\n    switch (n) {\n    case 4:\n        n = 4;\n        a = a/3;\n        return 1;\n    case 6:\n        n = 8;\n        a = a/sqrt(2);\n        return 1;\n    case 8:\n        n = 6;\n        a = a*sqrt(2)/3;\n        return 1;\n    case 12:\n        n = 20;\n        a = a*(5+3*sqrt(5))/10;\n        return 1;\n    case 20:\n        n = 12;\n        a = a*(1+sqrt(5))/6;\n        return 1;\n    default:\n        return 0;\n    }\n}\n\nvoid solve() {\n    cin>>n>>a>>k;\n    while(duiou()&&--k);//不合法或操作次数完就退出循环\n    if(k)printf(\"impossible \\n\");//未操作完即为不合法\n    else printf(\"possible %d %.15lf\\n\",n,a);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# N-Particle Arts\n\n来源: 牛客多校训练营4\n算法: 位运算\n题目链接: https://ac.nowcoder.com/acm/contest/33189/N\n补完: Yes\n完成时间: July 30, 2022\n\n## 题解\n\n发现两粒子碰撞之后能量和不变, 但能量差更大.\n\n$$\n0011\\to AND~0001\\\\\n0101\\to OR~~~~~0111 \n$$\n\n则收敛的稳定值为总体能量差最大的情况.\n\n用桶提取每个粒子的每个二进制位上的能量, 然后再组合成尽可能大能量的粒子.\n\n要求输出真分数, 故不能在计算时直接除, 要保留分子$z$分母$m$到最后, 最后用$GCD$处理后输出.\n\n计算公式如下转换\n\n$$\nσ^2=\\frac1n∑_{i=1}^n(x_i−μ)^2\\\\μ=\\frac 1n∑_{i=1}^nx_i\\\\\nsum=∑_{i=1}^nx_i\n$$\n\n$$\nσ^2=\\frac1n∑_{i=1}^n(\\frac{nx_i}{n}−\\frac{sum}{n})^2\n$$\n\n$$\nσ^2=\\frac1n∑_{i=1}^n({\\frac{n^2x_i^2}{n^2}}−{\\frac{2nx_isum}{n^2}}+{\\frac{sum^2}{n^2}})\n                            \n$$\n\n$$\nσ^2=\\frac n{n^2}∑_{i=1}^n{x_i^2}−{\\frac{2sum^2}{n^2}}∑_{i=1}^nx_i+{\\frac{sum^2}{n^2}}∑_{i=1}^n1\n                            \n$$\n\n$$\nσ^2=\\frac n{n^2}∑_{i=1}^n{x_i^2}−{\\frac{2sum^2}{n^2}}+{\\frac{sum^2}{n^2}}\n                            \n$$\n\n$$\nσ^2=\\frac{n∑_{i=1}^n{x_i^2}−sum^2}{n^2}\n                            \n$$\n\n注意数据范围$n≤1e5$, $n*n$就爆int了.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll num[15];\nll temp,sum;\nll z,m;\nvoid solve(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>temp;\n        for(int j=0;j<15;j++){\n            if(temp&(1<<j))num[j]++;\n        }\n        sum += temp;\n    }\n    for(int i=0;i<n;i++){\n        int temp=0;\n        for(int j=0;j<15;j++){\n            if(num[j])temp|=(1<<j),num[j]--;\n        }\n        z += temp*temp;\n    }\n    z = z*n - sum*sum;\n    m = (long long)n*n;\n    ll g = __gcd(z,m);\n    printf(\"%lld/%lld\\n\",z/g,m/g);\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营04.md","raw":"---\ntitle: 2022牛客多校训练营04\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# L-Black Hole\n\n来源: 牛客多校训练营4\n算法: 模拟, 计算几何\n补完: Yes\n完成时间: August 16, 2022\n\n## 题解\n\n有一个正$n$面体, 初始边长为$a$, 做$k$次操作:\n\n取正$n$面体的中心, 求它们的凸包, 得到新的正$n'$面体.\n\n求最终正$n'$面体的面数$n'$和边长$a'$.\n\n正$n$面体一共只有五种, 且有以下性质\n\n| 名称       | 面       | 对偶多面体 |\n| ---------- | -------- | ---------- |\n| 正四面体   | 正三角形 | 正四面体   |\n| 正六面体   | 正方形   | 正八面体   |\n| 正八面体   | 正三角形 | 正六面体   |\n| 正十二面体 | 正五边形 | 正二十面体 |\n| 正二十面体 | 正三角形 | 正十二面体 |\n\n当知道多面体的中心到棱长的距离$l$和二面角$\\alpha$时, 可以求得对偶多面体的棱长$a'$\n\n$$\na'=\\sqrt{2l^2(1-\\cos\\alpha)}\n$$\n\n已知多面体的面时, 就可求$l$\n\n对正方形\n\n$$\nl=\\frac 12 a\n$$\n\n对正三角形\n\n$$\nl=\\frac{\\sqrt 3}{6}a\n$$\n\n对正五边形\n\n$$\nl=\\frac{\\sqrt{25+10\\sqrt{5}}}{10}a\n$$\n\n多面体二面角查资料得,\n\n| 名称       | 二面角                         |\n| ---------- | ------------------------------ |\n| 正四面体   | $\\arccos{\\frac{1}{3}}$         |\n| 正六面体   | $\\arccos{0}$                   |\n| 正八面体   | $\\arccos{-\\frac{1}{3}}$        |\n| 正十二面体 | $\\arccos{-\\frac{\\sqrt{5}}{5}}$ |\n| 正二十面体 | $\\arccos{-\\frac{\\sqrt{5}}{3}}$ |\n\n最终有\n\n| 名称       | 对偶多面体 | 对偶多面体棱长棱长        |\n| ---------- | ---------- | ------------------------- |\n| 正四面体   | 正四面体   | $\\frac{1}{3}a$            |\n| 正六面体   | 正八面体   | $\\frac{1}{\\sqrt{2}}a$     |\n| 正八面体   | 正六面体   | $\\frac{\\sqrt{2}}{3}a$     |\n| 正十二面体 | 正二十面体 | $\\frac{5+3\\sqrt{5}}{10}a$ |\n| 正二十面体 | 正十二面体 | $\\frac{1+\\sqrt{5}}{6}a$   |\n\n### 参考\n\n**[高度对称的多面体和它们的对偶多面体](http://www.matrix67.com/blog/archives/6161)**\n\n****[五种正多面体的二面角以及体积的计算](https://zhuanlan.zhihu.com/p/455979279)****\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ndouble a;\nint n,k;\n\nbool duiou(){\n    switch (n) {\n    case 4:\n        n = 4;\n        a = a/3;\n        return 1;\n    case 6:\n        n = 8;\n        a = a/sqrt(2);\n        return 1;\n    case 8:\n        n = 6;\n        a = a*sqrt(2)/3;\n        return 1;\n    case 12:\n        n = 20;\n        a = a*(5+3*sqrt(5))/10;\n        return 1;\n    case 20:\n        n = 12;\n        a = a*(1+sqrt(5))/6;\n        return 1;\n    default:\n        return 0;\n    }\n}\n\nvoid solve() {\n    cin>>n>>a>>k;\n    while(duiou()&&--k);//不合法或操作次数完就退出循环\n    if(k)printf(\"impossible \\n\");//未操作完即为不合法\n    else printf(\"possible %d %.15lf\\n\",n,a);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# N-Particle Arts\n\n来源: 牛客多校训练营4\n算法: 位运算\n题目链接: https://ac.nowcoder.com/acm/contest/33189/N\n补完: Yes\n完成时间: July 30, 2022\n\n## 题解\n\n发现两粒子碰撞之后能量和不变, 但能量差更大.\n\n$$\n0011\\to AND~0001\\\\\n0101\\to OR~~~~~0111 \n$$\n\n则收敛的稳定值为总体能量差最大的情况.\n\n用桶提取每个粒子的每个二进制位上的能量, 然后再组合成尽可能大能量的粒子.\n\n要求输出真分数, 故不能在计算时直接除, 要保留分子$z$分母$m$到最后, 最后用$GCD$处理后输出.\n\n计算公式如下转换\n\n$$\nσ^2=\\frac1n∑_{i=1}^n(x_i−μ)^2\\\\μ=\\frac 1n∑_{i=1}^nx_i\\\\\nsum=∑_{i=1}^nx_i\n$$\n\n$$\nσ^2=\\frac1n∑_{i=1}^n(\\frac{nx_i}{n}−\\frac{sum}{n})^2\n$$\n\n$$\nσ^2=\\frac1n∑_{i=1}^n({\\frac{n^2x_i^2}{n^2}}−{\\frac{2nx_isum}{n^2}}+{\\frac{sum^2}{n^2}})\n                            \n$$\n\n$$\nσ^2=\\frac n{n^2}∑_{i=1}^n{x_i^2}−{\\frac{2sum^2}{n^2}}∑_{i=1}^nx_i+{\\frac{sum^2}{n^2}}∑_{i=1}^n1\n                            \n$$\n\n$$\nσ^2=\\frac n{n^2}∑_{i=1}^n{x_i^2}−{\\frac{2sum^2}{n^2}}+{\\frac{sum^2}{n^2}}\n                            \n$$\n\n$$\nσ^2=\\frac{n∑_{i=1}^n{x_i^2}−sum^2}{n^2}\n                            \n$$\n\n注意数据范围$n≤1e5$, $n*n$就爆int了.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll num[15];\nll temp,sum;\nll z,m;\nvoid solve(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>temp;\n        for(int j=0;j<15;j++){\n            if(temp&(1<<j))num[j]++;\n        }\n        sum += temp;\n    }\n    for(int i=0;i<n;i++){\n        int temp=0;\n        for(int j=0;j<15;j++){\n            if(num[j])temp|=(1<<j),num[j]--;\n        }\n        z += temp*temp;\n    }\n    z = z*n - sum*sum;\n    m = (long long)n*n;\n    ll g = __gcd(z,m);\n    printf(\"%lld/%lld\\n\",z/g,m/g);\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营04","published":1,"updated":"2023-10-29T06:38:00.296Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexb000dn0umcnzlhhh2","content":"<h1 id=\"l-black-hole\">L-Black Hole</h1>\r\n<p>来源: 牛客多校训练营4 算法: 模拟, 计算几何 补完: Yes 完成时间: August\r\n16, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>有一个正<span class=\"math inline\">\\(n\\)</span>面体, 初始边长为<span\r\nclass=\"math inline\">\\(a\\)</span>, 做<span\r\nclass=\"math inline\">\\(k\\)</span>次操作:</p>\r\n<p>取正<span class=\"math inline\">\\(n\\)</span>面体的中心, 求它们的凸包,\r\n得到新的正<span class=\"math inline\">\\(n&#39;\\)</span>面体.</p>\r\n<p>求最终正<span class=\"math inline\">\\(n&#39;\\)</span>面体的面数<span\r\nclass=\"math inline\">\\(n&#39;\\)</span>和边长<span\r\nclass=\"math inline\">\\(a&#39;\\)</span>.</p>\r\n<p>正<span class=\"math inline\">\\(n\\)</span>面体一共只有五种,\r\n且有以下性质</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>面</th>\r\n<th>对偶多面体</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>正四面体</td>\r\n<td>正三角形</td>\r\n<td>正四面体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正六面体</td>\r\n<td>正方形</td>\r\n<td>正八面体</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正八面体</td>\r\n<td>正三角形</td>\r\n<td>正六面体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正十二面体</td>\r\n<td>正五边形</td>\r\n<td>正二十面体</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正二十面体</td>\r\n<td>正三角形</td>\r\n<td>正十二面体</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>当知道多面体的中心到棱长的距离<span\r\nclass=\"math inline\">\\(l\\)</span>和二面角<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>时, 可以求得对偶多面体的棱长<span\r\nclass=\"math inline\">\\(a&#39;\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\na&#39;=\\sqrt{2l^2(1-\\cos\\alpha)}\r\n\\]</span></p>\r\n<p>已知多面体的面时, 就可求<span class=\"math inline\">\\(l\\)</span></p>\r\n<p>对正方形</p>\r\n<p><span class=\"math display\">\\[\r\nl=\\frac 12 a\r\n\\]</span></p>\r\n<p>对正三角形</p>\r\n<p><span class=\"math display\">\\[\r\nl=\\frac{\\sqrt 3}{6}a\r\n\\]</span></p>\r\n<p>对正五边形</p>\r\n<p><span class=\"math display\">\\[\r\nl=\\frac{\\sqrt{25+10\\sqrt{5}}}{10}a\r\n\\]</span></p>\r\n<p>多面体二面角查资料得,</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>二面角</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>正四面体</td>\r\n<td><span class=\"math inline\">\\(\\arccos{\\frac{1}{3}}\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正六面体</td>\r\n<td><span class=\"math inline\">\\(\\arccos{0}\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正八面体</td>\r\n<td><span class=\"math inline\">\\(\\arccos{-\\frac{1}{3}}\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正十二面体</td>\r\n<td><span\r\nclass=\"math inline\">\\(\\arccos{-\\frac{\\sqrt{5}}{5}}\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正二十面体</td>\r\n<td><span\r\nclass=\"math inline\">\\(\\arccos{-\\frac{\\sqrt{5}}{3}}\\)</span></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>最终有</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>对偶多面体</th>\r\n<th>对偶多面体棱长棱长</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>正四面体</td>\r\n<td>正四面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{1}{3}a\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正六面体</td>\r\n<td>正八面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{1}{\\sqrt{2}}a\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正八面体</td>\r\n<td>正六面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{\\sqrt{2}}{3}a\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正十二面体</td>\r\n<td>正二十面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{5+3\\sqrt{5}}{10}a\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正二十面体</td>\r\n<td>正十二面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{1+\\sqrt{5}}{6}a\\)</span></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"参考\">参考</h3>\r\n<p><strong><a\r\nhref=\"http://www.matrix67.com/blog/archives/6161\">高度对称的多面体和它们的对偶多面体</a></strong></p>\r\n<p>****<a\r\nhref=\"https://zhuanlan.zhihu.com/p/455979279\">五种正多面体的二面角以及体积的计算</a>****</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">duiou</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">        n = <span class=\"number\">4</span>;</span><br><span class=\"line\">        a = a/<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">        n = <span class=\"number\">8</span>;</span><br><span class=\"line\">        a = a/<span class=\"built_in\">sqrt</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">        n = <span class=\"number\">6</span>;</span><br><span class=\"line\">        a = a*<span class=\"built_in\">sqrt</span>(<span class=\"number\">2</span>)/<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">12</span>:</span><br><span class=\"line\">        n = <span class=\"number\">20</span>;</span><br><span class=\"line\">        a = a*(<span class=\"number\">5</span><span class=\"number\">+3</span>*<span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>))/<span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">20</span>:</span><br><span class=\"line\">        n = <span class=\"number\">12</span>;</span><br><span class=\"line\">        a = a*(<span class=\"number\">1</span>+<span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>))/<span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">duiou</span>()&amp;&amp;--k);<span class=\"comment\">//不合法或操作次数完就退出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;impossible \\n&quot;</span>);<span class=\"comment\">//未操作完即为不合法</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;possible %d %.15lf\\n&quot;</span>,n,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"n-particle-arts\">N-Particle Arts</h1>\r\n<p>来源: 牛客多校训练营4 算法: 位运算 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33189/N 补完: Yes 完成时间: July 30,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>发现两粒子碰撞之后能量和不变, 但能量差更大.</p>\r\n<p><span class=\"math display\">\\[\r\n0011\\to AND~0001\\\\\r\n0101\\to OR~~~~~0111\r\n\\]</span></p>\r\n<p>则收敛的稳定值为总体能量差最大的情况.</p>\r\n<p>用桶提取每个粒子的每个二进制位上的能量,\r\n然后再组合成尽可能大能量的粒子.</p>\r\n<p>要求输出真分数, 故不能在计算时直接除, 要保留分子<span\r\nclass=\"math inline\">\\(z\\)</span>分母<span\r\nclass=\"math inline\">\\(m\\)</span>到最后, 最后用<span\r\nclass=\"math inline\">\\(GCD\\)</span>处理后输出.</p>\r\n<p>计算公式如下转换</p>\r\n<p><span class=\"math display\">\\[\r\nσ^2=\\frac1n∑_{i=1}^n(x_i−μ)^2\\\\μ=\\frac 1n∑_{i=1}^nx_i\\\\\r\nsum=∑_{i=1}^nx_i\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nσ^2=\\frac1n∑_{i=1}^n(\\frac{nx_i}{n}−\\frac{sum}{n})^2\r\n\\]</span></p>\r\n<p>$$ σ^2=1n∑_{i=1}^n({}−{}+{})</p>\r\n<p>$$</p>\r\n<p>$$\r\nσ<sup>2=n{n</sup>2}∑<em>{i=1}<sup>n{x_i</sup>2}−{}∑</em>{i=1}^nx_i+{}∑_{i=1}^n1</p>\r\n<p>$$</p>\r\n<p>$$ σ<sup>2=n{n</sup>2}∑_{i=1}<sup>n{x_i</sup>2}−{}+{}</p>\r\n<p>$$</p>\r\n<p>$$ σ^2=</p>\r\n<p>$$</p>\r\n<p>注意数据范围<span class=\"math inline\">\\(n≤1e5\\)</span>, <span\r\nclass=\"math inline\">\\(n*n\\)</span>就爆int了.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">ll num[<span class=\"number\">15</span>];</span><br><span class=\"line\">ll temp,sum;</span><br><span class=\"line\">ll z,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">15</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp&amp;(<span class=\"number\">1</span>&lt;&lt;j))num[j]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum += temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">15</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num[j])temp|=(<span class=\"number\">1</span>&lt;&lt;j),num[j]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        z += temp*temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    z = z*n - sum*sum;</span><br><span class=\"line\">    m = (<span class=\"type\">long</span> <span class=\"type\">long</span>)n*n;</span><br><span class=\"line\">    ll g = __gcd(z,m);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld/%lld\\n&quot;</span>,z/g,m/g);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"l-black-hole\">L-Black Hole</h1>\r\n<p>来源: 牛客多校训练营4 算法: 模拟, 计算几何 补完: Yes 完成时间: August\r\n16, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>有一个正<span class=\"math inline\">\\(n\\)</span>面体, 初始边长为<span\r\nclass=\"math inline\">\\(a\\)</span>, 做<span\r\nclass=\"math inline\">\\(k\\)</span>次操作:</p>\r\n<p>取正<span class=\"math inline\">\\(n\\)</span>面体的中心, 求它们的凸包,\r\n得到新的正<span class=\"math inline\">\\(n&#39;\\)</span>面体.</p>\r\n<p>求最终正<span class=\"math inline\">\\(n&#39;\\)</span>面体的面数<span\r\nclass=\"math inline\">\\(n&#39;\\)</span>和边长<span\r\nclass=\"math inline\">\\(a&#39;\\)</span>.</p>\r\n<p>正<span class=\"math inline\">\\(n\\)</span>面体一共只有五种,\r\n且有以下性质</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>面</th>\r\n<th>对偶多面体</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>正四面体</td>\r\n<td>正三角形</td>\r\n<td>正四面体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正六面体</td>\r\n<td>正方形</td>\r\n<td>正八面体</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正八面体</td>\r\n<td>正三角形</td>\r\n<td>正六面体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正十二面体</td>\r\n<td>正五边形</td>\r\n<td>正二十面体</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正二十面体</td>\r\n<td>正三角形</td>\r\n<td>正十二面体</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>当知道多面体的中心到棱长的距离<span\r\nclass=\"math inline\">\\(l\\)</span>和二面角<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>时, 可以求得对偶多面体的棱长<span\r\nclass=\"math inline\">\\(a&#39;\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\na&#39;=\\sqrt{2l^2(1-\\cos\\alpha)}\r\n\\]</span></p>\r\n<p>已知多面体的面时, 就可求<span class=\"math inline\">\\(l\\)</span></p>\r\n<p>对正方形</p>\r\n<p><span class=\"math display\">\\[\r\nl=\\frac 12 a\r\n\\]</span></p>\r\n<p>对正三角形</p>\r\n<p><span class=\"math display\">\\[\r\nl=\\frac{\\sqrt 3}{6}a\r\n\\]</span></p>\r\n<p>对正五边形</p>\r\n<p><span class=\"math display\">\\[\r\nl=\\frac{\\sqrt{25+10\\sqrt{5}}}{10}a\r\n\\]</span></p>\r\n<p>多面体二面角查资料得,</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>二面角</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>正四面体</td>\r\n<td><span class=\"math inline\">\\(\\arccos{\\frac{1}{3}}\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正六面体</td>\r\n<td><span class=\"math inline\">\\(\\arccos{0}\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正八面体</td>\r\n<td><span class=\"math inline\">\\(\\arccos{-\\frac{1}{3}}\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正十二面体</td>\r\n<td><span\r\nclass=\"math inline\">\\(\\arccos{-\\frac{\\sqrt{5}}{5}}\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正二十面体</td>\r\n<td><span\r\nclass=\"math inline\">\\(\\arccos{-\\frac{\\sqrt{5}}{3}}\\)</span></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>最终有</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>对偶多面体</th>\r\n<th>对偶多面体棱长棱长</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>正四面体</td>\r\n<td>正四面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{1}{3}a\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正六面体</td>\r\n<td>正八面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{1}{\\sqrt{2}}a\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正八面体</td>\r\n<td>正六面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{\\sqrt{2}}{3}a\\)</span></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正十二面体</td>\r\n<td>正二十面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{5+3\\sqrt{5}}{10}a\\)</span></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>正二十面体</td>\r\n<td>正十二面体</td>\r\n<td><span class=\"math inline\">\\(\\frac{1+\\sqrt{5}}{6}a\\)</span></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"参考\">参考</h3>\r\n<p><strong><a\r\nhref=\"http://www.matrix67.com/blog/archives/6161\">高度对称的多面体和它们的对偶多面体</a></strong></p>\r\n<p>****<a\r\nhref=\"https://zhuanlan.zhihu.com/p/455979279\">五种正多面体的二面角以及体积的计算</a>****</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">duiou</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">        n = <span class=\"number\">4</span>;</span><br><span class=\"line\">        a = a/<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">        n = <span class=\"number\">8</span>;</span><br><span class=\"line\">        a = a/<span class=\"built_in\">sqrt</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">        n = <span class=\"number\">6</span>;</span><br><span class=\"line\">        a = a*<span class=\"built_in\">sqrt</span>(<span class=\"number\">2</span>)/<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">12</span>:</span><br><span class=\"line\">        n = <span class=\"number\">20</span>;</span><br><span class=\"line\">        a = a*(<span class=\"number\">5</span><span class=\"number\">+3</span>*<span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>))/<span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">20</span>:</span><br><span class=\"line\">        n = <span class=\"number\">12</span>;</span><br><span class=\"line\">        a = a*(<span class=\"number\">1</span>+<span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>))/<span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">duiou</span>()&amp;&amp;--k);<span class=\"comment\">//不合法或操作次数完就退出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k)<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;impossible \\n&quot;</span>);<span class=\"comment\">//未操作完即为不合法</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;possible %d %.15lf\\n&quot;</span>,n,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"n-particle-arts\">N-Particle Arts</h1>\r\n<p>来源: 牛客多校训练营4 算法: 位运算 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33189/N 补完: Yes 完成时间: July 30,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>发现两粒子碰撞之后能量和不变, 但能量差更大.</p>\r\n<p><span class=\"math display\">\\[\r\n0011\\to AND~0001\\\\\r\n0101\\to OR~~~~~0111\r\n\\]</span></p>\r\n<p>则收敛的稳定值为总体能量差最大的情况.</p>\r\n<p>用桶提取每个粒子的每个二进制位上的能量,\r\n然后再组合成尽可能大能量的粒子.</p>\r\n<p>要求输出真分数, 故不能在计算时直接除, 要保留分子<span\r\nclass=\"math inline\">\\(z\\)</span>分母<span\r\nclass=\"math inline\">\\(m\\)</span>到最后, 最后用<span\r\nclass=\"math inline\">\\(GCD\\)</span>处理后输出.</p>\r\n<p>计算公式如下转换</p>\r\n<p><span class=\"math display\">\\[\r\nσ^2=\\frac1n∑_{i=1}^n(x_i−μ)^2\\\\μ=\\frac 1n∑_{i=1}^nx_i\\\\\r\nsum=∑_{i=1}^nx_i\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nσ^2=\\frac1n∑_{i=1}^n(\\frac{nx_i}{n}−\\frac{sum}{n})^2\r\n\\]</span></p>\r\n<p>$$ σ^2=1n∑_{i=1}^n({}−{}+{})</p>\r\n<p>$$</p>\r\n<p>$$\r\nσ<sup>2=n{n</sup>2}∑<em>{i=1}<sup>n{x_i</sup>2}−{}∑</em>{i=1}^nx_i+{}∑_{i=1}^n1</p>\r\n<p>$$</p>\r\n<p>$$ σ<sup>2=n{n</sup>2}∑_{i=1}<sup>n{x_i</sup>2}−{}+{}</p>\r\n<p>$$</p>\r\n<p>$$ σ^2=</p>\r\n<p>$$</p>\r\n<p>注意数据范围<span class=\"math inline\">\\(n≤1e5\\)</span>, <span\r\nclass=\"math inline\">\\(n*n\\)</span>就爆int了.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">ll num[<span class=\"number\">15</span>];</span><br><span class=\"line\">ll temp,sum;</span><br><span class=\"line\">ll z,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">15</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp&amp;(<span class=\"number\">1</span>&lt;&lt;j))num[j]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum += temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">15</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num[j])temp|=(<span class=\"number\">1</span>&lt;&lt;j),num[j]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        z += temp*temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    z = z*n - sum*sum;</span><br><span class=\"line\">    m = (<span class=\"type\">long</span> <span class=\"type\">long</span>)n*n;</span><br><span class=\"line\">    ll g = __gcd(z,m);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld/%lld\\n&quot;</span>,z/g,m/g);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营05","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# A-Don't Starve\n\n来源: 牛客多校训练营5\n算法: 动态规划\n补完: Yes\n完成时间: August 11, 2022\n\n## 题解\n\n二维平面上有$n≤2000$个点会刷新食物, 威尔逊从原点出发收集食物, 每次前往下一个食物的距离要比上一次短, 每个食物被收集过后会重新刷新, 求最多可以收集到的食物数量.\n\n每两个点之间都可以走, 记录每条边的信息, 第$i$条边有起点$s_i$, 终点$t_i$, 长度$l_i$. \n\n从原点出发故除了食物之间的边, 还要再考虑从原点到食物的边. \n\n考虑$dp_i$表示上一步走了第$i$条边的最大收集量, 从$s_i$走到了$t_i$. \n\n则下一步$dp_j$走第$j$条边需要从$t_i$出发, 即$t_i=s_j$, 走的长度要变短, 即$l_j<l_i$\n\n$$\ndp_i=1+\\max\\{dp_j|s_j=t_i, l_j<l_i\\}\n$$\n\n从最长的边开始依个枚举, 每次$dp$以上一次数据更新, 使用滚动数组.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2005;\n\nstruct Side {\n    int s, t;\n    double l;\n    friend bool operator<(const Side &Left, const Side &Right) {\n        return Left.l > Right.l;\n    }\n};\n\nvector<Side> sides;\nint x[MAXN], y[MAXN];\n\ndouble lengthOf(double dx, double dy) {\n    return sqrt(dx*dx+dy*dy);\n}\n\nint main() {\n    int n;\n    cin>>n;\n    for (int i = 1; i <= n; i++) \n        cin>>x[i]>>y[i];\n    for (int i = 0; i <= n; i++) \n        for (int j = 1; j <= n; j++) \n            if (i!=j)\n                sides.push_back({i,j,lengthOf(x[i]-x[j],y[i]-y[j])});\n    sort(sides.begin(),sides.end());\n    vector<int> f(n+1,-0x3f3f3f3f), g(n+1,-0x3f3f3f3f);\n    f[0] = 0;\n    for (int i = 0, j = 0; i < sides.size();i = j) {\n        vector<Side>t;\n        for (j = i; j < sides.size() && sides[i].l == sides[j].l; j++)\n            t.push_back(sides[j]);\n        for (auto e : t)g[e.t] = -0x3f3f3f3f;\n        for (auto e : t)g[e.t] = max(g[e.t], f[e.s] + 1);\n        for (auto e : t)f[e.t] = max(f[e.t], g[e.t]);\n    }\n    cout << *max_element(f.begin(), f.end()) << endl;\n    return 0;\n}\n```\n# B-Watches\n\n来源: 牛客多校训练营5\n算法: 二分\n题目链接: https://ac.nowcoder.com/acm/contest/33190/B\n补完: Yes\n完成时间: August 1, 2022\n\n## **题意概括**\n\nNIO要向制造产进一批手表，需要花费的金额除了手表本身的价钱外还有税收，计算方法为如果他买了k个手表，第i个手表的价格就是手表原价+k*i，现在NIO有M美元，问NIO最多可以买多少手表？\n\n## **解题思路**\n\n采用二分的方法，求出NIO最多可以买到多少手表。\n\n1）用结构体存储手表的原价、位置以及最终价格，输入原价时即记下该手表的位置i；\n\n2）最少NIO的钱可能一个手表都不购买，最多可能购买n个，因此把0和n传入二分函数中，如果二分结果（买的手表个数）满足条件，则寻找更大的数判断是否满足条件。\n\n3）判断是否满足条件的方法为：判断函数传入手表个数k，在购买k个手表的条件下，计算每个手表的最终价格，用sort从小到大排序，选择k个价格低的累加，计算购买k个所需的总价，如果小于或等于M，则满足条件，否则不满足。\n\n**注意：**总价和手表的最终价格要用long long！！\n\n## **代码**\n\n```cpp\n#include <iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nstruct watch{\n    long long w; \n    int a;\n    int i;\n}A[1000005];\n\nbool cmp(watch x,watch y){\n\treturn x.w<y.w;\n}\n\nint check(int k)\n{\n\tlong long res=0;\n\tfor(int i=1;i<=n;i++){\n\t\tA[i].w=A[i].a+k*A[i].i;  //计算手表的最终价格\n\t}\n\tsort(A+1,A+n+1,cmp);\n\tfor(int i=1;i<=k;i++){\n\t\tres+=A[i].w;\n\t}\n\treturn res<=m;  //判断这个mid是不是符合题目条件（是否为1）;\n}\n\nint find(int min,int max) \n{\n\tint ans=-1;\n\twhile (min<=max)\n\t{\n\t\tint mid=(min+max)/2;\n\t\tif(check(mid))\n\t\t{\n\t\t\tans=mid;\n\t\t\tmin=mid+1;  //依题目的临界条件而变，此题为寻找满足条件的最大数\n\t\t}\n\t\telse max=mid-1;  //依题目的临界条件而变\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin>>n>>m;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcin>>A[i].a;\n\t\tA[i].i=i;\t    //记录手表位置\n\t}\n\tcout<<find(0,n);\n\treturn 0;\n}\n```\n# C-Bit Transmission\n\n来源: 牛客多校训练营5\n算法: 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33190/C\n补完: Yes\n完成时间: August 23, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33190/C)\n\n## 题意简述\n\n有一个01串，$3N$次询问，每次询问一个索引（从0开始），机器会返回这个索引位置的字符是不是1。\n\n如果机器只最多给一个错误回答，是否能得到唯一的串？能，输出串，不能，输出-1。\n\n## AC代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    if(n==3)cout<<\"111\";\n    else cout<<\"-1\";\n    return 0;\n}\n```\n\n~~开玩笑的，这不是正解。但这真的是AC代码。~~\n\n## 题目分析\n\n首先，”机器最多给一个错误回答“是前提。\n\n~~虽然在题目修锅之前样例没保证这个还得把和前提冲突的情况考虑进去。~~\n\n~~多考虑点情况的代码可以通过现在的样例。~~\n\n那么答复一定**不会出现**多组冲突（比如0索引报告过YES和NO，1索引也报告过YES和NO）或者一组里面多个冲突（比如0索引报告了3个YES和4个NO）的情况。\n\n也就是答案可能是**完全不冲突**（所有索引都只报告YES或者NO），或者**只存在一组冲突**的情况。\n\n并且存在冲突的那种情况中，错误答案**只报告了一次**。\n\n那正确答案就很好组成了，不冲突的索引就是报告了非0次的那个答案，冲突的索引就是报告了多次的那个答案。可以统一写成**出现次数多**的那个答案。\n\n无法判断的情况也很显然：\n\n①该索引**没有被报告**。完全无法掌握对应索引的信息。\n\n②冲突报告的索引，YES和NO**各**被汇报了一次。无法确定哪个是假信息。\n\n③所有报告不存在冲突。但有索引**只有一个报告**。不管是YES还是NO，无法确定这条信息是否是真信息。（因为找不到那个可能存在的假信息在哪）\n\n其中①和②是YES和NO都被报告了0次或1次，可以合并成两个**次数相等**来判断。\n\n判断前事先统计每个索引的01结果报告数量即可。（YES表示这里是1，NO表示这里是0）\n\n代码见完整代码。\n\n————\n\n顺便考虑一下题目”机器最多给一个错误回答“不保证的情况。\n\n也就是出现机器给出多个错误答案直接输出-1的考虑。\n\n那么也就是加上前面认为不会出现的两种情况：\n\n①存在多个冲突对。\n\n②一组冲突里两种结果都有多次报告。\n\n代码见特殊版。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint cnt[100010][2]={0};\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<3*n;i++){\n        int id;\n        string IF;\n        cin>>id>>IF;\n        if(IF[0]=='N')cnt[id][0]++;\n        else cnt[id][1]++;\n    }\n    string ans=\"\";\n    int flag=0;\n    for(int i=0;i<n;i++){\n        ans+=cnt[i][1]>cnt[i][0]?'1':'0';//存结果串\n        if(cnt[i][1]!=0&&cnt[i][0]!=0){\n            flag=1;//标记存在冲突\n        }\n        if(cnt[i][1]==cnt[i][0]){//均0次或者均1次\n            cout<<\"-1\";\n            return 0;\n        }\n    }\n    if(flag==0){//不存在冲突\n        for(int i=0;i<n;i++){\n            if(cnt[i][0]+cnt[i][1]==1){//但有索引只有一个报告\n                cout<<\"-1\"; \n                return 0;\n            }\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n## 完整代码-特殊版\n\n```cpp\n#include<iostream>\nusing namespace std;\nint cnt[100010][2]={0};\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<3*n;i++){\n        int id;\n        string IF;\n        cin>>id>>IF;\n        if(IF[0]=='N')cnt[id][0]++;\n        else cnt[id][1]++;\n    }\n    string ans=\"\";\n    int flag=0;\n    for(int i=0;i<n;i++){\n        ans+=cnt[i][1]>cnt[i][0]?'1':'0';\n        if(cnt[i][1]!=0&&cnt[i][0]!=0){\n            if(flag){\n\t\t\t\t\t\t//冲突存在标记的另一个使用处：出现第二个冲突。\n                cout<<\"-1\";\n                return 0;\n            }\n            flag=1;\n        }\n        if(cnt[i][1]==cnt[i][0]){\n            cout<<\"-1\";\n            return 0;\n        }\n        if(cnt[i][1]>=2&&cnt[i][0]>=2){\n\t\t\t\t\t\t//一组冲突多个报告的情况\n            cout<<\"-1\";\n            return 0;\n        }\n    }\n    if(flag==0){\n        for(int i=0;i<n;i++){\n            if(cnt[i][0]+cnt[i][1]==1){\n                cout<<\"-1\"; \n                return 0;\n            }\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n# D-Birds in the tree\n\n来源: 牛客多校训练营5\n算法: DFS, 动态规划, 树形DP\n题目链接: https://ac.nowcoder.com/acm/contest/33190/D\n补完: Yes\n完成时间: August 11, 2022\n\n## 题解\n\n给有$n$个节点的树, 每个节点具有颜色$0$或颜色$1$. 求其有多少联通子图, 满足度数为$1$的节点颜色相同. \n\n树上求方案树考虑树形DP\n\n设$dp_{u,c}$为在以$x$为根的子树内, 有多少包含$u$的连通子图, 叶结点(不包括$u$)的颜色为$c$的方案数.\n\n对一个父节点$u$的某一个子节点$v_i$的方案数都有选和不选两种情况, 故共有$dp[v_i][c]+1$种方案.\n\n对一个父节点$u$的所有个子节点$v_i$, 每个子节点的方案数都可以独立选取, 故父节点的方案数为所有子节点方案数的乘积. \n\n$$\ndp'[u][c]=\\prod_v(1+dp[v][c])\n$$\n\n当$u$不选取的任何子树数时, $u$本身也是一个叶结点, 考虑$u$的颜色, 若此时其颜色不为$c$则为无效方案数, 需要减去. \n\n$$\ndp[u][c]=\\prod_v(1+dp[v][c])-(a[u]!=c)\n$$\n\n统计答案时统计各个结点的方案数, 另外考虑当一个结点仅选取一个子树时,  $u$本身也是一个叶结点, 考虑$u$的颜色, 若此时其颜色不为$c$则为无效方案数, 需要减去. \n\n$$\nans_c=\\sum_u\\left(dp[u][c]-(a[u]!=c)\\sum dp[v][c]\\right)\n$$\n\n最后加和答案即可\n\n$$\nAns=ans_0+ans_1\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 1000000007;\nconst int MAXN = 300005;\n\nint n;\nchar a[MAXN];\nll Ans = 0;\nvector<int> e[MAXN];\nll dp[MAXN][2];\n\nll add(ll a, ll b) {\n    return (a+b+P)%P;\n}\nll mul(ll a, ll b) {\n    return (a*b)%P;\n}\n\nvoid dfs(int u, int f, int c) {\n    ll prod = 1, sum = 0;\n    for (auto v: e[u]) {\n        if (v==f)continue;\n        dfs(v,u,c);\n        prod = mul(prod, 1+dp[v][c]);\n        sum  = add(sum ,   dp[v][c]);\n    }\n    dp[u][c] = add(prod, -(a[u]!=c));\n    Ans = add(Ans, dp[u][c]-(a[u]!=c)*sum);\n}\n\nvoid solve() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        char c; \n        cin>>c;\n        a[i] = c - '0';\n    }\n    for (int i = 1; i < n; i++) {\n        int x, y;\n        cin>>x>>y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    dfs(1,0,0);\n    dfs(1,0,1);\n    cout<<Ans;\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# F-A Stack of CDs\n\n来源: 牛客多校训练营5\n算法: 计算几何\n题目链接: https://ac.nowcoder.com/acm/contest/33190/F\n补完: Yes\n完成时间: August 2, 2022\n\n## 题解\n\n有$n$张CD叠在平面上, 求可见的CD弧长(不是求总的投影的边缘长). \n\n后放置的圆会压到先放置的圆, 将先放置的圆的部分弧压住看不到. \n\n以样例为例:\n\n![样例.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25A0%25B7%25E4%25BE%258B.jpg)\n\n放置第一圆, 在最底下.\n\n放置第二圆, 此时小圆没有压到任何弧. 也没有被压它自身是可见的.\n\n放置第三圆, 此时第二圆完全被第三圆覆盖, 标红表示不可见.\n\n同时第一圆的右上角有部分弧被第三圆覆盖, 标红表示不可见.\n\n发现后放置的圆有可能对先放置的圆有影响, 会将其完全覆盖, 或者覆盖部分弧长. \n\n为求剩余可见弧长, 可以记录此圆是否被完全覆盖, 若为被完全覆盖则记录被覆盖了多少弧长. 最后从周长中减去被覆盖的弧长即为可见弧长. 统计所有圆的可见弧长即为答案.\n\n由于后续可能有多个圆对它覆盖, 这些弧之间可能有重叠, 所以不能单纯记录被覆盖弧长的长度, 而是要记录被覆盖弧长的起始点, 最后区间合并统计被覆盖弧长的总长度. 记录圆上起始点可以使用极角. \n\n先用余弦定理求弧长圆心角的绝对值\n\n$$\n\\cos \\alpha=\\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\n$$\n\n$$\n\\alpha=\\arccos \\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\n$$\n\n![求alpha.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582alpha.jpg)\n\n再通过正切求出圆心角相对极轴的偏移量\n\n$$\n\\tan\\beta=\\frac{y_b-y_a}{x_b-x_a}\n$$\n\n$$\n\\beta=\\arctan\\frac{y_b-y_a}{x_b-x_a}\n$$\n\n![求beta.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582beta.jpg)\n\n相加之后可得一条弧的起始点极角\n\n![求se.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582se.jpg)\n\n这样处理后的极角可能落在$[-2\\pi,2\\pi]$区间内, 而一个圆的正确区间是$[0,2\\pi]$, 可以通过让负数直接$+2\\pi$落回正确区间. \n\n如果被覆盖弧越过零点, 应该拆成两段处理.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define PI M_PI\nusing namespace std;\nconst int MAXN = 1005;\nstruct arc{\n    double start;\n    double end;\n};\nbool cmp(arc a,arc b){\n    return a.start<b.start || (a.start==b.start&&a.end>b.end);\n}\nstruct circle{\n    double x;\n    double y;\n    double radius;\n    vector<arc> covered;\n    bool alive = true;\n}Circle[MAXN];\ndouble sqr(double x){\n\treturn x*x;\n}\nvoid analyseCoverWith(circle &a,circle b){\n    if(!a.alive)return ;\n    double deltax = b.x-a.x;\n    double deltay = b.y-a.y;\n    double dis = sqrt(sqr(deltax)+sqr(deltay));\n    if(dis>=a.radius+b.radius)                 return; //外离外切\n    if(dis+b.radius<=a.radius)                 return; //上者小无覆盖\n    if(dis+a.radius<=b.radius){a.alive = false;return;}//上者大全覆盖\n    double alpha = acos((sqr(a.radius)+sqr(dis)-sqr(b.radius))/(2*a.radius*dis));\n    double beta  = atan2(deltay,deltax);\n    double start = ((beta-alpha)>0)?(beta-alpha):(beta-alpha+2*PI);\n    double end   = ((beta+alpha)>0)?(beta+alpha):(beta+alpha+2*PI);\n    if(start<=end){\n        a.covered.push_back({start, end});\n    }\n    else{\n        a.covered.push_back({  0  , end});\n        a.covered.push_back({start,2*PI});\n    }\n}\ndouble aliveArcOf(circle a){\n    if(!a.alive)return 0;\n    Circle[i].covered.push_back({  0 ,  0 });\n    Circle[i].covered.push_back({2*PI,2*PI});\n    sort(a.covered.begin(),a.covered.end(),cmp);\n    double lim = 0, temp = 0;\n    for(auto arc: a.covered){\n        if(arc.start>lim)\n            temp+=arc.start-lim;\n        lim = max(lim,arc.end);\n    }\n    return temp*a.radius;\n}\nvoid solve(){\n    int n;\n    double ans = 0;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>Circle[i].x>>Circle[i].y>>Circle[i].radius;\n    }\n    for(int i = 1; i<=n; i++){\n        for(int j = i+1; j<=n; j++){\n            analyseCoverWith(Circle[i],Circle[j]);\n        }\n        ans += aliveArcOf(Circle[i]);\n    }\n    printf(\"%.15lf\",ans);\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# G-KFC Crazy Thursday\n\n来源: 牛客多校训练营5\n算法: 回文自动机, 字符串\n题目链接: https://ac.nowcoder.com/acm/contest/33190/G\n补完: Yes\n完成时间: August 3, 2022\n\n## 题意\n\n给定一个字符串，分别输出以’k‘、’f‘、’c‘结尾的回文子串个数。\n\n## 解法\n\n套用**回文自动机**模板，在字符串存入回文树的过程中加上一层判断：当遇到’k‘、’f‘、’c‘时，分别计算出以该字符结尾的回文串的个数，并记录累加结果\n\n当字符串全部存入后，也就算出了所有以’k‘、’f‘、’c‘结尾的回文子串个数\n\n## 代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=500010;\nchar s[N];\nint len[N],n,num[N],fail[N],last,cur,pos,trie[N][26],tot=1;\nlong long k,f,c;\nint getfail(int x,int i)\n{\n\twhile(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];\n\treturn x;\n}\nint main()\n{ \n    cin>>n;\n\t  scanf(\"%s\",s);\n    fail[0]=1;len[1]=-1;\n    for(int i=0;i<=n-1;i++){ \n    \tpos=getfail(cur,i);\n        //找到cur的fail链中能匹配i位的最长回文后缀\n      if(!trie[pos][s[i]-'a']){\n        \tfail[++tot]=trie[getfail(fail[pos],i)][s[i]-'a'];\n        \ttrie[pos][s[i]-'a']=tot;\n        \tlen[tot]=len[pos]+2;\n          num[tot]=num[fail[tot]]+1;\n\t\t   }//不存在建立点，存在直接走过去\n       cur=trie[pos][s[i]-'a'];\n       last=num[cur];\n       if(s[i]=='k'){\n\t       \t k+=last;\n\t      }    \n\t     if(s[i]=='f'){\n    \t     f+=last;\n        }\n    \t if(s[i]=='c'){\n\t \t       c+=last;\n\t      }\n\t   }\n    cout<<k<<' '<<f<<' '<<c; \n\t  return 0;\n}\n```\n# H-Cutting Papers\n\n来源: 牛客多校训练营5\n算法: 计算几何\n题目链接: https://ac.nowcoder.com/acm/contest/33190/H\n补完: Yes\n完成时间: August 1, 2022\n\n## 题解\n\n当$x>0\\&\\&y>0$时, $x+y+x+y≤n$, 即为$x+y≤n/2$\n\n当$x<0\\&\\&y<0$时, $x+y+x+y≥n$, 即为$x+y≥n/2$\n\n当$x>0\\&\\&y<0$时, $|x|+|y|+(|x|-|y|)≤n$, 即为$|x|≤n/2$\n\n当$x<0\\&\\&y>0$时, $|x|+|y|+(|y|-|x|)≤n$, 即为$|y|≤n/2$\n\n对应六条边\n\n半径为$n/2$的圆\n\n![Untitled](H-Cutting%20Papers%200d73eb7a678047b79cc6a3b8f5cd04c8/Untitled.png)\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid solve(){\n    double n;\n    cin>>n;\n    double r = n/2;\n    double ans = r*r*M_PI/2+r*r*2;\n    printf(\"%.15lf\",ans);\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# K-Headpho\n\n来源: 牛客多校训练营5\n算法: 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33190/K\n补完: Yes\n完成时间: August 26, 2022\n\n## 题意\n\n- NIO和妹妹拿耳机\n- 共有$n$对耳机，妹妹已经拿了$k$对\n- 剩下的耳机两人分，NIO一只一只拿\n- 问剩下的耳机中NIO至少要拿多少只才能拥有比妹妹多对的耳机？\n\n## 解法\n\n- NIO最少要拿到$k+1$对耳机，此时总的耳机对数就是$k+k+1$，若$k+k+1>n$，说明NIO拿不到$k+1$对，输出$-1$\n- 因为NIO是一只一只拿的，所以NIO拿的比妹妹多的最坏情况就是，NIO拿了一半多一个，这样妹妹就凑不到一半的耳机了\n\n## 代码\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main(){\n    int n,k,ans=0;\n    cin>>n>>k;\n    ans=k+1;\n    if(ans+k>n){\n        ans=-1;\n    }else {\n       ans=n+1;\n    }\n    cout<<ans;\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营05.md","raw":"---\ntitle: 2022牛客多校训练营05\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# A-Don't Starve\n\n来源: 牛客多校训练营5\n算法: 动态规划\n补完: Yes\n完成时间: August 11, 2022\n\n## 题解\n\n二维平面上有$n≤2000$个点会刷新食物, 威尔逊从原点出发收集食物, 每次前往下一个食物的距离要比上一次短, 每个食物被收集过后会重新刷新, 求最多可以收集到的食物数量.\n\n每两个点之间都可以走, 记录每条边的信息, 第$i$条边有起点$s_i$, 终点$t_i$, 长度$l_i$. \n\n从原点出发故除了食物之间的边, 还要再考虑从原点到食物的边. \n\n考虑$dp_i$表示上一步走了第$i$条边的最大收集量, 从$s_i$走到了$t_i$. \n\n则下一步$dp_j$走第$j$条边需要从$t_i$出发, 即$t_i=s_j$, 走的长度要变短, 即$l_j<l_i$\n\n$$\ndp_i=1+\\max\\{dp_j|s_j=t_i, l_j<l_i\\}\n$$\n\n从最长的边开始依个枚举, 每次$dp$以上一次数据更新, 使用滚动数组.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2005;\n\nstruct Side {\n    int s, t;\n    double l;\n    friend bool operator<(const Side &Left, const Side &Right) {\n        return Left.l > Right.l;\n    }\n};\n\nvector<Side> sides;\nint x[MAXN], y[MAXN];\n\ndouble lengthOf(double dx, double dy) {\n    return sqrt(dx*dx+dy*dy);\n}\n\nint main() {\n    int n;\n    cin>>n;\n    for (int i = 1; i <= n; i++) \n        cin>>x[i]>>y[i];\n    for (int i = 0; i <= n; i++) \n        for (int j = 1; j <= n; j++) \n            if (i!=j)\n                sides.push_back({i,j,lengthOf(x[i]-x[j],y[i]-y[j])});\n    sort(sides.begin(),sides.end());\n    vector<int> f(n+1,-0x3f3f3f3f), g(n+1,-0x3f3f3f3f);\n    f[0] = 0;\n    for (int i = 0, j = 0; i < sides.size();i = j) {\n        vector<Side>t;\n        for (j = i; j < sides.size() && sides[i].l == sides[j].l; j++)\n            t.push_back(sides[j]);\n        for (auto e : t)g[e.t] = -0x3f3f3f3f;\n        for (auto e : t)g[e.t] = max(g[e.t], f[e.s] + 1);\n        for (auto e : t)f[e.t] = max(f[e.t], g[e.t]);\n    }\n    cout << *max_element(f.begin(), f.end()) << endl;\n    return 0;\n}\n```\n# B-Watches\n\n来源: 牛客多校训练营5\n算法: 二分\n题目链接: https://ac.nowcoder.com/acm/contest/33190/B\n补完: Yes\n完成时间: August 1, 2022\n\n## **题意概括**\n\nNIO要向制造产进一批手表，需要花费的金额除了手表本身的价钱外还有税收，计算方法为如果他买了k个手表，第i个手表的价格就是手表原价+k*i，现在NIO有M美元，问NIO最多可以买多少手表？\n\n## **解题思路**\n\n采用二分的方法，求出NIO最多可以买到多少手表。\n\n1）用结构体存储手表的原价、位置以及最终价格，输入原价时即记下该手表的位置i；\n\n2）最少NIO的钱可能一个手表都不购买，最多可能购买n个，因此把0和n传入二分函数中，如果二分结果（买的手表个数）满足条件，则寻找更大的数判断是否满足条件。\n\n3）判断是否满足条件的方法为：判断函数传入手表个数k，在购买k个手表的条件下，计算每个手表的最终价格，用sort从小到大排序，选择k个价格低的累加，计算购买k个所需的总价，如果小于或等于M，则满足条件，否则不满足。\n\n**注意：**总价和手表的最终价格要用long long！！\n\n## **代码**\n\n```cpp\n#include <iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nstruct watch{\n    long long w; \n    int a;\n    int i;\n}A[1000005];\n\nbool cmp(watch x,watch y){\n\treturn x.w<y.w;\n}\n\nint check(int k)\n{\n\tlong long res=0;\n\tfor(int i=1;i<=n;i++){\n\t\tA[i].w=A[i].a+k*A[i].i;  //计算手表的最终价格\n\t}\n\tsort(A+1,A+n+1,cmp);\n\tfor(int i=1;i<=k;i++){\n\t\tres+=A[i].w;\n\t}\n\treturn res<=m;  //判断这个mid是不是符合题目条件（是否为1）;\n}\n\nint find(int min,int max) \n{\n\tint ans=-1;\n\twhile (min<=max)\n\t{\n\t\tint mid=(min+max)/2;\n\t\tif(check(mid))\n\t\t{\n\t\t\tans=mid;\n\t\t\tmin=mid+1;  //依题目的临界条件而变，此题为寻找满足条件的最大数\n\t\t}\n\t\telse max=mid-1;  //依题目的临界条件而变\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin>>n>>m;\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcin>>A[i].a;\n\t\tA[i].i=i;\t    //记录手表位置\n\t}\n\tcout<<find(0,n);\n\treturn 0;\n}\n```\n# C-Bit Transmission\n\n来源: 牛客多校训练营5\n算法: 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33190/C\n补完: Yes\n完成时间: August 23, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33190/C)\n\n## 题意简述\n\n有一个01串，$3N$次询问，每次询问一个索引（从0开始），机器会返回这个索引位置的字符是不是1。\n\n如果机器只最多给一个错误回答，是否能得到唯一的串？能，输出串，不能，输出-1。\n\n## AC代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    if(n==3)cout<<\"111\";\n    else cout<<\"-1\";\n    return 0;\n}\n```\n\n~~开玩笑的，这不是正解。但这真的是AC代码。~~\n\n## 题目分析\n\n首先，”机器最多给一个错误回答“是前提。\n\n~~虽然在题目修锅之前样例没保证这个还得把和前提冲突的情况考虑进去。~~\n\n~~多考虑点情况的代码可以通过现在的样例。~~\n\n那么答复一定**不会出现**多组冲突（比如0索引报告过YES和NO，1索引也报告过YES和NO）或者一组里面多个冲突（比如0索引报告了3个YES和4个NO）的情况。\n\n也就是答案可能是**完全不冲突**（所有索引都只报告YES或者NO），或者**只存在一组冲突**的情况。\n\n并且存在冲突的那种情况中，错误答案**只报告了一次**。\n\n那正确答案就很好组成了，不冲突的索引就是报告了非0次的那个答案，冲突的索引就是报告了多次的那个答案。可以统一写成**出现次数多**的那个答案。\n\n无法判断的情况也很显然：\n\n①该索引**没有被报告**。完全无法掌握对应索引的信息。\n\n②冲突报告的索引，YES和NO**各**被汇报了一次。无法确定哪个是假信息。\n\n③所有报告不存在冲突。但有索引**只有一个报告**。不管是YES还是NO，无法确定这条信息是否是真信息。（因为找不到那个可能存在的假信息在哪）\n\n其中①和②是YES和NO都被报告了0次或1次，可以合并成两个**次数相等**来判断。\n\n判断前事先统计每个索引的01结果报告数量即可。（YES表示这里是1，NO表示这里是0）\n\n代码见完整代码。\n\n————\n\n顺便考虑一下题目”机器最多给一个错误回答“不保证的情况。\n\n也就是出现机器给出多个错误答案直接输出-1的考虑。\n\n那么也就是加上前面认为不会出现的两种情况：\n\n①存在多个冲突对。\n\n②一组冲突里两种结果都有多次报告。\n\n代码见特殊版。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint cnt[100010][2]={0};\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<3*n;i++){\n        int id;\n        string IF;\n        cin>>id>>IF;\n        if(IF[0]=='N')cnt[id][0]++;\n        else cnt[id][1]++;\n    }\n    string ans=\"\";\n    int flag=0;\n    for(int i=0;i<n;i++){\n        ans+=cnt[i][1]>cnt[i][0]?'1':'0';//存结果串\n        if(cnt[i][1]!=0&&cnt[i][0]!=0){\n            flag=1;//标记存在冲突\n        }\n        if(cnt[i][1]==cnt[i][0]){//均0次或者均1次\n            cout<<\"-1\";\n            return 0;\n        }\n    }\n    if(flag==0){//不存在冲突\n        for(int i=0;i<n;i++){\n            if(cnt[i][0]+cnt[i][1]==1){//但有索引只有一个报告\n                cout<<\"-1\"; \n                return 0;\n            }\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n## 完整代码-特殊版\n\n```cpp\n#include<iostream>\nusing namespace std;\nint cnt[100010][2]={0};\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<3*n;i++){\n        int id;\n        string IF;\n        cin>>id>>IF;\n        if(IF[0]=='N')cnt[id][0]++;\n        else cnt[id][1]++;\n    }\n    string ans=\"\";\n    int flag=0;\n    for(int i=0;i<n;i++){\n        ans+=cnt[i][1]>cnt[i][0]?'1':'0';\n        if(cnt[i][1]!=0&&cnt[i][0]!=0){\n            if(flag){\n\t\t\t\t\t\t//冲突存在标记的另一个使用处：出现第二个冲突。\n                cout<<\"-1\";\n                return 0;\n            }\n            flag=1;\n        }\n        if(cnt[i][1]==cnt[i][0]){\n            cout<<\"-1\";\n            return 0;\n        }\n        if(cnt[i][1]>=2&&cnt[i][0]>=2){\n\t\t\t\t\t\t//一组冲突多个报告的情况\n            cout<<\"-1\";\n            return 0;\n        }\n    }\n    if(flag==0){\n        for(int i=0;i<n;i++){\n            if(cnt[i][0]+cnt[i][1]==1){\n                cout<<\"-1\"; \n                return 0;\n            }\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n# D-Birds in the tree\n\n来源: 牛客多校训练营5\n算法: DFS, 动态规划, 树形DP\n题目链接: https://ac.nowcoder.com/acm/contest/33190/D\n补完: Yes\n完成时间: August 11, 2022\n\n## 题解\n\n给有$n$个节点的树, 每个节点具有颜色$0$或颜色$1$. 求其有多少联通子图, 满足度数为$1$的节点颜色相同. \n\n树上求方案树考虑树形DP\n\n设$dp_{u,c}$为在以$x$为根的子树内, 有多少包含$u$的连通子图, 叶结点(不包括$u$)的颜色为$c$的方案数.\n\n对一个父节点$u$的某一个子节点$v_i$的方案数都有选和不选两种情况, 故共有$dp[v_i][c]+1$种方案.\n\n对一个父节点$u$的所有个子节点$v_i$, 每个子节点的方案数都可以独立选取, 故父节点的方案数为所有子节点方案数的乘积. \n\n$$\ndp'[u][c]=\\prod_v(1+dp[v][c])\n$$\n\n当$u$不选取的任何子树数时, $u$本身也是一个叶结点, 考虑$u$的颜色, 若此时其颜色不为$c$则为无效方案数, 需要减去. \n\n$$\ndp[u][c]=\\prod_v(1+dp[v][c])-(a[u]!=c)\n$$\n\n统计答案时统计各个结点的方案数, 另外考虑当一个结点仅选取一个子树时,  $u$本身也是一个叶结点, 考虑$u$的颜色, 若此时其颜色不为$c$则为无效方案数, 需要减去. \n\n$$\nans_c=\\sum_u\\left(dp[u][c]-(a[u]!=c)\\sum dp[v][c]\\right)\n$$\n\n最后加和答案即可\n\n$$\nAns=ans_0+ans_1\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 1000000007;\nconst int MAXN = 300005;\n\nint n;\nchar a[MAXN];\nll Ans = 0;\nvector<int> e[MAXN];\nll dp[MAXN][2];\n\nll add(ll a, ll b) {\n    return (a+b+P)%P;\n}\nll mul(ll a, ll b) {\n    return (a*b)%P;\n}\n\nvoid dfs(int u, int f, int c) {\n    ll prod = 1, sum = 0;\n    for (auto v: e[u]) {\n        if (v==f)continue;\n        dfs(v,u,c);\n        prod = mul(prod, 1+dp[v][c]);\n        sum  = add(sum ,   dp[v][c]);\n    }\n    dp[u][c] = add(prod, -(a[u]!=c));\n    Ans = add(Ans, dp[u][c]-(a[u]!=c)*sum);\n}\n\nvoid solve() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        char c; \n        cin>>c;\n        a[i] = c - '0';\n    }\n    for (int i = 1; i < n; i++) {\n        int x, y;\n        cin>>x>>y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    dfs(1,0,0);\n    dfs(1,0,1);\n    cout<<Ans;\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# F-A Stack of CDs\n\n来源: 牛客多校训练营5\n算法: 计算几何\n题目链接: https://ac.nowcoder.com/acm/contest/33190/F\n补完: Yes\n完成时间: August 2, 2022\n\n## 题解\n\n有$n$张CD叠在平面上, 求可见的CD弧长(不是求总的投影的边缘长). \n\n后放置的圆会压到先放置的圆, 将先放置的圆的部分弧压住看不到. \n\n以样例为例:\n\n![样例.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25A0%25B7%25E4%25BE%258B.jpg)\n\n放置第一圆, 在最底下.\n\n放置第二圆, 此时小圆没有压到任何弧. 也没有被压它自身是可见的.\n\n放置第三圆, 此时第二圆完全被第三圆覆盖, 标红表示不可见.\n\n同时第一圆的右上角有部分弧被第三圆覆盖, 标红表示不可见.\n\n发现后放置的圆有可能对先放置的圆有影响, 会将其完全覆盖, 或者覆盖部分弧长. \n\n为求剩余可见弧长, 可以记录此圆是否被完全覆盖, 若为被完全覆盖则记录被覆盖了多少弧长. 最后从周长中减去被覆盖的弧长即为可见弧长. 统计所有圆的可见弧长即为答案.\n\n由于后续可能有多个圆对它覆盖, 这些弧之间可能有重叠, 所以不能单纯记录被覆盖弧长的长度, 而是要记录被覆盖弧长的起始点, 最后区间合并统计被覆盖弧长的总长度. 记录圆上起始点可以使用极角. \n\n先用余弦定理求弧长圆心角的绝对值\n\n$$\n\\cos \\alpha=\\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\n$$\n\n$$\n\\alpha=\\arccos \\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\n$$\n\n![求alpha.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582alpha.jpg)\n\n再通过正切求出圆心角相对极轴的偏移量\n\n$$\n\\tan\\beta=\\frac{y_b-y_a}{x_b-x_a}\n$$\n\n$$\n\\beta=\\arctan\\frac{y_b-y_a}{x_b-x_a}\n$$\n\n![求beta.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582beta.jpg)\n\n相加之后可得一条弧的起始点极角\n\n![求se.JPG](F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582se.jpg)\n\n这样处理后的极角可能落在$[-2\\pi,2\\pi]$区间内, 而一个圆的正确区间是$[0,2\\pi]$, 可以通过让负数直接$+2\\pi$落回正确区间. \n\n如果被覆盖弧越过零点, 应该拆成两段处理.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define PI M_PI\nusing namespace std;\nconst int MAXN = 1005;\nstruct arc{\n    double start;\n    double end;\n};\nbool cmp(arc a,arc b){\n    return a.start<b.start || (a.start==b.start&&a.end>b.end);\n}\nstruct circle{\n    double x;\n    double y;\n    double radius;\n    vector<arc> covered;\n    bool alive = true;\n}Circle[MAXN];\ndouble sqr(double x){\n\treturn x*x;\n}\nvoid analyseCoverWith(circle &a,circle b){\n    if(!a.alive)return ;\n    double deltax = b.x-a.x;\n    double deltay = b.y-a.y;\n    double dis = sqrt(sqr(deltax)+sqr(deltay));\n    if(dis>=a.radius+b.radius)                 return; //外离外切\n    if(dis+b.radius<=a.radius)                 return; //上者小无覆盖\n    if(dis+a.radius<=b.radius){a.alive = false;return;}//上者大全覆盖\n    double alpha = acos((sqr(a.radius)+sqr(dis)-sqr(b.radius))/(2*a.radius*dis));\n    double beta  = atan2(deltay,deltax);\n    double start = ((beta-alpha)>0)?(beta-alpha):(beta-alpha+2*PI);\n    double end   = ((beta+alpha)>0)?(beta+alpha):(beta+alpha+2*PI);\n    if(start<=end){\n        a.covered.push_back({start, end});\n    }\n    else{\n        a.covered.push_back({  0  , end});\n        a.covered.push_back({start,2*PI});\n    }\n}\ndouble aliveArcOf(circle a){\n    if(!a.alive)return 0;\n    Circle[i].covered.push_back({  0 ,  0 });\n    Circle[i].covered.push_back({2*PI,2*PI});\n    sort(a.covered.begin(),a.covered.end(),cmp);\n    double lim = 0, temp = 0;\n    for(auto arc: a.covered){\n        if(arc.start>lim)\n            temp+=arc.start-lim;\n        lim = max(lim,arc.end);\n    }\n    return temp*a.radius;\n}\nvoid solve(){\n    int n;\n    double ans = 0;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>Circle[i].x>>Circle[i].y>>Circle[i].radius;\n    }\n    for(int i = 1; i<=n; i++){\n        for(int j = i+1; j<=n; j++){\n            analyseCoverWith(Circle[i],Circle[j]);\n        }\n        ans += aliveArcOf(Circle[i]);\n    }\n    printf(\"%.15lf\",ans);\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# G-KFC Crazy Thursday\n\n来源: 牛客多校训练营5\n算法: 回文自动机, 字符串\n题目链接: https://ac.nowcoder.com/acm/contest/33190/G\n补完: Yes\n完成时间: August 3, 2022\n\n## 题意\n\n给定一个字符串，分别输出以’k‘、’f‘、’c‘结尾的回文子串个数。\n\n## 解法\n\n套用**回文自动机**模板，在字符串存入回文树的过程中加上一层判断：当遇到’k‘、’f‘、’c‘时，分别计算出以该字符结尾的回文串的个数，并记录累加结果\n\n当字符串全部存入后，也就算出了所有以’k‘、’f‘、’c‘结尾的回文子串个数\n\n## 代码\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=500010;\nchar s[N];\nint len[N],n,num[N],fail[N],last,cur,pos,trie[N][26],tot=1;\nlong long k,f,c;\nint getfail(int x,int i)\n{\n\twhile(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];\n\treturn x;\n}\nint main()\n{ \n    cin>>n;\n\t  scanf(\"%s\",s);\n    fail[0]=1;len[1]=-1;\n    for(int i=0;i<=n-1;i++){ \n    \tpos=getfail(cur,i);\n        //找到cur的fail链中能匹配i位的最长回文后缀\n      if(!trie[pos][s[i]-'a']){\n        \tfail[++tot]=trie[getfail(fail[pos],i)][s[i]-'a'];\n        \ttrie[pos][s[i]-'a']=tot;\n        \tlen[tot]=len[pos]+2;\n          num[tot]=num[fail[tot]]+1;\n\t\t   }//不存在建立点，存在直接走过去\n       cur=trie[pos][s[i]-'a'];\n       last=num[cur];\n       if(s[i]=='k'){\n\t       \t k+=last;\n\t      }    \n\t     if(s[i]=='f'){\n    \t     f+=last;\n        }\n    \t if(s[i]=='c'){\n\t \t       c+=last;\n\t      }\n\t   }\n    cout<<k<<' '<<f<<' '<<c; \n\t  return 0;\n}\n```\n# H-Cutting Papers\n\n来源: 牛客多校训练营5\n算法: 计算几何\n题目链接: https://ac.nowcoder.com/acm/contest/33190/H\n补完: Yes\n完成时间: August 1, 2022\n\n## 题解\n\n当$x>0\\&\\&y>0$时, $x+y+x+y≤n$, 即为$x+y≤n/2$\n\n当$x<0\\&\\&y<0$时, $x+y+x+y≥n$, 即为$x+y≥n/2$\n\n当$x>0\\&\\&y<0$时, $|x|+|y|+(|x|-|y|)≤n$, 即为$|x|≤n/2$\n\n当$x<0\\&\\&y>0$时, $|x|+|y|+(|y|-|x|)≤n$, 即为$|y|≤n/2$\n\n对应六条边\n\n半径为$n/2$的圆\n\n![Untitled](H-Cutting%20Papers%200d73eb7a678047b79cc6a3b8f5cd04c8/Untitled.png)\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid solve(){\n    double n;\n    cin>>n;\n    double r = n/2;\n    double ans = r*r*M_PI/2+r*r*2;\n    printf(\"%.15lf\",ans);\n}\nint main(){\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# K-Headpho\n\n来源: 牛客多校训练营5\n算法: 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33190/K\n补完: Yes\n完成时间: August 26, 2022\n\n## 题意\n\n- NIO和妹妹拿耳机\n- 共有$n$对耳机，妹妹已经拿了$k$对\n- 剩下的耳机两人分，NIO一只一只拿\n- 问剩下的耳机中NIO至少要拿多少只才能拥有比妹妹多对的耳机？\n\n## 解法\n\n- NIO最少要拿到$k+1$对耳机，此时总的耳机对数就是$k+k+1$，若$k+k+1>n$，说明NIO拿不到$k+1$对，输出$-1$\n- 因为NIO是一只一只拿的，所以NIO拿的比妹妹多的最坏情况就是，NIO拿了一半多一个，这样妹妹就凑不到一半的耳机了\n\n## 代码\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main(){\n    int n,k,ans=0;\n    cin>>n>>k;\n    ans=k+1;\n    if(ans+k>n){\n        ans=-1;\n    }else {\n       ans=n+1;\n    }\n    cout<<ans;\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营05","published":1,"updated":"2023-10-29T06:36:23.080Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexc000en0umeduj9a10","content":"<h1 id=\"a-dont-starve\">A-Don't Starve</h1>\r\n<p>来源: 牛客多校训练营5 算法: 动态规划 补完: Yes 完成时间: August 11,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>二维平面上有<span\r\nclass=\"math inline\">\\(n≤2000\\)</span>个点会刷新食物,\r\n威尔逊从原点出发收集食物, 每次前往下一个食物的距离要比上一次短,\r\n每个食物被收集过后会重新刷新, 求最多可以收集到的食物数量.</p>\r\n<p>每两个点之间都可以走, 记录每条边的信息, 第<span\r\nclass=\"math inline\">\\(i\\)</span>条边有起点<span\r\nclass=\"math inline\">\\(s_i\\)</span>, 终点<span\r\nclass=\"math inline\">\\(t_i\\)</span>, 长度<span\r\nclass=\"math inline\">\\(l_i\\)</span>.</p>\r\n<p>从原点出发故除了食物之间的边, 还要再考虑从原点到食物的边.</p>\r\n<p>考虑<span class=\"math inline\">\\(dp_i\\)</span>表示上一步走了第<span\r\nclass=\"math inline\">\\(i\\)</span>条边的最大收集量, 从<span\r\nclass=\"math inline\">\\(s_i\\)</span>走到了<span\r\nclass=\"math inline\">\\(t_i\\)</span>.</p>\r\n<p>则下一步<span class=\"math inline\">\\(dp_j\\)</span>走第<span\r\nclass=\"math inline\">\\(j\\)</span>条边需要从<span\r\nclass=\"math inline\">\\(t_i\\)</span>出发, 即<span\r\nclass=\"math inline\">\\(t_i=s_j\\)</span>, 走的长度要变短, 即<span\r\nclass=\"math inline\">\\(l_j&lt;l_i\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\ndp_i=1+\\max\\{dp_j|s_j=t_i, l_j&lt;l_i\\}\r\n\\]</span></p>\r\n<p>从最长的边开始依个枚举, 每次<span\r\nclass=\"math inline\">\\(dp\\)</span>以上一次数据更新, 使用滚动数组.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">2005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Side</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s, t;</span><br><span class=\"line\">    <span class=\"type\">double</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Side &amp;Left, <span class=\"type\">const</span> Side &amp;Right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Left.l &gt; Right.l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;Side&gt; sides;</span><br><span class=\"line\"><span class=\"type\">int</span> x[MAXN], y[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">lengthOf</span><span class=\"params\">(<span class=\"type\">double</span> dx, <span class=\"type\">double</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(dx*dx+dy*dy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) </span><br><span class=\"line\">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i!=j)</span><br><span class=\"line\">                sides.<span class=\"built_in\">push_back</span>(&#123;i,j,<span class=\"built_in\">lengthOf</span>(x[i]-x[j],y[i]-y[j])&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(sides.<span class=\"built_in\">begin</span>(),sides.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">f</span><span class=\"params\">(n<span class=\"number\">+1</span>,<span class=\"number\">-0x3f3f3f3f</span>)</span>, <span class=\"title\">g</span><span class=\"params\">(n<span class=\"number\">+1</span>,<span class=\"number\">-0x3f3f3f3f</span>)</span></span>;</span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; sides.<span class=\"built_in\">size</span>();i = j) &#123;</span><br><span class=\"line\">        vector&lt;Side&gt;t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i; j &lt; sides.<span class=\"built_in\">size</span>() &amp;&amp; sides[i].l == sides[j].l; j++)</span><br><span class=\"line\">            t.<span class=\"built_in\">push_back</span>(sides[j]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : t)g[e.t] = <span class=\"number\">-0x3f3f3f3f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : t)g[e.t] = <span class=\"built_in\">max</span>(g[e.t], f[e.s] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : t)f[e.t] = <span class=\"built_in\">max</span>(f[e.t], g[e.t]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; *<span class=\"built_in\">max_element</span>(f.<span class=\"built_in\">begin</span>(), f.<span class=\"built_in\">end</span>()) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"b-watches\">B-Watches</h1>\r\n<p>来源: 牛客多校训练营5 算法: 二分 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/B 补完: Yes 完成时间: August\r\n1, 2022</p>\r\n<h2 id=\"题意概括\"><strong>题意概括</strong></h2>\r\n<p>NIO要向制造产进一批手表，需要花费的金额除了手表本身的价钱外还有税收，计算方法为如果他买了k个手表，第i个手表的价格就是手表原价+k*i，现在NIO有M美元，问NIO最多可以买多少手表？</p>\r\n<h2 id=\"解题思路\"><strong>解题思路</strong></h2>\r\n<p>采用二分的方法，求出NIO最多可以买到多少手表。</p>\r\n<p>1）用结构体存储手表的原价、位置以及最终价格，输入原价时即记下该手表的位置i；</p>\r\n<p>2）最少NIO的钱可能一个手表都不购买，最多可能购买n个，因此把0和n传入二分函数中，如果二分结果（买的手表个数）满足条件，则寻找更大的数判断是否满足条件。</p>\r\n<p>3）判断是否满足条件的方法为：判断函数传入手表个数k，在购买k个手表的条件下，计算每个手表的最终价格，用sort从小到大排序，选择k个价格低的累加，计算购买k个所需的总价，如果小于或等于M，则满足条件，否则不满足。</p>\r\n<p><strong>注意：</strong>总价和手表的最终价格要用long long！！</p>\r\n<h2 id=\"代码-1\"><strong>代码</strong></h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">watch</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> w; </span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">&#125;A[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(watch x,watch y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.w&lt;y.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tA[i].w=A[i].a+k*A[i].i;  <span class=\"comment\">//计算手表的最终价格</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(A<span class=\"number\">+1</span>,A+n<span class=\"number\">+1</span>,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\tres+=A[i].w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res&lt;=m;  <span class=\"comment\">//判断这个mid是不是符合题目条件（是否为1）;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> min,<span class=\"type\">int</span> max)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans=<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (min&lt;=max)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=(min+max)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tans=mid;</span><br><span class=\"line\">\t\t\tmin=mid<span class=\"number\">+1</span>;  <span class=\"comment\">//依题目的临界条件而变，此题为寻找满足条件的最大数</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> max=mid<span class=\"number\">-1</span>;  <span class=\"comment\">//依题目的临界条件而变</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;A[i].a;</span><br><span class=\"line\">\t\tA[i].i=i;\t    <span class=\"comment\">//记录手表位置</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"built_in\">find</span>(<span class=\"number\">0</span>,n);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"c-bit-transmission\">C-Bit Transmission</h1>\r\n<p>来源: 牛客多校训练营5 算法: 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/C 补完: Yes 完成时间: August\r\n23, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33190/C\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>有一个01串，<span\r\nclass=\"math inline\">\\(3N\\)</span>次询问，每次询问一个索引（从0开始），机器会返回这个索引位置的字符是不是1。</p>\r\n<p>如果机器只最多给一个错误回答，是否能得到唯一的串？能，输出串，不能，输出-1。</p>\r\n<h2 id=\"ac代码\">AC代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">3</span>)cout&lt;&lt;<span class=\"string\">&quot;111&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><del>开玩笑的，这不是正解。但这真的是AC代码。</del></p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>首先，”机器最多给一个错误回答“是前提。</p>\r\n<p><del>虽然在题目修锅之前样例没保证这个还得把和前提冲突的情况考虑进去。</del></p>\r\n<p><del>多考虑点情况的代码可以通过现在的样例。</del></p>\r\n<p>那么答复一定<strong>不会出现</strong>多组冲突（比如0索引报告过YES和NO，1索引也报告过YES和NO）或者一组里面多个冲突（比如0索引报告了3个YES和4个NO）的情况。</p>\r\n<p>也就是答案可能是<strong>完全不冲突</strong>（所有索引都只报告YES或者NO），或者<strong>只存在一组冲突</strong>的情况。</p>\r\n<p>并且存在冲突的那种情况中，错误答案<strong>只报告了一次</strong>。</p>\r\n<p>那正确答案就很好组成了，不冲突的索引就是报告了非0次的那个答案，冲突的索引就是报告了多次的那个答案。可以统一写成<strong>出现次数多</strong>的那个答案。</p>\r\n<p>无法判断的情况也很显然：</p>\r\n<p>①该索引<strong>没有被报告</strong>。完全无法掌握对应索引的信息。</p>\r\n<p>②冲突报告的索引，YES和NO<strong>各</strong>被汇报了一次。无法确定哪个是假信息。</p>\r\n<p>③所有报告不存在冲突。但有索引<strong>只有一个报告</strong>。不管是YES还是NO，无法确定这条信息是否是真信息。（因为找不到那个可能存在的假信息在哪）</p>\r\n<p>其中①和②是YES和NO都被报告了0次或1次，可以合并成两个<strong>次数相等</strong>来判断。</p>\r\n<p>判断前事先统计每个索引的01结果报告数量即可。（YES表示这里是1，NO表示这里是0）</p>\r\n<p>代码见完整代码。</p>\r\n<p>————</p>\r\n<p>顺便考虑一下题目”机器最多给一个错误回答“不保证的情况。</p>\r\n<p>也就是出现机器给出多个错误答案直接输出-1的考虑。</p>\r\n<p>那么也就是加上前面认为不会出现的两种情况：</p>\r\n<p>①存在多个冲突对。</p>\r\n<p>②一组冲突里两种结果都有多次报告。</p>\r\n<p>代码见特殊版。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[<span class=\"number\">100010</span>][<span class=\"number\">2</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>*n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> id;</span><br><span class=\"line\">        string IF;</span><br><span class=\"line\">        cin&gt;&gt;id&gt;&gt;IF;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(IF[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;N&#x27;</span>)cnt[id][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cnt[id][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string ans=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        ans+=cnt[i][<span class=\"number\">1</span>]&gt;cnt[i][<span class=\"number\">0</span>]?<span class=\"string\">&#x27;1&#x27;</span>:<span class=\"string\">&#x27;0&#x27;</span>;<span class=\"comment\">//存结果串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]!=<span class=\"number\">0</span>&amp;&amp;cnt[i][<span class=\"number\">0</span>]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            flag=<span class=\"number\">1</span>;<span class=\"comment\">//标记存在冲突</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]==cnt[i][<span class=\"number\">0</span>])&#123;<span class=\"comment\">//均0次或者均1次</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;<span class=\"comment\">//不存在冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">0</span>]+cnt[i][<span class=\"number\">1</span>]==<span class=\"number\">1</span>)&#123;<span class=\"comment\">//但有索引只有一个报告</span></span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"完整代码-特殊版\">完整代码-特殊版</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[<span class=\"number\">100010</span>][<span class=\"number\">2</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>*n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> id;</span><br><span class=\"line\">        string IF;</span><br><span class=\"line\">        cin&gt;&gt;id&gt;&gt;IF;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(IF[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;N&#x27;</span>)cnt[id][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cnt[id][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string ans=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        ans+=cnt[i][<span class=\"number\">1</span>]&gt;cnt[i][<span class=\"number\">0</span>]?<span class=\"string\">&#x27;1&#x27;</span>:<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]!=<span class=\"number\">0</span>&amp;&amp;cnt[i][<span class=\"number\">0</span>]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//冲突存在标记的另一个使用处：出现第二个冲突。</span></span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]==cnt[i][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]&gt;=<span class=\"number\">2</span>&amp;&amp;cnt[i][<span class=\"number\">0</span>]&gt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//一组冲突多个报告的情况</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">0</span>]+cnt[i][<span class=\"number\">1</span>]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"d-birds-in-the-tree\">D-Birds in the tree</h1>\r\n<p>来源: 牛客多校训练营5 算法: DFS, 动态规划, 树形DP 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/D 补完: Yes 完成时间: August\r\n11, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>给有<span class=\"math inline\">\\(n\\)</span>个节点的树,\r\n每个节点具有颜色<span class=\"math inline\">\\(0\\)</span>或颜色<span\r\nclass=\"math inline\">\\(1\\)</span>. 求其有多少联通子图, 满足度数为<span\r\nclass=\"math inline\">\\(1\\)</span>的节点颜色相同.</p>\r\n<p>树上求方案树考虑树形DP</p>\r\n<p>设<span class=\"math inline\">\\(dp_{u,c}\\)</span>为在以<span\r\nclass=\"math inline\">\\(x\\)</span>为根的子树内, 有多少包含<span\r\nclass=\"math inline\">\\(u\\)</span>的连通子图, 叶结点(不包括<span\r\nclass=\"math inline\">\\(u\\)</span>)的颜色为<span\r\nclass=\"math inline\">\\(c\\)</span>的方案数.</p>\r\n<p>对一个父节点<span class=\"math inline\">\\(u\\)</span>的某一个子节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>的方案数都有选和不选两种情况,\r\n故共有<span class=\"math inline\">\\(dp[v_i][c]+1\\)</span>种方案.</p>\r\n<p>对一个父节点<span class=\"math inline\">\\(u\\)</span>的所有个子节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>, 每个子节点的方案数都可以独立选取,\r\n故父节点的方案数为所有子节点方案数的乘积.</p>\r\n<p><span class=\"math display\">\\[\r\ndp&#39;[u][c]=\\prod_v(1+dp[v][c])\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(u\\)</span>不选取的任何子树数时, <span\r\nclass=\"math inline\">\\(u\\)</span>本身也是一个叶结点, 考虑<span\r\nclass=\"math inline\">\\(u\\)</span>的颜色, 若此时其颜色不为<span\r\nclass=\"math inline\">\\(c\\)</span>则为无效方案数, 需要减去.</p>\r\n<p><span class=\"math display\">\\[\r\ndp[u][c]=\\prod_v(1+dp[v][c])-(a[u]!=c)\r\n\\]</span></p>\r\n<p>统计答案时统计各个结点的方案数, 另外考虑当一个结点仅选取一个子树时,\r\n<span class=\"math inline\">\\(u\\)</span>本身也是一个叶结点, 考虑<span\r\nclass=\"math inline\">\\(u\\)</span>的颜色, 若此时其颜色不为<span\r\nclass=\"math inline\">\\(c\\)</span>则为无效方案数, 需要减去.</p>\r\n<p><span class=\"math display\">\\[\r\nans_c=\\sum_u\\left(dp[u][c]-(a[u]!=c)\\sum dp[v][c]\\right)\r\n\\]</span></p>\r\n<p>最后加和答案即可</p>\r\n<p><span class=\"math display\">\\[\r\nAns=ans_0+ans_1\r\n\\]</span></p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">300005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">char</span> a[MAXN];</span><br><span class=\"line\">ll Ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\">ll dp[MAXN][<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+b+P)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a*b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> f, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    ll prod = <span class=\"number\">1</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u,c);</span><br><span class=\"line\">        prod = <span class=\"built_in\">mul</span>(prod, <span class=\"number\">1</span>+dp[v][c]);</span><br><span class=\"line\">        sum  = <span class=\"built_in\">add</span>(sum ,   dp[v][c]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[u][c] = <span class=\"built_in\">add</span>(prod, -(a[u]!=c));</span><br><span class=\"line\">    Ans = <span class=\"built_in\">add</span>(Ans, dp[u][c]-(a[u]!=c)*sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> c; </span><br><span class=\"line\">        cin&gt;&gt;c;</span><br><span class=\"line\">        a[i] = c - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        e[x].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">        e[y].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;Ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"f-a-stack-of-cds\">F-A Stack of CDs</h1>\r\n<p>来源: 牛客多校训练营5 算法: 计算几何 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/F 补完: Yes 完成时间: August\r\n2, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>有<span class=\"math inline\">\\(n\\)</span>张CD叠在平面上,\r\n求可见的CD弧长(不是求总的投影的边缘长).</p>\r\n<p>后放置的圆会压到先放置的圆, 将先放置的圆的部分弧压住看不到.</p>\r\n<p>以样例为例:</p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25A0%25B7%25E4%25BE%258B.jpg\"\r\nalt=\"样例.JPG\" />\r\n<figcaption aria-hidden=\"true\">样例.JPG</figcaption>\r\n</figure>\r\n<p>放置第一圆, 在最底下.</p>\r\n<p>放置第二圆, 此时小圆没有压到任何弧. 也没有被压它自身是可见的.</p>\r\n<p>放置第三圆, 此时第二圆完全被第三圆覆盖, 标红表示不可见.</p>\r\n<p>同时第一圆的右上角有部分弧被第三圆覆盖, 标红表示不可见.</p>\r\n<p>发现后放置的圆有可能对先放置的圆有影响, 会将其完全覆盖,\r\n或者覆盖部分弧长.</p>\r\n<p>为求剩余可见弧长, 可以记录此圆是否被完全覆盖,\r\n若为被完全覆盖则记录被覆盖了多少弧长.\r\n最后从周长中减去被覆盖的弧长即为可见弧长.\r\n统计所有圆的可见弧长即为答案.</p>\r\n<p>由于后续可能有多个圆对它覆盖, 这些弧之间可能有重叠,\r\n所以不能单纯记录被覆盖弧长的长度, 而是要记录被覆盖弧长的起始点,\r\n最后区间合并统计被覆盖弧长的总长度. 记录圆上起始点可以使用极角.</p>\r\n<p>先用余弦定理求弧长圆心角的绝对值</p>\r\n<p><span class=\"math display\">\\[\r\n\\cos \\alpha=\\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\alpha=\\arccos \\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\r\n\\]</span></p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582alpha.jpg\"\r\nalt=\"求alpha.JPG\" />\r\n<figcaption aria-hidden=\"true\">求alpha.JPG</figcaption>\r\n</figure>\r\n<p>再通过正切求出圆心角相对极轴的偏移量</p>\r\n<p><span class=\"math display\">\\[\r\n\\tan\\beta=\\frac{y_b-y_a}{x_b-x_a}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\beta=\\arctan\\frac{y_b-y_a}{x_b-x_a}\r\n\\]</span></p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582beta.jpg\"\r\nalt=\"求beta.JPG\" />\r\n<figcaption aria-hidden=\"true\">求beta.JPG</figcaption>\r\n</figure>\r\n<p>相加之后可得一条弧的起始点极角</p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582se.jpg\"\r\nalt=\"求se.JPG\" />\r\n<figcaption aria-hidden=\"true\">求se.JPG</figcaption>\r\n</figure>\r\n<p>这样处理后的极角可能落在<span\r\nclass=\"math inline\">\\([-2\\pi,2\\pi]\\)</span>区间内,\r\n而一个圆的正确区间是<span class=\"math inline\">\\([0,2\\pi]\\)</span>,\r\n可以通过让负数直接<span\r\nclass=\"math inline\">\\(+2\\pi\\)</span>落回正确区间.</p>\r\n<p>如果被覆盖弧越过零点, 应该拆成两段处理.</p>\r\n<h2 id=\"代码-3\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI M_PI</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">arc</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> start;</span><br><span class=\"line\">    <span class=\"type\">double</span> end;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(arc a,arc b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.start&lt;b.start || (a.start==b.start&amp;&amp;a.end&gt;b.end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">circle</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> y;</span><br><span class=\"line\">    <span class=\"type\">double</span> radius;</span><br><span class=\"line\">    vector&lt;arc&gt; covered;</span><br><span class=\"line\">    <span class=\"type\">bool</span> alive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;Circle[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">sqr</span><span class=\"params\">(<span class=\"type\">double</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">analyseCoverWith</span><span class=\"params\">(circle &amp;a,circle b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!a.alive)<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltax = b.x-a.x;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltay = b.y-a.y;</span><br><span class=\"line\">    <span class=\"type\">double</span> dis = <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">sqr</span>(deltax)+<span class=\"built_in\">sqr</span>(deltay));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis&gt;=a.radius+b.radius)                 <span class=\"keyword\">return</span>; <span class=\"comment\">//外离外切</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis+b.radius&lt;=a.radius)                 <span class=\"keyword\">return</span>; <span class=\"comment\">//上者小无覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis+a.radius&lt;=b.radius)&#123;a.alive = <span class=\"literal\">false</span>;<span class=\"keyword\">return</span>;&#125;<span class=\"comment\">//上者大全覆盖</span></span><br><span class=\"line\">    <span class=\"type\">double</span> alpha = <span class=\"built_in\">acos</span>((<span class=\"built_in\">sqr</span>(a.radius)+<span class=\"built_in\">sqr</span>(dis)-<span class=\"built_in\">sqr</span>(b.radius))/(<span class=\"number\">2</span>*a.radius*dis));</span><br><span class=\"line\">    <span class=\"type\">double</span> beta  = <span class=\"built_in\">atan2</span>(deltay,deltax);</span><br><span class=\"line\">    <span class=\"type\">double</span> start = ((beta-alpha)&gt;<span class=\"number\">0</span>)?(beta-alpha):(beta-alpha<span class=\"number\">+2</span>*PI);</span><br><span class=\"line\">    <span class=\"type\">double</span> end   = ((beta+alpha)&gt;<span class=\"number\">0</span>)?(beta+alpha):(beta+alpha<span class=\"number\">+2</span>*PI);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start&lt;=end)&#123;</span><br><span class=\"line\">        a.covered.<span class=\"built_in\">push_back</span>(&#123;start, end&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        a.covered.<span class=\"built_in\">push_back</span>(&#123;  <span class=\"number\">0</span>  , end&#125;);</span><br><span class=\"line\">        a.covered.<span class=\"built_in\">push_back</span>(&#123;start,<span class=\"number\">2</span>*PI&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">aliveArcOf</span><span class=\"params\">(circle a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!a.alive)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    Circle[i].covered.<span class=\"built_in\">push_back</span>(&#123;  <span class=\"number\">0</span> ,  <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">    Circle[i].covered.<span class=\"built_in\">push_back</span>(&#123;<span class=\"number\">2</span>*PI,<span class=\"number\">2</span>*PI&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a.covered.<span class=\"built_in\">begin</span>(),a.covered.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    <span class=\"type\">double</span> lim = <span class=\"number\">0</span>, temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> arc: a.covered)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arc.start&gt;lim)</span><br><span class=\"line\">            temp+=arc.start-lim;</span><br><span class=\"line\">        lim = <span class=\"built_in\">max</span>(lim,arc.end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp*a.radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">double</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;Circle[i].x&gt;&gt;Circle[i].y&gt;&gt;Circle[i].radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;=n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i<span class=\"number\">+1</span>; j&lt;=n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">analyseCoverWith</span>(Circle[i],Circle[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += <span class=\"built_in\">aliveArcOf</span>(Circle[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf&quot;</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-kfc-crazy-thursday\">G-KFC Crazy Thursday</h1>\r\n<p>来源: 牛客多校训练营5 算法: 回文自动机, 字符串 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/G 补完: Yes 完成时间: August\r\n3, 2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>给定一个字符串，分别输出以’k‘、’f‘、’c‘结尾的回文子串个数。</p>\r\n<h2 id=\"解法\">解法</h2>\r\n<p>套用<strong>回文自动机</strong>模板，在字符串存入回文树的过程中加上一层判断：当遇到’k‘、’f‘、’c‘时，分别计算出以该字符结尾的回文串的个数，并记录累加结果</p>\r\n<p>当字符串全部存入后，也就算出了所有以’k‘、’f‘、’c‘结尾的回文子串个数</p>\r\n<h2 id=\"代码-4\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">500010</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"type\">int</span> len[N],n,num[N],fail[N],last,cur,pos,trie[N][<span class=\"number\">26</span>],tot=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> k,f,c;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getfail</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i-len[x]<span class=\"number\">-1</span>&lt;<span class=\"number\">0</span>||s[i-len[x]<span class=\"number\">-1</span>]!=s[i])x=fail[x];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">\t  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,s);</span><br><span class=\"line\">    fail[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;len[<span class=\"number\">1</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123; </span><br><span class=\"line\">    \tpos=<span class=\"built_in\">getfail</span>(cur,i);</span><br><span class=\"line\">        <span class=\"comment\">//找到cur的fail链中能匹配i位的最长回文后缀</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!trie[pos][s[i]-<span class=\"string\">&#x27;a&#x27;</span>])&#123;</span><br><span class=\"line\">        \tfail[++tot]=trie[<span class=\"built_in\">getfail</span>(fail[pos],i)][s[i]-<span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        \ttrie[pos][s[i]-<span class=\"string\">&#x27;a&#x27;</span>]=tot;</span><br><span class=\"line\">        \tlen[tot]=len[pos]<span class=\"number\">+2</span>;</span><br><span class=\"line\">          num[tot]=num[fail[tot]]<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t   &#125;<span class=\"comment\">//不存在建立点，存在直接走过去</span></span><br><span class=\"line\">       cur=trie[pos][s[i]-<span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">       last=num[cur];</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;k&#x27;</span>)&#123;</span><br><span class=\"line\">\t       \t k+=last;</span><br><span class=\"line\">\t      &#125;    </span><br><span class=\"line\">\t     <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;f&#x27;</span>)&#123;</span><br><span class=\"line\">    \t     f+=last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;c&#x27;</span>)&#123;</span><br><span class=\"line\">\t \t       c+=last;</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">    cout&lt;&lt;k&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;f&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;c; </span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"h-cutting-papers\">H-Cutting Papers</h1>\r\n<p>来源: 牛客多校训练营5 算法: 计算几何 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/H 补完: Yes 完成时间: August\r\n1, 2022</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>当<span class=\"math inline\">\\(x&gt;0\\&amp;\\&amp;y&gt;0\\)</span>时,\r\n<span class=\"math inline\">\\(x+y+x+y≤n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(x+y≤n/2\\)</span></p>\r\n<p>当<span class=\"math inline\">\\(x&lt;0\\&amp;\\&amp;y&lt;0\\)</span>时,\r\n<span class=\"math inline\">\\(x+y+x+y≥n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(x+y≥n/2\\)</span></p>\r\n<p>当<span class=\"math inline\">\\(x&gt;0\\&amp;\\&amp;y&lt;0\\)</span>时,\r\n<span class=\"math inline\">\\(|x|+|y|+(|x|-|y|)≤n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(|x|≤n/2\\)</span></p>\r\n<p>当<span class=\"math inline\">\\(x&lt;0\\&amp;\\&amp;y&gt;0\\)</span>时,\r\n<span class=\"math inline\">\\(|x|+|y|+(|y|-|x|)≤n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(|y|≤n/2\\)</span></p>\r\n<p>对应六条边</p>\r\n<p>半径为<span class=\"math inline\">\\(n/2\\)</span>的圆</p>\r\n<figure>\r\n<img\r\nsrc=\"H-Cutting%20Papers%200d73eb7a678047b79cc6a3b8f5cd04c8/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<h2 id=\"代码-5\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">double</span> r = n/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> ans = r*r*M_PI/<span class=\"number\">2</span>+r*r*<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf&quot;</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"k-headpho\">K-Headpho</h1>\r\n<p>来源: 牛客多校训练营5 算法: 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/K 补完: Yes 完成时间: August\r\n26, 2022</p>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<ul>\r\n<li>NIO和妹妹拿耳机</li>\r\n<li>共有<span class=\"math inline\">\\(n\\)</span>对耳机，妹妹已经拿了<span\r\nclass=\"math inline\">\\(k\\)</span>对</li>\r\n<li>剩下的耳机两人分，NIO一只一只拿</li>\r\n<li>问剩下的耳机中NIO至少要拿多少只才能拥有比妹妹多对的耳机？</li>\r\n</ul>\r\n<h2 id=\"解法-1\">解法</h2>\r\n<ul>\r\n<li>NIO最少要拿到<span\r\nclass=\"math inline\">\\(k+1\\)</span>对耳机，此时总的耳机对数就是<span\r\nclass=\"math inline\">\\(k+k+1\\)</span>，若<span\r\nclass=\"math inline\">\\(k+k+1&gt;n\\)</span>，说明NIO拿不到<span\r\nclass=\"math inline\">\\(k+1\\)</span>对，输出<span\r\nclass=\"math inline\">\\(-1\\)</span></li>\r\n<li>因为NIO是一只一只拿的，所以NIO拿的比妹妹多的最坏情况就是，NIO拿了一半多一个，这样妹妹就凑不到一半的耳机了</li>\r\n</ul>\r\n<h2 id=\"代码-6\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,k,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    ans=k<span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans+k&gt;n)&#123;</span><br><span class=\"line\">        ans=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       ans=n<span class=\"number\">+1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"a-dont-starve\">A-Don't Starve</h1>\r\n<p>来源: 牛客多校训练营5 算法: 动态规划 补完: Yes 完成时间: August 11,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>二维平面上有<span\r\nclass=\"math inline\">\\(n≤2000\\)</span>个点会刷新食物,\r\n威尔逊从原点出发收集食物, 每次前往下一个食物的距离要比上一次短,\r\n每个食物被收集过后会重新刷新, 求最多可以收集到的食物数量.</p>\r\n<p>每两个点之间都可以走, 记录每条边的信息, 第<span\r\nclass=\"math inline\">\\(i\\)</span>条边有起点<span\r\nclass=\"math inline\">\\(s_i\\)</span>, 终点<span\r\nclass=\"math inline\">\\(t_i\\)</span>, 长度<span\r\nclass=\"math inline\">\\(l_i\\)</span>.</p>\r\n<p>从原点出发故除了食物之间的边, 还要再考虑从原点到食物的边.</p>\r\n<p>考虑<span class=\"math inline\">\\(dp_i\\)</span>表示上一步走了第<span\r\nclass=\"math inline\">\\(i\\)</span>条边的最大收集量, 从<span\r\nclass=\"math inline\">\\(s_i\\)</span>走到了<span\r\nclass=\"math inline\">\\(t_i\\)</span>.</p>\r\n<p>则下一步<span class=\"math inline\">\\(dp_j\\)</span>走第<span\r\nclass=\"math inline\">\\(j\\)</span>条边需要从<span\r\nclass=\"math inline\">\\(t_i\\)</span>出发, 即<span\r\nclass=\"math inline\">\\(t_i=s_j\\)</span>, 走的长度要变短, 即<span\r\nclass=\"math inline\">\\(l_j&lt;l_i\\)</span></p>\r\n<p><span class=\"math display\">\\[\r\ndp_i=1+\\max\\{dp_j|s_j=t_i, l_j&lt;l_i\\}\r\n\\]</span></p>\r\n<p>从最长的边开始依个枚举, 每次<span\r\nclass=\"math inline\">\\(dp\\)</span>以上一次数据更新, 使用滚动数组.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">2005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Side</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s, t;</span><br><span class=\"line\">    <span class=\"type\">double</span> l;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Side &amp;Left, <span class=\"type\">const</span> Side &amp;Right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Left.l &gt; Right.l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;Side&gt; sides;</span><br><span class=\"line\"><span class=\"type\">int</span> x[MAXN], y[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">lengthOf</span><span class=\"params\">(<span class=\"type\">double</span> dx, <span class=\"type\">double</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(dx*dx+dy*dy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) </span><br><span class=\"line\">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i!=j)</span><br><span class=\"line\">                sides.<span class=\"built_in\">push_back</span>(&#123;i,j,<span class=\"built_in\">lengthOf</span>(x[i]-x[j],y[i]-y[j])&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(sides.<span class=\"built_in\">begin</span>(),sides.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">f</span><span class=\"params\">(n<span class=\"number\">+1</span>,<span class=\"number\">-0x3f3f3f3f</span>)</span>, <span class=\"title\">g</span><span class=\"params\">(n<span class=\"number\">+1</span>,<span class=\"number\">-0x3f3f3f3f</span>)</span></span>;</span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; sides.<span class=\"built_in\">size</span>();i = j) &#123;</span><br><span class=\"line\">        vector&lt;Side&gt;t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i; j &lt; sides.<span class=\"built_in\">size</span>() &amp;&amp; sides[i].l == sides[j].l; j++)</span><br><span class=\"line\">            t.<span class=\"built_in\">push_back</span>(sides[j]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : t)g[e.t] = <span class=\"number\">-0x3f3f3f3f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : t)g[e.t] = <span class=\"built_in\">max</span>(g[e.t], f[e.s] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : t)f[e.t] = <span class=\"built_in\">max</span>(f[e.t], g[e.t]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; *<span class=\"built_in\">max_element</span>(f.<span class=\"built_in\">begin</span>(), f.<span class=\"built_in\">end</span>()) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"b-watches\">B-Watches</h1>\r\n<p>来源: 牛客多校训练营5 算法: 二分 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/B 补完: Yes 完成时间: August\r\n1, 2022</p>\r\n<h2 id=\"题意概括\"><strong>题意概括</strong></h2>\r\n<p>NIO要向制造产进一批手表，需要花费的金额除了手表本身的价钱外还有税收，计算方法为如果他买了k个手表，第i个手表的价格就是手表原价+k*i，现在NIO有M美元，问NIO最多可以买多少手表？</p>\r\n<h2 id=\"解题思路\"><strong>解题思路</strong></h2>\r\n<p>采用二分的方法，求出NIO最多可以买到多少手表。</p>\r\n<p>1）用结构体存储手表的原价、位置以及最终价格，输入原价时即记下该手表的位置i；</p>\r\n<p>2）最少NIO的钱可能一个手表都不购买，最多可能购买n个，因此把0和n传入二分函数中，如果二分结果（买的手表个数）满足条件，则寻找更大的数判断是否满足条件。</p>\r\n<p>3）判断是否满足条件的方法为：判断函数传入手表个数k，在购买k个手表的条件下，计算每个手表的最终价格，用sort从小到大排序，选择k个价格低的累加，计算购买k个所需的总价，如果小于或等于M，则满足条件，否则不满足。</p>\r\n<p><strong>注意：</strong>总价和手表的最终价格要用long long！！</p>\r\n<h2 id=\"代码-1\"><strong>代码</strong></h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">watch</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> w; </span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">&#125;A[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(watch x,watch y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.w&lt;y.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tA[i].w=A[i].a+k*A[i].i;  <span class=\"comment\">//计算手表的最终价格</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(A<span class=\"number\">+1</span>,A+n<span class=\"number\">+1</span>,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\tres+=A[i].w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res&lt;=m;  <span class=\"comment\">//判断这个mid是不是符合题目条件（是否为1）;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> min,<span class=\"type\">int</span> max)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans=<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (min&lt;=max)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid=(min+max)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tans=mid;</span><br><span class=\"line\">\t\t\tmin=mid<span class=\"number\">+1</span>;  <span class=\"comment\">//依题目的临界条件而变，此题为寻找满足条件的最大数</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> max=mid<span class=\"number\">-1</span>;  <span class=\"comment\">//依题目的临界条件而变</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;A[i].a;</span><br><span class=\"line\">\t\tA[i].i=i;\t    <span class=\"comment\">//记录手表位置</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"built_in\">find</span>(<span class=\"number\">0</span>,n);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"c-bit-transmission\">C-Bit Transmission</h1>\r\n<p>来源: 牛客多校训练营5 算法: 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/C 补完: Yes 完成时间: August\r\n23, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33190/C\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>有一个01串，<span\r\nclass=\"math inline\">\\(3N\\)</span>次询问，每次询问一个索引（从0开始），机器会返回这个索引位置的字符是不是1。</p>\r\n<p>如果机器只最多给一个错误回答，是否能得到唯一的串？能，输出串，不能，输出-1。</p>\r\n<h2 id=\"ac代码\">AC代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">3</span>)cout&lt;&lt;<span class=\"string\">&quot;111&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><del>开玩笑的，这不是正解。但这真的是AC代码。</del></p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>首先，”机器最多给一个错误回答“是前提。</p>\r\n<p><del>虽然在题目修锅之前样例没保证这个还得把和前提冲突的情况考虑进去。</del></p>\r\n<p><del>多考虑点情况的代码可以通过现在的样例。</del></p>\r\n<p>那么答复一定<strong>不会出现</strong>多组冲突（比如0索引报告过YES和NO，1索引也报告过YES和NO）或者一组里面多个冲突（比如0索引报告了3个YES和4个NO）的情况。</p>\r\n<p>也就是答案可能是<strong>完全不冲突</strong>（所有索引都只报告YES或者NO），或者<strong>只存在一组冲突</strong>的情况。</p>\r\n<p>并且存在冲突的那种情况中，错误答案<strong>只报告了一次</strong>。</p>\r\n<p>那正确答案就很好组成了，不冲突的索引就是报告了非0次的那个答案，冲突的索引就是报告了多次的那个答案。可以统一写成<strong>出现次数多</strong>的那个答案。</p>\r\n<p>无法判断的情况也很显然：</p>\r\n<p>①该索引<strong>没有被报告</strong>。完全无法掌握对应索引的信息。</p>\r\n<p>②冲突报告的索引，YES和NO<strong>各</strong>被汇报了一次。无法确定哪个是假信息。</p>\r\n<p>③所有报告不存在冲突。但有索引<strong>只有一个报告</strong>。不管是YES还是NO，无法确定这条信息是否是真信息。（因为找不到那个可能存在的假信息在哪）</p>\r\n<p>其中①和②是YES和NO都被报告了0次或1次，可以合并成两个<strong>次数相等</strong>来判断。</p>\r\n<p>判断前事先统计每个索引的01结果报告数量即可。（YES表示这里是1，NO表示这里是0）</p>\r\n<p>代码见完整代码。</p>\r\n<p>————</p>\r\n<p>顺便考虑一下题目”机器最多给一个错误回答“不保证的情况。</p>\r\n<p>也就是出现机器给出多个错误答案直接输出-1的考虑。</p>\r\n<p>那么也就是加上前面认为不会出现的两种情况：</p>\r\n<p>①存在多个冲突对。</p>\r\n<p>②一组冲突里两种结果都有多次报告。</p>\r\n<p>代码见特殊版。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[<span class=\"number\">100010</span>][<span class=\"number\">2</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>*n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> id;</span><br><span class=\"line\">        string IF;</span><br><span class=\"line\">        cin&gt;&gt;id&gt;&gt;IF;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(IF[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;N&#x27;</span>)cnt[id][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cnt[id][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string ans=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        ans+=cnt[i][<span class=\"number\">1</span>]&gt;cnt[i][<span class=\"number\">0</span>]?<span class=\"string\">&#x27;1&#x27;</span>:<span class=\"string\">&#x27;0&#x27;</span>;<span class=\"comment\">//存结果串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]!=<span class=\"number\">0</span>&amp;&amp;cnt[i][<span class=\"number\">0</span>]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            flag=<span class=\"number\">1</span>;<span class=\"comment\">//标记存在冲突</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]==cnt[i][<span class=\"number\">0</span>])&#123;<span class=\"comment\">//均0次或者均1次</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;<span class=\"comment\">//不存在冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">0</span>]+cnt[i][<span class=\"number\">1</span>]==<span class=\"number\">1</span>)&#123;<span class=\"comment\">//但有索引只有一个报告</span></span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"完整代码-特殊版\">完整代码-特殊版</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> cnt[<span class=\"number\">100010</span>][<span class=\"number\">2</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>*n;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> id;</span><br><span class=\"line\">        string IF;</span><br><span class=\"line\">        cin&gt;&gt;id&gt;&gt;IF;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(IF[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;N&#x27;</span>)cnt[id][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cnt[id][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string ans=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        ans+=cnt[i][<span class=\"number\">1</span>]&gt;cnt[i][<span class=\"number\">0</span>]?<span class=\"string\">&#x27;1&#x27;</span>:<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]!=<span class=\"number\">0</span>&amp;&amp;cnt[i][<span class=\"number\">0</span>]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//冲突存在标记的另一个使用处：出现第二个冲突。</span></span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]==cnt[i][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">1</span>]&gt;=<span class=\"number\">2</span>&amp;&amp;cnt[i][<span class=\"number\">0</span>]&gt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//一组冲突多个报告的情况</span></span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt[i][<span class=\"number\">0</span>]+cnt[i][<span class=\"number\">1</span>]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"d-birds-in-the-tree\">D-Birds in the tree</h1>\r\n<p>来源: 牛客多校训练营5 算法: DFS, 动态规划, 树形DP 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/D 补完: Yes 完成时间: August\r\n11, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>给有<span class=\"math inline\">\\(n\\)</span>个节点的树,\r\n每个节点具有颜色<span class=\"math inline\">\\(0\\)</span>或颜色<span\r\nclass=\"math inline\">\\(1\\)</span>. 求其有多少联通子图, 满足度数为<span\r\nclass=\"math inline\">\\(1\\)</span>的节点颜色相同.</p>\r\n<p>树上求方案树考虑树形DP</p>\r\n<p>设<span class=\"math inline\">\\(dp_{u,c}\\)</span>为在以<span\r\nclass=\"math inline\">\\(x\\)</span>为根的子树内, 有多少包含<span\r\nclass=\"math inline\">\\(u\\)</span>的连通子图, 叶结点(不包括<span\r\nclass=\"math inline\">\\(u\\)</span>)的颜色为<span\r\nclass=\"math inline\">\\(c\\)</span>的方案数.</p>\r\n<p>对一个父节点<span class=\"math inline\">\\(u\\)</span>的某一个子节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>的方案数都有选和不选两种情况,\r\n故共有<span class=\"math inline\">\\(dp[v_i][c]+1\\)</span>种方案.</p>\r\n<p>对一个父节点<span class=\"math inline\">\\(u\\)</span>的所有个子节点<span\r\nclass=\"math inline\">\\(v_i\\)</span>, 每个子节点的方案数都可以独立选取,\r\n故父节点的方案数为所有子节点方案数的乘积.</p>\r\n<p><span class=\"math display\">\\[\r\ndp&#39;[u][c]=\\prod_v(1+dp[v][c])\r\n\\]</span></p>\r\n<p>当<span class=\"math inline\">\\(u\\)</span>不选取的任何子树数时, <span\r\nclass=\"math inline\">\\(u\\)</span>本身也是一个叶结点, 考虑<span\r\nclass=\"math inline\">\\(u\\)</span>的颜色, 若此时其颜色不为<span\r\nclass=\"math inline\">\\(c\\)</span>则为无效方案数, 需要减去.</p>\r\n<p><span class=\"math display\">\\[\r\ndp[u][c]=\\prod_v(1+dp[v][c])-(a[u]!=c)\r\n\\]</span></p>\r\n<p>统计答案时统计各个结点的方案数, 另外考虑当一个结点仅选取一个子树时,\r\n<span class=\"math inline\">\\(u\\)</span>本身也是一个叶结点, 考虑<span\r\nclass=\"math inline\">\\(u\\)</span>的颜色, 若此时其颜色不为<span\r\nclass=\"math inline\">\\(c\\)</span>则为无效方案数, 需要减去.</p>\r\n<p><span class=\"math display\">\\[\r\nans_c=\\sum_u\\left(dp[u][c]-(a[u]!=c)\\sum dp[v][c]\\right)\r\n\\]</span></p>\r\n<p>最后加和答案即可</p>\r\n<p><span class=\"math display\">\\[\r\nAns=ans_0+ans_1\r\n\\]</span></p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">300005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">char</span> a[MAXN];</span><br><span class=\"line\">ll Ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\">ll dp[MAXN][<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+b+P)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a*b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> f, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    ll prod = <span class=\"number\">1</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u,c);</span><br><span class=\"line\">        prod = <span class=\"built_in\">mul</span>(prod, <span class=\"number\">1</span>+dp[v][c]);</span><br><span class=\"line\">        sum  = <span class=\"built_in\">add</span>(sum ,   dp[v][c]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[u][c] = <span class=\"built_in\">add</span>(prod, -(a[u]!=c));</span><br><span class=\"line\">    Ans = <span class=\"built_in\">add</span>(Ans, dp[u][c]-(a[u]!=c)*sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> c; </span><br><span class=\"line\">        cin&gt;&gt;c;</span><br><span class=\"line\">        a[i] = c - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        e[x].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">        e[y].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;Ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"f-a-stack-of-cds\">F-A Stack of CDs</h1>\r\n<p>来源: 牛客多校训练营5 算法: 计算几何 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/F 补完: Yes 完成时间: August\r\n2, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>有<span class=\"math inline\">\\(n\\)</span>张CD叠在平面上,\r\n求可见的CD弧长(不是求总的投影的边缘长).</p>\r\n<p>后放置的圆会压到先放置的圆, 将先放置的圆的部分弧压住看不到.</p>\r\n<p>以样例为例:</p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25A0%25B7%25E4%25BE%258B.jpg\"\r\nalt=\"样例.JPG\" />\r\n<figcaption aria-hidden=\"true\">样例.JPG</figcaption>\r\n</figure>\r\n<p>放置第一圆, 在最底下.</p>\r\n<p>放置第二圆, 此时小圆没有压到任何弧. 也没有被压它自身是可见的.</p>\r\n<p>放置第三圆, 此时第二圆完全被第三圆覆盖, 标红表示不可见.</p>\r\n<p>同时第一圆的右上角有部分弧被第三圆覆盖, 标红表示不可见.</p>\r\n<p>发现后放置的圆有可能对先放置的圆有影响, 会将其完全覆盖,\r\n或者覆盖部分弧长.</p>\r\n<p>为求剩余可见弧长, 可以记录此圆是否被完全覆盖,\r\n若为被完全覆盖则记录被覆盖了多少弧长.\r\n最后从周长中减去被覆盖的弧长即为可见弧长.\r\n统计所有圆的可见弧长即为答案.</p>\r\n<p>由于后续可能有多个圆对它覆盖, 这些弧之间可能有重叠,\r\n所以不能单纯记录被覆盖弧长的长度, 而是要记录被覆盖弧长的起始点,\r\n最后区间合并统计被覆盖弧长的总长度. 记录圆上起始点可以使用极角.</p>\r\n<p>先用余弦定理求弧长圆心角的绝对值</p>\r\n<p><span class=\"math display\">\\[\r\n\\cos \\alpha=\\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\alpha=\\arccos \\frac{dist^2+a.r^2-b.r^2}{2*a.r*dist}\r\n\\]</span></p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582alpha.jpg\"\r\nalt=\"求alpha.JPG\" />\r\n<figcaption aria-hidden=\"true\">求alpha.JPG</figcaption>\r\n</figure>\r\n<p>再通过正切求出圆心角相对极轴的偏移量</p>\r\n<p><span class=\"math display\">\\[\r\n\\tan\\beta=\\frac{y_b-y_a}{x_b-x_a}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\beta=\\arctan\\frac{y_b-y_a}{x_b-x_a}\r\n\\]</span></p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582beta.jpg\"\r\nalt=\"求beta.JPG\" />\r\n<figcaption aria-hidden=\"true\">求beta.JPG</figcaption>\r\n</figure>\r\n<p>相加之后可得一条弧的起始点极角</p>\r\n<figure>\r\n<img\r\nsrc=\"F-A%20Stack%20of%20CDs%2002628ae9aa4240fd8032af53bd00734a/%25E6%25B1%2582se.jpg\"\r\nalt=\"求se.JPG\" />\r\n<figcaption aria-hidden=\"true\">求se.JPG</figcaption>\r\n</figure>\r\n<p>这样处理后的极角可能落在<span\r\nclass=\"math inline\">\\([-2\\pi,2\\pi]\\)</span>区间内,\r\n而一个圆的正确区间是<span class=\"math inline\">\\([0,2\\pi]\\)</span>,\r\n可以通过让负数直接<span\r\nclass=\"math inline\">\\(+2\\pi\\)</span>落回正确区间.</p>\r\n<p>如果被覆盖弧越过零点, 应该拆成两段处理.</p>\r\n<h2 id=\"代码-3\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI M_PI</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">1005</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">arc</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> start;</span><br><span class=\"line\">    <span class=\"type\">double</span> end;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(arc a,arc b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.start&lt;b.start || (a.start==b.start&amp;&amp;a.end&gt;b.end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">circle</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> x;</span><br><span class=\"line\">    <span class=\"type\">double</span> y;</span><br><span class=\"line\">    <span class=\"type\">double</span> radius;</span><br><span class=\"line\">    vector&lt;arc&gt; covered;</span><br><span class=\"line\">    <span class=\"type\">bool</span> alive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;Circle[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">sqr</span><span class=\"params\">(<span class=\"type\">double</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">analyseCoverWith</span><span class=\"params\">(circle &amp;a,circle b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!a.alive)<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltax = b.x-a.x;</span><br><span class=\"line\">    <span class=\"type\">double</span> deltay = b.y-a.y;</span><br><span class=\"line\">    <span class=\"type\">double</span> dis = <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">sqr</span>(deltax)+<span class=\"built_in\">sqr</span>(deltay));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis&gt;=a.radius+b.radius)                 <span class=\"keyword\">return</span>; <span class=\"comment\">//外离外切</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis+b.radius&lt;=a.radius)                 <span class=\"keyword\">return</span>; <span class=\"comment\">//上者小无覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dis+a.radius&lt;=b.radius)&#123;a.alive = <span class=\"literal\">false</span>;<span class=\"keyword\">return</span>;&#125;<span class=\"comment\">//上者大全覆盖</span></span><br><span class=\"line\">    <span class=\"type\">double</span> alpha = <span class=\"built_in\">acos</span>((<span class=\"built_in\">sqr</span>(a.radius)+<span class=\"built_in\">sqr</span>(dis)-<span class=\"built_in\">sqr</span>(b.radius))/(<span class=\"number\">2</span>*a.radius*dis));</span><br><span class=\"line\">    <span class=\"type\">double</span> beta  = <span class=\"built_in\">atan2</span>(deltay,deltax);</span><br><span class=\"line\">    <span class=\"type\">double</span> start = ((beta-alpha)&gt;<span class=\"number\">0</span>)?(beta-alpha):(beta-alpha<span class=\"number\">+2</span>*PI);</span><br><span class=\"line\">    <span class=\"type\">double</span> end   = ((beta+alpha)&gt;<span class=\"number\">0</span>)?(beta+alpha):(beta+alpha<span class=\"number\">+2</span>*PI);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start&lt;=end)&#123;</span><br><span class=\"line\">        a.covered.<span class=\"built_in\">push_back</span>(&#123;start, end&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        a.covered.<span class=\"built_in\">push_back</span>(&#123;  <span class=\"number\">0</span>  , end&#125;);</span><br><span class=\"line\">        a.covered.<span class=\"built_in\">push_back</span>(&#123;start,<span class=\"number\">2</span>*PI&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">aliveArcOf</span><span class=\"params\">(circle a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!a.alive)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    Circle[i].covered.<span class=\"built_in\">push_back</span>(&#123;  <span class=\"number\">0</span> ,  <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">    Circle[i].covered.<span class=\"built_in\">push_back</span>(&#123;<span class=\"number\">2</span>*PI,<span class=\"number\">2</span>*PI&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a.covered.<span class=\"built_in\">begin</span>(),a.covered.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    <span class=\"type\">double</span> lim = <span class=\"number\">0</span>, temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> arc: a.covered)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arc.start&gt;lim)</span><br><span class=\"line\">            temp+=arc.start-lim;</span><br><span class=\"line\">        lim = <span class=\"built_in\">max</span>(lim,arc.end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp*a.radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">double</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;Circle[i].x&gt;&gt;Circle[i].y&gt;&gt;Circle[i].radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;=n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i<span class=\"number\">+1</span>; j&lt;=n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">analyseCoverWith</span>(Circle[i],Circle[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += <span class=\"built_in\">aliveArcOf</span>(Circle[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf&quot;</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-kfc-crazy-thursday\">G-KFC Crazy Thursday</h1>\r\n<p>来源: 牛客多校训练营5 算法: 回文自动机, 字符串 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/G 补完: Yes 完成时间: August\r\n3, 2022</p>\r\n<h2 id=\"题意\">题意</h2>\r\n<p>给定一个字符串，分别输出以’k‘、’f‘、’c‘结尾的回文子串个数。</p>\r\n<h2 id=\"解法\">解法</h2>\r\n<p>套用<strong>回文自动机</strong>模板，在字符串存入回文树的过程中加上一层判断：当遇到’k‘、’f‘、’c‘时，分别计算出以该字符结尾的回文串的个数，并记录累加结果</p>\r\n<p>当字符串全部存入后，也就算出了所有以’k‘、’f‘、’c‘结尾的回文子串个数</p>\r\n<h2 id=\"代码-4\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">500010</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"type\">int</span> len[N],n,num[N],fail[N],last,cur,pos,trie[N][<span class=\"number\">26</span>],tot=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> k,f,c;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getfail</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i-len[x]<span class=\"number\">-1</span>&lt;<span class=\"number\">0</span>||s[i-len[x]<span class=\"number\">-1</span>]!=s[i])x=fail[x];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">\t  <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,s);</span><br><span class=\"line\">    fail[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;len[<span class=\"number\">1</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123; </span><br><span class=\"line\">    \tpos=<span class=\"built_in\">getfail</span>(cur,i);</span><br><span class=\"line\">        <span class=\"comment\">//找到cur的fail链中能匹配i位的最长回文后缀</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!trie[pos][s[i]-<span class=\"string\">&#x27;a&#x27;</span>])&#123;</span><br><span class=\"line\">        \tfail[++tot]=trie[<span class=\"built_in\">getfail</span>(fail[pos],i)][s[i]-<span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        \ttrie[pos][s[i]-<span class=\"string\">&#x27;a&#x27;</span>]=tot;</span><br><span class=\"line\">        \tlen[tot]=len[pos]<span class=\"number\">+2</span>;</span><br><span class=\"line\">          num[tot]=num[fail[tot]]<span class=\"number\">+1</span>;</span><br><span class=\"line\">\t\t   &#125;<span class=\"comment\">//不存在建立点，存在直接走过去</span></span><br><span class=\"line\">       cur=trie[pos][s[i]-<span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">       last=num[cur];</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;k&#x27;</span>)&#123;</span><br><span class=\"line\">\t       \t k+=last;</span><br><span class=\"line\">\t      &#125;    </span><br><span class=\"line\">\t     <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;f&#x27;</span>)&#123;</span><br><span class=\"line\">    \t     f+=last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;c&#x27;</span>)&#123;</span><br><span class=\"line\">\t \t       c+=last;</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">    cout&lt;&lt;k&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;f&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;c; </span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"h-cutting-papers\">H-Cutting Papers</h1>\r\n<p>来源: 牛客多校训练营5 算法: 计算几何 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/H 补完: Yes 完成时间: August\r\n1, 2022</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>当<span class=\"math inline\">\\(x&gt;0\\&amp;\\&amp;y&gt;0\\)</span>时,\r\n<span class=\"math inline\">\\(x+y+x+y≤n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(x+y≤n/2\\)</span></p>\r\n<p>当<span class=\"math inline\">\\(x&lt;0\\&amp;\\&amp;y&lt;0\\)</span>时,\r\n<span class=\"math inline\">\\(x+y+x+y≥n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(x+y≥n/2\\)</span></p>\r\n<p>当<span class=\"math inline\">\\(x&gt;0\\&amp;\\&amp;y&lt;0\\)</span>时,\r\n<span class=\"math inline\">\\(|x|+|y|+(|x|-|y|)≤n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(|x|≤n/2\\)</span></p>\r\n<p>当<span class=\"math inline\">\\(x&lt;0\\&amp;\\&amp;y&gt;0\\)</span>时,\r\n<span class=\"math inline\">\\(|x|+|y|+(|y|-|x|)≤n\\)</span>, 即为<span\r\nclass=\"math inline\">\\(|y|≤n/2\\)</span></p>\r\n<p>对应六条边</p>\r\n<p>半径为<span class=\"math inline\">\\(n/2\\)</span>的圆</p>\r\n<figure>\r\n<img\r\nsrc=\"H-Cutting%20Papers%200d73eb7a678047b79cc6a3b8f5cd04c8/Untitled.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<h2 id=\"代码-5\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">double</span> r = n/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> ans = r*r*M_PI/<span class=\"number\">2</span>+r*r*<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf&quot;</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"k-headpho\">K-Headpho</h1>\r\n<p>来源: 牛客多校训练营5 算法: 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33190/K 补完: Yes 完成时间: August\r\n26, 2022</p>\r\n<h2 id=\"题意-1\">题意</h2>\r\n<ul>\r\n<li>NIO和妹妹拿耳机</li>\r\n<li>共有<span class=\"math inline\">\\(n\\)</span>对耳机，妹妹已经拿了<span\r\nclass=\"math inline\">\\(k\\)</span>对</li>\r\n<li>剩下的耳机两人分，NIO一只一只拿</li>\r\n<li>问剩下的耳机中NIO至少要拿多少只才能拥有比妹妹多对的耳机？</li>\r\n</ul>\r\n<h2 id=\"解法-1\">解法</h2>\r\n<ul>\r\n<li>NIO最少要拿到<span\r\nclass=\"math inline\">\\(k+1\\)</span>对耳机，此时总的耳机对数就是<span\r\nclass=\"math inline\">\\(k+k+1\\)</span>，若<span\r\nclass=\"math inline\">\\(k+k+1&gt;n\\)</span>，说明NIO拿不到<span\r\nclass=\"math inline\">\\(k+1\\)</span>对，输出<span\r\nclass=\"math inline\">\\(-1\\)</span></li>\r\n<li>因为NIO是一只一只拿的，所以NIO拿的比妹妹多的最坏情况就是，NIO拿了一半多一个，这样妹妹就凑不到一半的耳机了</li>\r\n</ul>\r\n<h2 id=\"代码-6\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,k,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    ans=k<span class=\"number\">+1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans+k&gt;n)&#123;</span><br><span class=\"line\">        ans=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       ans=n<span class=\"number\">+1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营06","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# A-Array\n\n来源: 牛客多校训练营6\n算法: 构造\n补完: Yes\n完成时间: August 16, 2022\n\n## 题解\n\n给定$≥2$的正整数$a_1\\sim a_n$, 满足$\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12$, \n\n构造一个循环数列, 使得其任意长度为$a_i$的子区间都至少包含一个$i(1≤i≤n)$. \n\n即要求在循环中任意两个$i$的距离是小于等于$a_i$的\n\n转化原式子\n\n$$\n\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12\n$$\n\n为\n\n$$\n\\sum_{i=1}^n\\frac{1}{a_i/2}≤1\n$$\n\n对$a_i$的不大于其的最大的$2$的幂,即\n\n$$\na_i\\to2^{\\lfloor\\log_2a_i\\rfloor}\n$$\n\n有下式总是成立\n\n$$\n\\frac{a_i}{2}≤2^{\\lfloor\\log_2a_i\\rfloor}\n$$\n\n故有\n\n$$\n\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1\n$$\n\n---\n\neg.\n\n$a_1=3,a_2=12,a_3=24,a_4=24$\n\n下取整幂\n\n$a_1=2,a_2=8,a_3=16,a_4=16$\n\n即为每2步填一个1, 每8步填一个2, 每16步填一个3, 每16步填一个4\n\n12131410121010101\n\n在16个位置里填完所有数后仍有空位.\n\n---\n\n对想填的所有数有最大幂$2^k$, 对填入的任意一个数有$2^l≤2^k$, 这个数会占用$2^{k-l}$个位置, 填入的所有数有$\\sum 2^{k-l}$个,\n\n而 $\\sum 2^{k-l}=2^k\\sum\\frac1{2^l}$, 且上推出$\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1$, 固有\n\n$$\n\\sum 2^{k-l}≤2^k\n$$\n\n那么总有空位可以填数\n\n将数据处理为幂次, 排序后构造. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint n,lim = MAXN;\nint ans[MAXN];\npair<int, int> a[MAXN];\n\nvoid solve() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        cin>>a[i].first;\n        int t = log2(a[i].first);\n        a[i].first  = (1<<t);\n        a[i].second = i;\n    }\n    sort(a+1, a+1+n);\n    int k = 1;\n    for (int i = 1; i <= n; i++) {\n        while (ans[k])k++;\n        for (int j = k; j <= lim; j+=a[i].first) {\n            ans[j] = a[i].second;\n        }\n    }\n    printf(\"%d\\n\",k);\n    for (int i = 1; ans[i]; i++) {\n        printf(\"%d \",ans[i]);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# B-Eezie and Pie\n\n来源: 牛客多校训练营6\n算法: DFS, 树上差分\n补完: Yes\n完成时间: August 12, 2022\n\n## 题解\n\n有一颗$n$个点的树, 结点$i$上的食物可以送到从$i$走到$1$的简单路径上且距离不超过$d_i$的结点, 问每个结点都能被送到多少食物. \n\n本题固定了食物只能向根节点方向送, 故考虑树上差分, 只需要在每个点上$+1$, 并在每个点的第$d_i$个祖先上$-1$即可.\n\n如何找到第$d_i$个祖先呢, 在DFS过程中程序会从上往下遍历, 只要在访问到每个节点的时候记录下来, 得到的就是一条从根结点出发的链, 在路径上即可访问到祖先.当没有那么多祖先时, 就不操作. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2000005;\n\nvector<int> e[MAXN];\nvector<int> d(MAXN);\nvector<int> s(MAXN);\nvector<int> path;\n\nvoid dfs(int u,int f){\n    path.push_back(u);\n    s[u]++;\n    s[path[max(-1,(int)(path.size()-2-d[u]))]]--;\n    for (auto v: e[u]) {\n        if(v==f)continue;\n        dfs(v,u);\n        s[u] += s[v];\n    }\n    path.pop_back();\n}\nvoid solve() {\n    int n;\n    cin>>n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    d.push_back(0);\n    for (int i = 1; i <= n; i++) {\n        cin>>d[i];\n    }\n    dfs(1,0);\n    for (int i = 1; i <= n; i++) {\n        cout<<s[i]<<\" \";\n    }\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# G-Icon Design\n\n来源: 牛客多校训练营6\n算法: 构造, 语法\n题目链接: https://ac.nowcoder.com/acm/contest/33191/G\n补完: Yes\n完成时间: August 6, 2022\n\n## 题解\n\n画字符画图像,一看$n≤5$,打表!\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstring ans[5] = {\n{\"\\\n********************************\\n\\\n*..............................*\\n\\\n*..@...@..@@@@@..@......@@@@@..*\\n\\\n*..@@..@..@......@......@......*\\n\\\n*..@.@.@..@@@@@..@......@@@@@..*\\n\\\n*..@..@@..@......@..........@..*\\n\\\n*..@...@..@......@@@@@..@@@@@..*\\n\\\n*..............................*\\n\\\n********************************\"},\n{\"\\\n*********************************************\\n\\\n*...........................................*\\n\\\n*...........................................*\\n\\\n*...@.....@...@@@@@@@...@.........@@@@@@@...*\\n\\\n*...@@....@...@.........@.........@.........*\\n\\\n*...@.@...@...@.........@.........@.........*\\n\\\n*...@..@..@...@@@@@@@...@.........@@@@@@@...*\\n\\\n*...@...@.@...@.........@...............@...*\\n\\\n*...@....@@...@.........@...............@...*\\n\\\n*...@.....@...@.........@@@@@@@...@@@@@@@...*\\n\\\n*...........................................*\\n\\\n*...........................................*\\n\\\n*********************************************\"},\n{\"\\\n**********************************************************\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n*....@.......@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\\n*....@@......@....@............@............@............*\\n\\\n*....@.@.....@....@............@............@............*\\n\\\n*....@..@....@....@............@............@............*\\n\\\n*....@...@...@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\\n*....@....@..@....@............@....................@....*\\n\\\n*....@.....@.@....@............@....................@....*\\n\\\n*....@......@@....@............@....................@....*\\n\\\n*....@.......@....@............@@@@@@@@@....@@@@@@@@@....*\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n**********************************************************\"},\n{\"\\\n***********************************************************************\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....@.........@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\\n*.....@@........@.....@...............@...............@...............*\\n\\\n*.....@.@.......@.....@...............@...............@...............*\\n\\\n*.....@..@......@.....@...............@...............@...............*\\n\\\n*.....@...@.....@.....@...............@...............@...............*\\n\\\n*.....@....@....@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\\n*.....@.....@...@.....@...............@.........................@.....*\\n\\\n*.....@......@..@.....@...............@.........................@.....*\\n\\\n*.....@.......@.@.....@...............@.........................@.....*\\n\\\n*.....@........@@.....@...............@.........................@.....*\\n\\\n*.....@.........@.....@...............@@@@@@@@@@@.....@@@@@@@@@@@.....*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n***********************************************************************\"},\n{\"\\\n************************************************************************************\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*......@...........@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\\n*......@@..........@......@..................@..................@..................*\\n\\\n*......@.@.........@......@..................@..................@..................*\\n\\\n*......@..@........@......@..................@..................@..................*\\n\\\n*......@...@.......@......@..................@..................@..................*\\n\\\n*......@....@......@......@..................@..................@..................*\\n\\\n*......@.....@.....@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\\n*......@......@....@......@..................@..............................@......*\\n\\\n*......@.......@...@......@..................@..............................@......*\\n\\\n*......@........@..@......@..................@..............................@......*\\n\\\n*......@.........@.@......@..................@..............................@......*\\n\\\n*......@..........@@......@..................@..............................@......*\\n\\\n*......@...........@......@..................@@@@@@@@@@@@@......@@@@@@@@@@@@@......*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n************************************************************************************\"},\n    };\n\nvoid solve() {\n    int n;\n    cin>>n;\n    cout<<ans[n-1];\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# J-Number Game\n\n来源: 牛客多校训练营6\n算法: 数论\n题目链接: https://ac.nowcoder.com/acm/contest/33191/J\n补完: Yes\n完成时间: August 6, 2022\n\n## 题解\n\n给数字$A,B,C,x$, 和操作$B = A-B,C = B-C$,判断能否让$C==x$\n\n画图找可能产生的$C$值\n\n[Geogebra](https://www.geogebra.org/geometry/skv6e5hr)\n\n![动画3.gif](J-Number%20Game%20fa5e4563f4004ed09c3429452faa8331/%25E5%258A%25A8%25E7%2594%25BB3.gif)\n\n$$\nC_0=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C_0\\\\\nC_1=B_0-C_0= ~~~~~~~~~~~~~~~B_0-C_0\\\\\nC_2=B_1-C_0= ~~~~~A-~~B_0-C_0\\\\\nC_3=B_1-C_1= ~~~~~A-2B_0+C_0\\\\\nC_4=B_0-C_2= -~~A+2B_0+C_0\\\\\nC_5=B_0-C_3= -~~A+3B_0-C_0\\\\\nC_6=B_1-C_4= ~~~2A-3B_0-C_0\\\\\nC_7=B_1-C_5= ~~~2A-4B_0+C_0\\\\\nC_8=B_0-C_6= -2A+4B_0+C_0\\\\\nC_9=B_0-C_7= -2A+5B_0-C_0\\\\\\dots\n$$\n\n观察化简可得$x$通项公式\n\n$$\nn(A-2B)+C~~~~~~~~=x\\\\\nn(A-2B)-C+B=x\n$$\n\n若存在$n$使得等式满足即可\n\n$$\nn=\\frac{x-C~~~~~~~~}{A-2B}\\\\\nn=\\frac{x+C-B}{A-2B}\n$$\n\n注意特判$A-2B==0$情况, \n\n公式上此时无法进行除法操作, \n\n物理上此时有$B_0==B_1$无法产生新类型的$C$, 仅存在$C_0$和$C_1$. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n    int A,B,C,x;\n    cin>>A>>B>>C>>x;\n    if(A==2*B){\n        if(x==C || x==B-C) \n            printf(\"Yes\\n\");\n        else \n            printf(\"No\\n\");\n    }\n    else {\n        if((x-C)%(A-2*B)==0 || (x-B+C)%(A-2*B)==0) \n            printf(\"Yes\\n\");\n        else \n            printf(\"No\\n\");\n    }\n}\n\nint main() {\n    int T = 1;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营06.md","raw":"---\ntitle: 2022牛客多校训练营06\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# A-Array\n\n来源: 牛客多校训练营6\n算法: 构造\n补完: Yes\n完成时间: August 16, 2022\n\n## 题解\n\n给定$≥2$的正整数$a_1\\sim a_n$, 满足$\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12$, \n\n构造一个循环数列, 使得其任意长度为$a_i$的子区间都至少包含一个$i(1≤i≤n)$. \n\n即要求在循环中任意两个$i$的距离是小于等于$a_i$的\n\n转化原式子\n\n$$\n\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12\n$$\n\n为\n\n$$\n\\sum_{i=1}^n\\frac{1}{a_i/2}≤1\n$$\n\n对$a_i$的不大于其的最大的$2$的幂,即\n\n$$\na_i\\to2^{\\lfloor\\log_2a_i\\rfloor}\n$$\n\n有下式总是成立\n\n$$\n\\frac{a_i}{2}≤2^{\\lfloor\\log_2a_i\\rfloor}\n$$\n\n故有\n\n$$\n\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1\n$$\n\n---\n\neg.\n\n$a_1=3,a_2=12,a_3=24,a_4=24$\n\n下取整幂\n\n$a_1=2,a_2=8,a_3=16,a_4=16$\n\n即为每2步填一个1, 每8步填一个2, 每16步填一个3, 每16步填一个4\n\n12131410121010101\n\n在16个位置里填完所有数后仍有空位.\n\n---\n\n对想填的所有数有最大幂$2^k$, 对填入的任意一个数有$2^l≤2^k$, 这个数会占用$2^{k-l}$个位置, 填入的所有数有$\\sum 2^{k-l}$个,\n\n而 $\\sum 2^{k-l}=2^k\\sum\\frac1{2^l}$, 且上推出$\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1$, 固有\n\n$$\n\\sum 2^{k-l}≤2^k\n$$\n\n那么总有空位可以填数\n\n将数据处理为幂次, 排序后构造. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint n,lim = MAXN;\nint ans[MAXN];\npair<int, int> a[MAXN];\n\nvoid solve() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        cin>>a[i].first;\n        int t = log2(a[i].first);\n        a[i].first  = (1<<t);\n        a[i].second = i;\n    }\n    sort(a+1, a+1+n);\n    int k = 1;\n    for (int i = 1; i <= n; i++) {\n        while (ans[k])k++;\n        for (int j = k; j <= lim; j+=a[i].first) {\n            ans[j] = a[i].second;\n        }\n    }\n    printf(\"%d\\n\",k);\n    for (int i = 1; ans[i]; i++) {\n        printf(\"%d \",ans[i]);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# B-Eezie and Pie\n\n来源: 牛客多校训练营6\n算法: DFS, 树上差分\n补完: Yes\n完成时间: August 12, 2022\n\n## 题解\n\n有一颗$n$个点的树, 结点$i$上的食物可以送到从$i$走到$1$的简单路径上且距离不超过$d_i$的结点, 问每个结点都能被送到多少食物. \n\n本题固定了食物只能向根节点方向送, 故考虑树上差分, 只需要在每个点上$+1$, 并在每个点的第$d_i$个祖先上$-1$即可.\n\n如何找到第$d_i$个祖先呢, 在DFS过程中程序会从上往下遍历, 只要在访问到每个节点的时候记录下来, 得到的就是一条从根结点出发的链, 在路径上即可访问到祖先.当没有那么多祖先时, 就不操作. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2000005;\n\nvector<int> e[MAXN];\nvector<int> d(MAXN);\nvector<int> s(MAXN);\nvector<int> path;\n\nvoid dfs(int u,int f){\n    path.push_back(u);\n    s[u]++;\n    s[path[max(-1,(int)(path.size()-2-d[u]))]]--;\n    for (auto v: e[u]) {\n        if(v==f)continue;\n        dfs(v,u);\n        s[u] += s[v];\n    }\n    path.pop_back();\n}\nvoid solve() {\n    int n;\n    cin>>n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    d.push_back(0);\n    for (int i = 1; i <= n; i++) {\n        cin>>d[i];\n    }\n    dfs(1,0);\n    for (int i = 1; i <= n; i++) {\n        cout<<s[i]<<\" \";\n    }\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# G-Icon Design\n\n来源: 牛客多校训练营6\n算法: 构造, 语法\n题目链接: https://ac.nowcoder.com/acm/contest/33191/G\n补完: Yes\n完成时间: August 6, 2022\n\n## 题解\n\n画字符画图像,一看$n≤5$,打表!\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstring ans[5] = {\n{\"\\\n********************************\\n\\\n*..............................*\\n\\\n*..@...@..@@@@@..@......@@@@@..*\\n\\\n*..@@..@..@......@......@......*\\n\\\n*..@.@.@..@@@@@..@......@@@@@..*\\n\\\n*..@..@@..@......@..........@..*\\n\\\n*..@...@..@......@@@@@..@@@@@..*\\n\\\n*..............................*\\n\\\n********************************\"},\n{\"\\\n*********************************************\\n\\\n*...........................................*\\n\\\n*...........................................*\\n\\\n*...@.....@...@@@@@@@...@.........@@@@@@@...*\\n\\\n*...@@....@...@.........@.........@.........*\\n\\\n*...@.@...@...@.........@.........@.........*\\n\\\n*...@..@..@...@@@@@@@...@.........@@@@@@@...*\\n\\\n*...@...@.@...@.........@...............@...*\\n\\\n*...@....@@...@.........@...............@...*\\n\\\n*...@.....@...@.........@@@@@@@...@@@@@@@...*\\n\\\n*...........................................*\\n\\\n*...........................................*\\n\\\n*********************************************\"},\n{\"\\\n**********************************************************\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n*....@.......@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\\n*....@@......@....@............@............@............*\\n\\\n*....@.@.....@....@............@............@............*\\n\\\n*....@..@....@....@............@............@............*\\n\\\n*....@...@...@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\\n*....@....@..@....@............@....................@....*\\n\\\n*....@.....@.@....@............@....................@....*\\n\\\n*....@......@@....@............@....................@....*\\n\\\n*....@.......@....@............@@@@@@@@@....@@@@@@@@@....*\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n*........................................................*\\n\\\n**********************************************************\"},\n{\"\\\n***********************************************************************\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....@.........@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\\n*.....@@........@.....@...............@...............@...............*\\n\\\n*.....@.@.......@.....@...............@...............@...............*\\n\\\n*.....@..@......@.....@...............@...............@...............*\\n\\\n*.....@...@.....@.....@...............@...............@...............*\\n\\\n*.....@....@....@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\\n*.....@.....@...@.....@...............@.........................@.....*\\n\\\n*.....@......@..@.....@...............@.........................@.....*\\n\\\n*.....@.......@.@.....@...............@.........................@.....*\\n\\\n*.....@........@@.....@...............@.........................@.....*\\n\\\n*.....@.........@.....@...............@@@@@@@@@@@.....@@@@@@@@@@@.....*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n*.....................................................................*\\n\\\n***********************************************************************\"},\n{\"\\\n************************************************************************************\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*......@...........@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\\n*......@@..........@......@..................@..................@..................*\\n\\\n*......@.@.........@......@..................@..................@..................*\\n\\\n*......@..@........@......@..................@..................@..................*\\n\\\n*......@...@.......@......@..................@..................@..................*\\n\\\n*......@....@......@......@..................@..................@..................*\\n\\\n*......@.....@.....@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\\n*......@......@....@......@..................@..............................@......*\\n\\\n*......@.......@...@......@..................@..............................@......*\\n\\\n*......@........@..@......@..................@..............................@......*\\n\\\n*......@.........@.@......@..................@..............................@......*\\n\\\n*......@..........@@......@..................@..............................@......*\\n\\\n*......@...........@......@..................@@@@@@@@@@@@@......@@@@@@@@@@@@@......*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n*..................................................................................*\\n\\\n************************************************************************************\"},\n    };\n\nvoid solve() {\n    int n;\n    cin>>n;\n    cout<<ans[n-1];\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n# J-Number Game\n\n来源: 牛客多校训练营6\n算法: 数论\n题目链接: https://ac.nowcoder.com/acm/contest/33191/J\n补完: Yes\n完成时间: August 6, 2022\n\n## 题解\n\n给数字$A,B,C,x$, 和操作$B = A-B,C = B-C$,判断能否让$C==x$\n\n画图找可能产生的$C$值\n\n[Geogebra](https://www.geogebra.org/geometry/skv6e5hr)\n\n![动画3.gif](J-Number%20Game%20fa5e4563f4004ed09c3429452faa8331/%25E5%258A%25A8%25E7%2594%25BB3.gif)\n\n$$\nC_0=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C_0\\\\\nC_1=B_0-C_0= ~~~~~~~~~~~~~~~B_0-C_0\\\\\nC_2=B_1-C_0= ~~~~~A-~~B_0-C_0\\\\\nC_3=B_1-C_1= ~~~~~A-2B_0+C_0\\\\\nC_4=B_0-C_2= -~~A+2B_0+C_0\\\\\nC_5=B_0-C_3= -~~A+3B_0-C_0\\\\\nC_6=B_1-C_4= ~~~2A-3B_0-C_0\\\\\nC_7=B_1-C_5= ~~~2A-4B_0+C_0\\\\\nC_8=B_0-C_6= -2A+4B_0+C_0\\\\\nC_9=B_0-C_7= -2A+5B_0-C_0\\\\\\dots\n$$\n\n观察化简可得$x$通项公式\n\n$$\nn(A-2B)+C~~~~~~~~=x\\\\\nn(A-2B)-C+B=x\n$$\n\n若存在$n$使得等式满足即可\n\n$$\nn=\\frac{x-C~~~~~~~~}{A-2B}\\\\\nn=\\frac{x+C-B}{A-2B}\n$$\n\n注意特判$A-2B==0$情况, \n\n公式上此时无法进行除法操作, \n\n物理上此时有$B_0==B_1$无法产生新类型的$C$, 仅存在$C_0$和$C_1$. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n    int A,B,C,x;\n    cin>>A>>B>>C>>x;\n    if(A==2*B){\n        if(x==C || x==B-C) \n            printf(\"Yes\\n\");\n        else \n            printf(\"No\\n\");\n    }\n    else {\n        if((x-C)%(A-2*B)==0 || (x-B+C)%(A-2*B)==0) \n            printf(\"Yes\\n\");\n        else \n            printf(\"No\\n\");\n    }\n}\n\nint main() {\n    int T = 1;\n    cin>>T;\n    while(T--)solve();\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营06","published":1,"updated":"2023-10-29T06:35:52.827Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexd000fn0umb0yecpl3","content":"<h1 id=\"a-array\">A-Array</h1>\r\n<p>来源: 牛客多校训练营6 算法: 构造 补完: Yes 完成时间: August 16,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给定<span class=\"math inline\">\\(≥2\\)</span>的正整数<span\r\nclass=\"math inline\">\\(a_1\\sim a_n\\)</span>, 满足<span\r\nclass=\"math inline\">\\(\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12\\)</span>,</p>\r\n<p>构造一个循环数列, 使得其任意长度为<span\r\nclass=\"math inline\">\\(a_i\\)</span>的子区间都至少包含一个<span\r\nclass=\"math inline\">\\(i(1≤i≤n)\\)</span>.</p>\r\n<p>即要求在循环中任意两个<span\r\nclass=\"math inline\">\\(i\\)</span>的距离是小于等于<span\r\nclass=\"math inline\">\\(a_i\\)</span>的</p>\r\n<p>转化原式子</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12\r\n\\]</span></p>\r\n<p>为</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum_{i=1}^n\\frac{1}{a_i/2}≤1\r\n\\]</span></p>\r\n<p>对<span class=\"math inline\">\\(a_i\\)</span>的不大于其的最大的<span\r\nclass=\"math inline\">\\(2\\)</span>的幂,即</p>\r\n<p><span class=\"math display\">\\[\r\na_i\\to2^{\\lfloor\\log_2a_i\\rfloor}\r\n\\]</span></p>\r\n<p>有下式总是成立</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{a_i}{2}≤2^{\\lfloor\\log_2a_i\\rfloor}\r\n\\]</span></p>\r\n<p>故有</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1\r\n\\]</span></p>\r\n<hr />\r\n<p>eg.</p>\r\n<p><span class=\"math inline\">\\(a_1=3,a_2=12,a_3=24,a_4=24\\)</span></p>\r\n<p>下取整幂</p>\r\n<p><span class=\"math inline\">\\(a_1=2,a_2=8,a_3=16,a_4=16\\)</span></p>\r\n<p>即为每2步填一个1, 每8步填一个2, 每16步填一个3, 每16步填一个4</p>\r\n<p>12131410121010101</p>\r\n<p>在16个位置里填完所有数后仍有空位.</p>\r\n<hr />\r\n<p>对想填的所有数有最大幂<span class=\"math inline\">\\(2^k\\)</span>,\r\n对填入的任意一个数有<span class=\"math inline\">\\(2^l≤2^k\\)</span>,\r\n这个数会占用<span class=\"math inline\">\\(2^{k-l}\\)</span>个位置,\r\n填入的所有数有<span class=\"math inline\">\\(\\sum 2^{k-l}\\)</span>个,</p>\r\n<p>而 <span class=\"math inline\">\\(\\sum\r\n2^{k-l}=2^k\\sum\\frac1{2^l}\\)</span>, 且上推出<span\r\nclass=\"math inline\">\\(\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1\\)</span>,\r\n固有</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum 2^{k-l}≤2^k\r\n\\]</span></p>\r\n<p>那么总有空位可以填数</p>\r\n<p>将数据处理为幂次, 排序后构造.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,lim = MAXN;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[MAXN];</span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; a[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i].first;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"built_in\">log2</span>(a[i].first);</span><br><span class=\"line\">        a[i].first  = (<span class=\"number\">1</span>&lt;&lt;t);</span><br><span class=\"line\">        a[i].second = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>, a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">    <span class=\"type\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ans[k])k++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = k; j &lt;= lim; j+=a[i].first) &#123;</span><br><span class=\"line\">            ans[j] = a[i].second;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; ans[i]; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,ans[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"b-eezie-and-pie\">B-Eezie and Pie</h1>\r\n<p>来源: 牛客多校训练营6 算法: DFS, 树上差分 补完: Yes 完成时间: August\r\n12, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>有一颗<span class=\"math inline\">\\(n\\)</span>个点的树, 结点<span\r\nclass=\"math inline\">\\(i\\)</span>上的食物可以送到从<span\r\nclass=\"math inline\">\\(i\\)</span>走到<span\r\nclass=\"math inline\">\\(1\\)</span>的简单路径上且距离不超过<span\r\nclass=\"math inline\">\\(d_i\\)</span>的结点,\r\n问每个结点都能被送到多少食物.</p>\r\n<p>本题固定了食物只能向根节点方向送, 故考虑树上差分,\r\n只需要在每个点上<span class=\"math inline\">\\(+1\\)</span>,\r\n并在每个点的第<span class=\"math inline\">\\(d_i\\)</span>个祖先上<span\r\nclass=\"math inline\">\\(-1\\)</span>即可.</p>\r\n<p>如何找到第<span class=\"math inline\">\\(d_i\\)</span>个祖先呢,\r\n在DFS过程中程序会从上往下遍历, 只要在访问到每个节点的时候记录下来,\r\n得到的就是一条从根结点出发的链,\r\n在路径上即可访问到祖先.当没有那么多祖先时, 就不操作.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">2000005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">d</span><span class=\"params\">(MAXN)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">s</span><span class=\"params\">(MAXN)</span></span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">    path.<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    s[u]++;</span><br><span class=\"line\">    s[path[<span class=\"built_in\">max</span>(<span class=\"number\">-1</span>,(<span class=\"type\">int</span>)(path.<span class=\"built_in\">size</span>()<span class=\"number\">-2</span>-d[u]))]]--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">        s[u] += s[v];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u, v;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        e[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cout&lt;&lt;s[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-icon-design\">G-Icon Design</h1>\r\n<p>来源: 牛客多校训练营6 算法: 构造, 语法 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33191/G 补完: Yes 完成时间: August\r\n6, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>画字符画图像,一看<span class=\"math inline\">\\(n≤5\\)</span>,打表!</p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">string ans[<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">********************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..............................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@...@..@@@@@..@......@@@@@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@@..@..@......@......@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@.@.@..@@@@@..@......@@@@@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@..@@..@......@..........@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@...@..@......@@@@@..@@@@@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..............................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">********************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">*********************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@.....@...@@@@@@@...@.........@@@@@@@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@@....@...@.........@.........@.........*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@.@...@...@.........@.........@.........*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@..@..@...@@@@@@@...@.........@@@@@@@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@...@.@...@.........@...............@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@....@@...@.........@...............@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@.....@...@.........@@@@@@@...@@@@@@@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*********************************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">**********************************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.......@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@@......@....@............@............@............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.@.....@....@............@............@............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@..@....@....@............@............@............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@...@...@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@....@..@....@............@....................@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.....@.@....@............@....................@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@......@@....@............@....................@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.......@....@............@@@@@@@@@....@@@@@@@@@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">**********************************************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">***********************************************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.........@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@@........@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.@.......@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@..@......@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@...@.....@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@....@....@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.....@...@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@......@..@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.......@.@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@........@@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.........@.....@...............@@@@@@@@@@@.....@@@@@@@@@@@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">***********************************************************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">************************************************************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@...........@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@@..........@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.@.........@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@..@........@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@...@.......@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@....@......@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.....@.....@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@......@....@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.......@...@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@........@..@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.........@.@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@..........@@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@...........@......@..................@@@@@@@@@@@@@......@@@@@@@@@@@@@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">************************************************************************************&quot;</span>&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cout&lt;&lt;ans[n<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-number-game\">J-Number Game</h1>\r\n<p>来源: 牛客多校训练营6 算法: 数论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33191/J 补完: Yes 完成时间: August\r\n6, 2022</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>给数字<span class=\"math inline\">\\(A,B,C,x\\)</span>, 和操作<span\r\nclass=\"math inline\">\\(B = A-B,C = B-C\\)</span>,判断能否让<span\r\nclass=\"math inline\">\\(C==x\\)</span></p>\r\n<p>画图找可能产生的<span class=\"math inline\">\\(C\\)</span>值</p>\r\n<p><a href=\"https://www.geogebra.org/geometry/skv6e5hr\">Geogebra</a></p>\r\n<figure>\r\n<img\r\nsrc=\"J-Number%20Game%20fa5e4563f4004ed09c3429452faa8331/%25E5%258A%25A8%25E7%2594%25BB3.gif\"\r\nalt=\"动画3.gif\" />\r\n<figcaption aria-hidden=\"true\">动画3.gif</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\nC_0=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C_0\\\\\r\nC_1=B_0-C_0= ~~~~~~~~~~~~~~~B_0-C_0\\\\\r\nC_2=B_1-C_0= ~~~~~A-~~B_0-C_0\\\\\r\nC_3=B_1-C_1= ~~~~~A-2B_0+C_0\\\\\r\nC_4=B_0-C_2= -~~A+2B_0+C_0\\\\\r\nC_5=B_0-C_3= -~~A+3B_0-C_0\\\\\r\nC_6=B_1-C_4= ~~~2A-3B_0-C_0\\\\\r\nC_7=B_1-C_5= ~~~2A-4B_0+C_0\\\\\r\nC_8=B_0-C_6= -2A+4B_0+C_0\\\\\r\nC_9=B_0-C_7= -2A+5B_0-C_0\\\\\\dots\r\n\\]</span></p>\r\n<p>观察化简可得<span class=\"math inline\">\\(x\\)</span>通项公式</p>\r\n<p><span class=\"math display\">\\[\r\nn(A-2B)+C~~~~~~~~=x\\\\\r\nn(A-2B)-C+B=x\r\n\\]</span></p>\r\n<p>若存在<span class=\"math inline\">\\(n\\)</span>使得等式满足即可</p>\r\n<p><span class=\"math display\">\\[\r\nn=\\frac{x-C~~~~~~~~}{A-2B}\\\\\r\nn=\\frac{x+C-B}{A-2B}\r\n\\]</span></p>\r\n<p>注意特判<span class=\"math inline\">\\(A-2B==0\\)</span>情况,</p>\r\n<p>公式上此时无法进行除法操作,</p>\r\n<p>物理上此时有<span\r\nclass=\"math inline\">\\(B_0==B_1\\)</span>无法产生新类型的<span\r\nclass=\"math inline\">\\(C\\)</span>, 仅存在<span\r\nclass=\"math inline\">\\(C_0\\)</span>和<span\r\nclass=\"math inline\">\\(C_1\\)</span>.</p>\r\n<h2 id=\"代码-3\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> A,B,C,x;</span><br><span class=\"line\">    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A==<span class=\"number\">2</span>*B)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==C || x==B-C) </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((x-C)%(A<span class=\"number\">-2</span>*B)==<span class=\"number\">0</span> || (x-B+C)%(A<span class=\"number\">-2</span>*B)==<span class=\"number\">0</span>) </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"a-array\">A-Array</h1>\r\n<p>来源: 牛客多校训练营6 算法: 构造 补完: Yes 完成时间: August 16,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给定<span class=\"math inline\">\\(≥2\\)</span>的正整数<span\r\nclass=\"math inline\">\\(a_1\\sim a_n\\)</span>, 满足<span\r\nclass=\"math inline\">\\(\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12\\)</span>,</p>\r\n<p>构造一个循环数列, 使得其任意长度为<span\r\nclass=\"math inline\">\\(a_i\\)</span>的子区间都至少包含一个<span\r\nclass=\"math inline\">\\(i(1≤i≤n)\\)</span>.</p>\r\n<p>即要求在循环中任意两个<span\r\nclass=\"math inline\">\\(i\\)</span>的距离是小于等于<span\r\nclass=\"math inline\">\\(a_i\\)</span>的</p>\r\n<p>转化原式子</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum_{i=1}^n\\frac{1}{a_i}≤\\frac12\r\n\\]</span></p>\r\n<p>为</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum_{i=1}^n\\frac{1}{a_i/2}≤1\r\n\\]</span></p>\r\n<p>对<span class=\"math inline\">\\(a_i\\)</span>的不大于其的最大的<span\r\nclass=\"math inline\">\\(2\\)</span>的幂,即</p>\r\n<p><span class=\"math display\">\\[\r\na_i\\to2^{\\lfloor\\log_2a_i\\rfloor}\r\n\\]</span></p>\r\n<p>有下式总是成立</p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{a_i}{2}≤2^{\\lfloor\\log_2a_i\\rfloor}\r\n\\]</span></p>\r\n<p>故有</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1\r\n\\]</span></p>\r\n<hr />\r\n<p>eg.</p>\r\n<p><span class=\"math inline\">\\(a_1=3,a_2=12,a_3=24,a_4=24\\)</span></p>\r\n<p>下取整幂</p>\r\n<p><span class=\"math inline\">\\(a_1=2,a_2=8,a_3=16,a_4=16\\)</span></p>\r\n<p>即为每2步填一个1, 每8步填一个2, 每16步填一个3, 每16步填一个4</p>\r\n<p>12131410121010101</p>\r\n<p>在16个位置里填完所有数后仍有空位.</p>\r\n<hr />\r\n<p>对想填的所有数有最大幂<span class=\"math inline\">\\(2^k\\)</span>,\r\n对填入的任意一个数有<span class=\"math inline\">\\(2^l≤2^k\\)</span>,\r\n这个数会占用<span class=\"math inline\">\\(2^{k-l}\\)</span>个位置,\r\n填入的所有数有<span class=\"math inline\">\\(\\sum 2^{k-l}\\)</span>个,</p>\r\n<p>而 <span class=\"math inline\">\\(\\sum\r\n2^{k-l}=2^k\\sum\\frac1{2^l}\\)</span>, 且上推出<span\r\nclass=\"math inline\">\\(\\sum_{i=1}^n\\frac{1}{2^{\\lfloor\\log_2a_i\\rfloor}}≤1\\)</span>,\r\n固有</p>\r\n<p><span class=\"math display\">\\[\r\n\\sum 2^{k-l}≤2^k\r\n\\]</span></p>\r\n<p>那么总有空位可以填数</p>\r\n<p>将数据处理为幂次, 排序后构造.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,lim = MAXN;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[MAXN];</span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; a[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i].first;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"built_in\">log2</span>(a[i].first);</span><br><span class=\"line\">        a[i].first  = (<span class=\"number\">1</span>&lt;&lt;t);</span><br><span class=\"line\">        a[i].second = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a<span class=\"number\">+1</span>, a<span class=\"number\">+1</span>+n);</span><br><span class=\"line\">    <span class=\"type\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ans[k])k++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = k; j &lt;= lim; j+=a[i].first) &#123;</span><br><span class=\"line\">            ans[j] = a[i].second;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; ans[i]; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,ans[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"b-eezie-and-pie\">B-Eezie and Pie</h1>\r\n<p>来源: 牛客多校训练营6 算法: DFS, 树上差分 补完: Yes 完成时间: August\r\n12, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>有一颗<span class=\"math inline\">\\(n\\)</span>个点的树, 结点<span\r\nclass=\"math inline\">\\(i\\)</span>上的食物可以送到从<span\r\nclass=\"math inline\">\\(i\\)</span>走到<span\r\nclass=\"math inline\">\\(1\\)</span>的简单路径上且距离不超过<span\r\nclass=\"math inline\">\\(d_i\\)</span>的结点,\r\n问每个结点都能被送到多少食物.</p>\r\n<p>本题固定了食物只能向根节点方向送, 故考虑树上差分,\r\n只需要在每个点上<span class=\"math inline\">\\(+1\\)</span>,\r\n并在每个点的第<span class=\"math inline\">\\(d_i\\)</span>个祖先上<span\r\nclass=\"math inline\">\\(-1\\)</span>即可.</p>\r\n<p>如何找到第<span class=\"math inline\">\\(d_i\\)</span>个祖先呢,\r\n在DFS过程中程序会从上往下遍历, 只要在访问到每个节点的时候记录下来,\r\n得到的就是一条从根结点出发的链,\r\n在路径上即可访问到祖先.当没有那么多祖先时, 就不操作.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">2000005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">d</span><span class=\"params\">(MAXN)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">s</span><span class=\"params\">(MAXN)</span></span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">    path.<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    s[u]++;</span><br><span class=\"line\">    s[path[<span class=\"built_in\">max</span>(<span class=\"number\">-1</span>,(<span class=\"type\">int</span>)(path.<span class=\"built_in\">size</span>()<span class=\"number\">-2</span>-d[u]))]]--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v: e[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==f)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">        s[u] += s[v];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u, v;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        e[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cout&lt;&lt;s[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"g-icon-design\">G-Icon Design</h1>\r\n<p>来源: 牛客多校训练营6 算法: 构造, 语法 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33191/G 补完: Yes 完成时间: August\r\n6, 2022</p>\r\n<h2 id=\"题解-2\">题解</h2>\r\n<p>画字符画图像,一看<span class=\"math inline\">\\(n≤5\\)</span>,打表!</p>\r\n<h2 id=\"代码-2\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">string ans[<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">********************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..............................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@...@..@@@@@..@......@@@@@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@@..@..@......@......@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@.@.@..@@@@@..@......@@@@@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@..@@..@......@..........@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..@...@..@......@@@@@..@@@@@..*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..............................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">********************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">*********************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@.....@...@@@@@@@...@.........@@@@@@@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@@....@...@.........@.........@.........*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@.@...@...@.........@.........@.........*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@..@..@...@@@@@@@...@.........@@@@@@@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@...@.@...@.........@...............@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@....@@...@.........@...............@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...@.....@...@.........@@@@@@@...@@@@@@@...*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*...........................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*********************************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">**********************************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.......@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@@......@....@............@............@............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.@.....@....@............@............@............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@..@....@....@............@............@............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@...@...@....@@@@@@@@@....@............@@@@@@@@@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@....@..@....@............@....................@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.....@.@....@............@....................@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@......@@....@............@....................@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*....@.......@....@............@@@@@@@@@....@@@@@@@@@....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*........................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">**********************************************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">***********************************************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.........@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@@........@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.@.......@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@..@......@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@...@.....@.....@...............@...............@...............*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@....@....@.....@@@@@@@@@@@.....@...............@@@@@@@@@@@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.....@...@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@......@..@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.......@.@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@........@@.....@...............@.........................@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....@.........@.....@...............@@@@@@@@@@@.....@@@@@@@@@@@.....*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*.....................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">***********************************************************************&quot;</span>&#125;,</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;\\</span></span><br><span class=\"line\"><span class=\"string\">************************************************************************************\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@...........@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@@..........@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.@.........@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@..@........@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@...@.......@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@....@......@......@..................@..................@..................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.....@.....@......@@@@@@@@@@@@@......@..................@@@@@@@@@@@@@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@......@....@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.......@...@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@........@..@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@.........@.@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@..........@@......@..................@..............................@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*......@...........@......@..................@@@@@@@@@@@@@......@@@@@@@@@@@@@......*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">*..................................................................................*\\n\\</span></span><br><span class=\"line\"><span class=\"string\">************************************************************************************&quot;</span>&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    cout&lt;&lt;ans[n<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"j-number-game\">J-Number Game</h1>\r\n<p>来源: 牛客多校训练营6 算法: 数论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33191/J 补完: Yes 完成时间: August\r\n6, 2022</p>\r\n<h2 id=\"题解-3\">题解</h2>\r\n<p>给数字<span class=\"math inline\">\\(A,B,C,x\\)</span>, 和操作<span\r\nclass=\"math inline\">\\(B = A-B,C = B-C\\)</span>,判断能否让<span\r\nclass=\"math inline\">\\(C==x\\)</span></p>\r\n<p>画图找可能产生的<span class=\"math inline\">\\(C\\)</span>值</p>\r\n<p><a href=\"https://www.geogebra.org/geometry/skv6e5hr\">Geogebra</a></p>\r\n<figure>\r\n<img\r\nsrc=\"J-Number%20Game%20fa5e4563f4004ed09c3429452faa8331/%25E5%258A%25A8%25E7%2594%25BB3.gif\"\r\nalt=\"动画3.gif\" />\r\n<figcaption aria-hidden=\"true\">动画3.gif</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\nC_0=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C_0\\\\\r\nC_1=B_0-C_0= ~~~~~~~~~~~~~~~B_0-C_0\\\\\r\nC_2=B_1-C_0= ~~~~~A-~~B_0-C_0\\\\\r\nC_3=B_1-C_1= ~~~~~A-2B_0+C_0\\\\\r\nC_4=B_0-C_2= -~~A+2B_0+C_0\\\\\r\nC_5=B_0-C_3= -~~A+3B_0-C_0\\\\\r\nC_6=B_1-C_4= ~~~2A-3B_0-C_0\\\\\r\nC_7=B_1-C_5= ~~~2A-4B_0+C_0\\\\\r\nC_8=B_0-C_6= -2A+4B_0+C_0\\\\\r\nC_9=B_0-C_7= -2A+5B_0-C_0\\\\\\dots\r\n\\]</span></p>\r\n<p>观察化简可得<span class=\"math inline\">\\(x\\)</span>通项公式</p>\r\n<p><span class=\"math display\">\\[\r\nn(A-2B)+C~~~~~~~~=x\\\\\r\nn(A-2B)-C+B=x\r\n\\]</span></p>\r\n<p>若存在<span class=\"math inline\">\\(n\\)</span>使得等式满足即可</p>\r\n<p><span class=\"math display\">\\[\r\nn=\\frac{x-C~~~~~~~~}{A-2B}\\\\\r\nn=\\frac{x+C-B}{A-2B}\r\n\\]</span></p>\r\n<p>注意特判<span class=\"math inline\">\\(A-2B==0\\)</span>情况,</p>\r\n<p>公式上此时无法进行除法操作,</p>\r\n<p>物理上此时有<span\r\nclass=\"math inline\">\\(B_0==B_1\\)</span>无法产生新类型的<span\r\nclass=\"math inline\">\\(C\\)</span>, 仅存在<span\r\nclass=\"math inline\">\\(C_0\\)</span>和<span\r\nclass=\"math inline\">\\(C_1\\)</span>.</p>\r\n<h2 id=\"代码-3\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> A,B,C,x;</span><br><span class=\"line\">    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A==<span class=\"number\">2</span>*B)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==C || x==B-C) </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((x-C)%(A<span class=\"number\">-2</span>*B)==<span class=\"number\">0</span> || (x-B+C)%(A<span class=\"number\">-2</span>*B)==<span class=\"number\">0</span>) </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T--)<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营07","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# F-Candies\n\n来源: 牛客多校训练营7\n算法: 双端队列, 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33192/F\n补完: Yes\n完成时间: August 25, 2022\n\n## 题解\n\n给长度为$n$的数列$a[i]$和$x$, 若有$a[i]==a[(i+1)\\%n]$或$a[i]+a[(i+1)\\%]==x$, 则可以将此两数删去, 问最大可删除次数. \n\n直接使用双端队列模拟, 循环遍历每两个数直到比无可比. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nint n, x;\nint ans = 0;\n\nvoid solve() {\n    cin>>n>>x;\n    int a;\n    deque<int> A;\n    for (int i = 1; i <= n; i++) {\n        cin>>a;\n        A.push_back(a);\n    }\n    for (int i = 0; i <= MAXN; i++) {\n        if (A.size()<=1)break;\n        if (A.front()==A.back() || A.front()+A.back()==x) {\n            ans++;\n            A.pop_back();\n            A.pop_front();\n        }\n        else {\n            A.push_back(A.front());\n            A.pop_front();\n        }\n    }\n    cout<<ans;\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营07.md","raw":"---\ntitle: 2022牛客多校训练营07\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# F-Candies\n\n来源: 牛客多校训练营7\n算法: 双端队列, 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33192/F\n补完: Yes\n完成时间: August 25, 2022\n\n## 题解\n\n给长度为$n$的数列$a[i]$和$x$, 若有$a[i]==a[(i+1)\\%n]$或$a[i]+a[(i+1)\\%]==x$, 则可以将此两数删去, 问最大可删除次数. \n\n直接使用双端队列模拟, 循环遍历每两个数直到比无可比. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nint n, x;\nint ans = 0;\n\nvoid solve() {\n    cin>>n>>x;\n    int a;\n    deque<int> A;\n    for (int i = 1; i <= n; i++) {\n        cin>>a;\n        A.push_back(a);\n    }\n    for (int i = 0; i <= MAXN; i++) {\n        if (A.size()<=1)break;\n        if (A.front()==A.back() || A.front()+A.back()==x) {\n            ans++;\n            A.pop_back();\n            A.pop_front();\n        }\n        else {\n            A.push_back(A.front());\n            A.pop_front();\n        }\n    }\n    cout<<ans;\n}\n\nint main() {\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营07","published":1,"updated":"2023-10-29T06:31:20.304Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexd000gn0umcxx204ib","content":"<h1 id=\"f-candies\">F-Candies</h1>\r\n<p>来源: 牛客多校训练营7 算法: 双端队列, 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33192/F 补完: Yes 完成时间: August\r\n25, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给长度为<span class=\"math inline\">\\(n\\)</span>的数列<span\r\nclass=\"math inline\">\\(a[i]\\)</span>和<span\r\nclass=\"math inline\">\\(x\\)</span>, 若有<span\r\nclass=\"math inline\">\\(a[i]==a[(i+1)\\%n]\\)</span>或<span\r\nclass=\"math inline\">\\(a[i]+a[(i+1)\\%]==x\\)</span>, 则可以将此两数删去,\r\n问最大可删除次数.</p>\r\n<p>直接使用双端队列模拟, 循环遍历每两个数直到比无可比.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, x;</span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; A;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a;</span><br><span class=\"line\">        A.<span class=\"built_in\">push_back</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAXN; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A.<span class=\"built_in\">size</span>()&lt;=<span class=\"number\">1</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A.<span class=\"built_in\">front</span>()==A.<span class=\"built_in\">back</span>() || A.<span class=\"built_in\">front</span>()+A.<span class=\"built_in\">back</span>()==x) &#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            A.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            A.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            A.<span class=\"built_in\">push_back</span>(A.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            A.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"f-candies\">F-Candies</h1>\r\n<p>来源: 牛客多校训练营7 算法: 双端队列, 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33192/F 补完: Yes 完成时间: August\r\n25, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给长度为<span class=\"math inline\">\\(n\\)</span>的数列<span\r\nclass=\"math inline\">\\(a[i]\\)</span>和<span\r\nclass=\"math inline\">\\(x\\)</span>, 若有<span\r\nclass=\"math inline\">\\(a[i]==a[(i+1)\\%n]\\)</span>或<span\r\nclass=\"math inline\">\\(a[i]+a[(i+1)\\%]==x\\)</span>, 则可以将此两数删去,\r\n问最大可删除次数.</p>\r\n<p>直接使用双端队列模拟, 循环遍历每两个数直到比无可比.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n, x;</span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; A;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a;</span><br><span class=\"line\">        A.<span class=\"built_in\">push_back</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAXN; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A.<span class=\"built_in\">size</span>()&lt;=<span class=\"number\">1</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A.<span class=\"built_in\">front</span>()==A.<span class=\"built_in\">back</span>() || A.<span class=\"built_in\">front</span>()+A.<span class=\"built_in\">back</span>()==x) &#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            A.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            A.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            A.<span class=\"built_in\">push_back</span>(A.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            A.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营08","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# F-Longest Common Subsequence\n\n来源: 牛客多校训练营8\n算法: LCS\n题目链接: https://ac.nowcoder.com/acm/contest/33193/F\n补完: Yes\n完成时间: August 13, 2022\n\n## 题解\n\n给公式\n\n$$\nx_{i+1}=(ax_i^2+bx_i+c)\\%P\n$$\n\n给参数$n,m,P,x_0,a,b,c$\n\n取$x_1\\sim x_n$为第一个序列, 取$x_{n+1}\\sim x_{n+m}$为第二个序列, 求最长公共子序列.\n\n易发现$x_i$在迭代过程中可能回归, 当有$x_i==x_j$时, 以$x_i$为起点的$t=j-i$个数字为一个循环节, 自$x_i$开始反复出现, 有$x_{i+k}==x_{i+k+lt}(k≤t,l\\in N)$.定义第一个循环节的起点为$x_{begin}$\n\n故若有循环节起点$x_{begin}$落在$x_1\\sim x_n$范围内且循环节终点落在$x_{1}\\sim x_{n+m}$范围内时, 两序列会有公共子序列,且公共子序列为循环结的不断重复.若无循环节在范围内出现则无公共子序列. \n\n以$x_{begin}$为起点的循环节不断重复出现, 若第一个序列的最后一个元素是$x_{n}=x_{begin+k}$, 则第二个序列的第一个元素是$x_{n+1}=x_{begin+k+1}$, 则第二个序列第第一次出现循环节第一个元素$x_{begin}$的位置是$x_{begin}=x_{n+(t-k)}$.或者说会有循环节被$x_n$打断, 其左边有$llen$个元素, 其右边有$rlen$个元素,即$llen = k,rlen=t-k$.\n\n1. 考虑优先匹配第一个序列中的循环节, 则确定公共子序列的起点元素为$x_{begin}$, \n    \n    对应第一个序列中最大可能匹配起点为$x_i$, 最大可能匹配终点为$x_n$. 故在第一个序列中有最大匹配长度$nlen = n-begin+1$. \n    \n    对应到第二个序列中, 最大可能匹配起点为$x_{n+(t-k)}$, 最大可能匹配终点为$x_{n+m}$. 故在第二个序列中有最大匹配长度$mlen-rlen$. \n    \n    取小者为最长公共子序列长度.\n    \n    $$\n    \\min(mlen-rlen,nlen)\n    $$\n    \n2. 考虑优先匹配第二个序列中的循环节, 则确定公共子序列的起点元素为$x_{llen+1}$, \n    \n    对应第一个序列中最大可能匹配起点为$x_{begin+llen}$, 最大可能匹配终点为$x_n$, 故子第一个序列中有最大匹配长度$nlen-llen$\n    \n    对应到第二个序列中, 最大可能匹配起点为$x_{n+1}$, 最大可能匹配终点为$x_{n+m}$. 故在第二个序列中有最大匹配长度$mlen$. \n    \n    取小者为最长公共子序列长度.\n    \n    $$\n    \\min(nlen-llen,mlen)\n    $$\n    \n\n两者再取大者即为最长公共子序列长度\n\n$$\n\\max\\left(\\min(mlen-rlen,nlen),\\min(nlen-llen,mlen)\\right)\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nunordered_map<ll, ll> mmap;\nll n,m,P,x,a,b,c;\n\nll add(ll a, ll b){\n    return (a+b)%P;\n}\n\nll mul(ll a, ll b){\n    return (a*b)%P;\n}\n\nll next(ll x){\n    return add(add(mul(a,mul(x,x)),mul(b,x)),c);\n}\n\nvoid solve() {\n    mmap.clear();\n    cin>>n>>m>>P>>x>>a>>b>>c;\n    for (ll i = 1; i <= n+m; i++){\n        x = next(x);\n        if (mmap[x] != 0) {\n            ll begin = mmap[x];\n            if(begin>n)break;\n            ll t = i - begin;\n            ll nlen = n-begin+1;\n            ll llen = nlen%t;\n            ll rlen = t - llen;\n            cout<<max(min(nlen-llen,m),min(m-rlen,nlen))<<\"\\n\";\n            return;\n        }\n        else { \n            mmap[x] = i;\n        }\n    }\n    cout<<\"0\"<<\"\\n\";\n}\n\nint main() {\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营08.md","raw":"---\ntitle: 2022牛客多校训练营08\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# F-Longest Common Subsequence\n\n来源: 牛客多校训练营8\n算法: LCS\n题目链接: https://ac.nowcoder.com/acm/contest/33193/F\n补完: Yes\n完成时间: August 13, 2022\n\n## 题解\n\n给公式\n\n$$\nx_{i+1}=(ax_i^2+bx_i+c)\\%P\n$$\n\n给参数$n,m,P,x_0,a,b,c$\n\n取$x_1\\sim x_n$为第一个序列, 取$x_{n+1}\\sim x_{n+m}$为第二个序列, 求最长公共子序列.\n\n易发现$x_i$在迭代过程中可能回归, 当有$x_i==x_j$时, 以$x_i$为起点的$t=j-i$个数字为一个循环节, 自$x_i$开始反复出现, 有$x_{i+k}==x_{i+k+lt}(k≤t,l\\in N)$.定义第一个循环节的起点为$x_{begin}$\n\n故若有循环节起点$x_{begin}$落在$x_1\\sim x_n$范围内且循环节终点落在$x_{1}\\sim x_{n+m}$范围内时, 两序列会有公共子序列,且公共子序列为循环结的不断重复.若无循环节在范围内出现则无公共子序列. \n\n以$x_{begin}$为起点的循环节不断重复出现, 若第一个序列的最后一个元素是$x_{n}=x_{begin+k}$, 则第二个序列的第一个元素是$x_{n+1}=x_{begin+k+1}$, 则第二个序列第第一次出现循环节第一个元素$x_{begin}$的位置是$x_{begin}=x_{n+(t-k)}$.或者说会有循环节被$x_n$打断, 其左边有$llen$个元素, 其右边有$rlen$个元素,即$llen = k,rlen=t-k$.\n\n1. 考虑优先匹配第一个序列中的循环节, 则确定公共子序列的起点元素为$x_{begin}$, \n    \n    对应第一个序列中最大可能匹配起点为$x_i$, 最大可能匹配终点为$x_n$. 故在第一个序列中有最大匹配长度$nlen = n-begin+1$. \n    \n    对应到第二个序列中, 最大可能匹配起点为$x_{n+(t-k)}$, 最大可能匹配终点为$x_{n+m}$. 故在第二个序列中有最大匹配长度$mlen-rlen$. \n    \n    取小者为最长公共子序列长度.\n    \n    $$\n    \\min(mlen-rlen,nlen)\n    $$\n    \n2. 考虑优先匹配第二个序列中的循环节, 则确定公共子序列的起点元素为$x_{llen+1}$, \n    \n    对应第一个序列中最大可能匹配起点为$x_{begin+llen}$, 最大可能匹配终点为$x_n$, 故子第一个序列中有最大匹配长度$nlen-llen$\n    \n    对应到第二个序列中, 最大可能匹配起点为$x_{n+1}$, 最大可能匹配终点为$x_{n+m}$. 故在第二个序列中有最大匹配长度$mlen$. \n    \n    取小者为最长公共子序列长度.\n    \n    $$\n    \\min(nlen-llen,mlen)\n    $$\n    \n\n两者再取大者即为最长公共子序列长度\n\n$$\n\\max\\left(\\min(mlen-rlen,nlen),\\min(nlen-llen,mlen)\\right)\n$$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nunordered_map<ll, ll> mmap;\nll n,m,P,x,a,b,c;\n\nll add(ll a, ll b){\n    return (a+b)%P;\n}\n\nll mul(ll a, ll b){\n    return (a*b)%P;\n}\n\nll next(ll x){\n    return add(add(mul(a,mul(x,x)),mul(b,x)),c);\n}\n\nvoid solve() {\n    mmap.clear();\n    cin>>n>>m>>P>>x>>a>>b>>c;\n    for (ll i = 1; i <= n+m; i++){\n        x = next(x);\n        if (mmap[x] != 0) {\n            ll begin = mmap[x];\n            if(begin>n)break;\n            ll t = i - begin;\n            ll nlen = n-begin+1;\n            ll llen = nlen%t;\n            ll rlen = t - llen;\n            cout<<max(min(nlen-llen,m),min(m-rlen,nlen))<<\"\\n\";\n            return;\n        }\n        else { \n            mmap[x] = i;\n        }\n    }\n    cout<<\"0\"<<\"\\n\";\n}\n\nint main() {\n    int T = 1;\n    cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营08","published":1,"updated":"2023-10-29T06:31:37.322Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexe000hn0um7or990m0","content":"<h1 id=\"f-longest-common-subsequence\">F-Longest Common Subsequence</h1>\r\n<p>来源: 牛客多校训练营8 算法: LCS 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33193/F 补完: Yes 完成时间: August\r\n13, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给公式</p>\r\n<p><span class=\"math display\">\\[\r\nx_{i+1}=(ax_i^2+bx_i+c)\\%P\r\n\\]</span></p>\r\n<p>给参数<span class=\"math inline\">\\(n,m,P,x_0,a,b,c\\)</span></p>\r\n<p>取<span class=\"math inline\">\\(x_1\\sim x_n\\)</span>为第一个序列,\r\n取<span class=\"math inline\">\\(x_{n+1}\\sim x_{n+m}\\)</span>为第二个序列,\r\n求最长公共子序列.</p>\r\n<p>易发现<span class=\"math inline\">\\(x_i\\)</span>在迭代过程中可能回归,\r\n当有<span class=\"math inline\">\\(x_i==x_j\\)</span>时, 以<span\r\nclass=\"math inline\">\\(x_i\\)</span>为起点的<span\r\nclass=\"math inline\">\\(t=j-i\\)</span>个数字为一个循环节, 自<span\r\nclass=\"math inline\">\\(x_i\\)</span>开始反复出现, 有<span\r\nclass=\"math inline\">\\(x_{i+k}==x_{i+k+lt}(k≤t,l\\in\r\nN)\\)</span>.定义第一个循环节的起点为<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span></p>\r\n<p>故若有循环节起点<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>落在<span\r\nclass=\"math inline\">\\(x_1\\sim x_n\\)</span>范围内且循环节终点落在<span\r\nclass=\"math inline\">\\(x_{1}\\sim x_{n+m}\\)</span>范围内时,\r\n两序列会有公共子序列,且公共子序列为循环结的不断重复.若无循环节在范围内出现则无公共子序列.</p>\r\n<p>以<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>为起点的循环节不断重复出现,\r\n若第一个序列的最后一个元素是<span\r\nclass=\"math inline\">\\(x_{n}=x_{begin+k}\\)</span>,\r\n则第二个序列的第一个元素是<span\r\nclass=\"math inline\">\\(x_{n+1}=x_{begin+k+1}\\)</span>,\r\n则第二个序列第第一次出现循环节第一个元素<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>的位置是<span\r\nclass=\"math inline\">\\(x_{begin}=x_{n+(t-k)}\\)</span>.或者说会有循环节被<span\r\nclass=\"math inline\">\\(x_n\\)</span>打断, 其左边有<span\r\nclass=\"math inline\">\\(llen\\)</span>个元素, 其右边有<span\r\nclass=\"math inline\">\\(rlen\\)</span>个元素,即<span\r\nclass=\"math inline\">\\(llen = k,rlen=t-k\\)</span>.</p>\r\n<ol type=\"1\">\r\n<li><p>考虑优先匹配第一个序列中的循环节,\r\n则确定公共子序列的起点元素为<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>,</p>\r\n<p>对应第一个序列中最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_i\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_n\\)</span>. 故在第一个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(nlen = n-begin+1\\)</span>.</p>\r\n<p>对应到第二个序列中, 最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_{n+(t-k)}\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_{n+m}\\)</span>.\r\n故在第二个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(mlen-rlen\\)</span>.</p>\r\n<p>取小者为最长公共子序列长度.</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(mlen-rlen,nlen)\r\n\\]</span></p></li>\r\n<li><p>考虑优先匹配第二个序列中的循环节,\r\n则确定公共子序列的起点元素为<span\r\nclass=\"math inline\">\\(x_{llen+1}\\)</span>,</p>\r\n<p>对应第一个序列中最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_{begin+llen}\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_n\\)</span>, 故子第一个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(nlen-llen\\)</span></p>\r\n<p>对应到第二个序列中, 最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_{n+1}\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_{n+m}\\)</span>.\r\n故在第二个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(mlen\\)</span>.</p>\r\n<p>取小者为最长公共子序列长度.</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(nlen-llen,mlen)\r\n\\]</span></p></li>\r\n</ol>\r\n<p>两者再取大者即为最长公共子序列长度</p>\r\n<p><span class=\"math display\">\\[\r\n\\max\\left(\\min(mlen-rlen,nlen),\\min(nlen-llen,mlen)\\right)\r\n\\]</span></p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">unordered_map&lt;ll, ll&gt; mmap;</span><br><span class=\"line\">ll n,m,P,x,a,b,c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a*b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">next</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">add</span>(<span class=\"built_in\">add</span>(<span class=\"built_in\">mul</span>(a,<span class=\"built_in\">mul</span>(x,x)),<span class=\"built_in\">mul</span>(b,x)),c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mmap.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;P&gt;&gt;x&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">1</span>; i &lt;= n+m; i++)&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">next</span>(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mmap[x] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ll begin = mmap[x];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(begin&gt;n)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            ll t = i - begin;</span><br><span class=\"line\">            ll nlen = n-begin<span class=\"number\">+1</span>;</span><br><span class=\"line\">            ll llen = nlen%t;</span><br><span class=\"line\">            ll rlen = t - llen;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"built_in\">max</span>(<span class=\"built_in\">min</span>(nlen-llen,m),<span class=\"built_in\">min</span>(m-rlen,nlen))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            mmap[x] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;0&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"f-longest-common-subsequence\">F-Longest Common Subsequence</h1>\r\n<p>来源: 牛客多校训练营8 算法: LCS 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33193/F 补完: Yes 完成时间: August\r\n13, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给公式</p>\r\n<p><span class=\"math display\">\\[\r\nx_{i+1}=(ax_i^2+bx_i+c)\\%P\r\n\\]</span></p>\r\n<p>给参数<span class=\"math inline\">\\(n,m,P,x_0,a,b,c\\)</span></p>\r\n<p>取<span class=\"math inline\">\\(x_1\\sim x_n\\)</span>为第一个序列,\r\n取<span class=\"math inline\">\\(x_{n+1}\\sim x_{n+m}\\)</span>为第二个序列,\r\n求最长公共子序列.</p>\r\n<p>易发现<span class=\"math inline\">\\(x_i\\)</span>在迭代过程中可能回归,\r\n当有<span class=\"math inline\">\\(x_i==x_j\\)</span>时, 以<span\r\nclass=\"math inline\">\\(x_i\\)</span>为起点的<span\r\nclass=\"math inline\">\\(t=j-i\\)</span>个数字为一个循环节, 自<span\r\nclass=\"math inline\">\\(x_i\\)</span>开始反复出现, 有<span\r\nclass=\"math inline\">\\(x_{i+k}==x_{i+k+lt}(k≤t,l\\in\r\nN)\\)</span>.定义第一个循环节的起点为<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span></p>\r\n<p>故若有循环节起点<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>落在<span\r\nclass=\"math inline\">\\(x_1\\sim x_n\\)</span>范围内且循环节终点落在<span\r\nclass=\"math inline\">\\(x_{1}\\sim x_{n+m}\\)</span>范围内时,\r\n两序列会有公共子序列,且公共子序列为循环结的不断重复.若无循环节在范围内出现则无公共子序列.</p>\r\n<p>以<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>为起点的循环节不断重复出现,\r\n若第一个序列的最后一个元素是<span\r\nclass=\"math inline\">\\(x_{n}=x_{begin+k}\\)</span>,\r\n则第二个序列的第一个元素是<span\r\nclass=\"math inline\">\\(x_{n+1}=x_{begin+k+1}\\)</span>,\r\n则第二个序列第第一次出现循环节第一个元素<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>的位置是<span\r\nclass=\"math inline\">\\(x_{begin}=x_{n+(t-k)}\\)</span>.或者说会有循环节被<span\r\nclass=\"math inline\">\\(x_n\\)</span>打断, 其左边有<span\r\nclass=\"math inline\">\\(llen\\)</span>个元素, 其右边有<span\r\nclass=\"math inline\">\\(rlen\\)</span>个元素,即<span\r\nclass=\"math inline\">\\(llen = k,rlen=t-k\\)</span>.</p>\r\n<ol type=\"1\">\r\n<li><p>考虑优先匹配第一个序列中的循环节,\r\n则确定公共子序列的起点元素为<span\r\nclass=\"math inline\">\\(x_{begin}\\)</span>,</p>\r\n<p>对应第一个序列中最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_i\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_n\\)</span>. 故在第一个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(nlen = n-begin+1\\)</span>.</p>\r\n<p>对应到第二个序列中, 最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_{n+(t-k)}\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_{n+m}\\)</span>.\r\n故在第二个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(mlen-rlen\\)</span>.</p>\r\n<p>取小者为最长公共子序列长度.</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(mlen-rlen,nlen)\r\n\\]</span></p></li>\r\n<li><p>考虑优先匹配第二个序列中的循环节,\r\n则确定公共子序列的起点元素为<span\r\nclass=\"math inline\">\\(x_{llen+1}\\)</span>,</p>\r\n<p>对应第一个序列中最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_{begin+llen}\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_n\\)</span>, 故子第一个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(nlen-llen\\)</span></p>\r\n<p>对应到第二个序列中, 最大可能匹配起点为<span\r\nclass=\"math inline\">\\(x_{n+1}\\)</span>, 最大可能匹配终点为<span\r\nclass=\"math inline\">\\(x_{n+m}\\)</span>.\r\n故在第二个序列中有最大匹配长度<span\r\nclass=\"math inline\">\\(mlen\\)</span>.</p>\r\n<p>取小者为最长公共子序列长度.</p>\r\n<p><span class=\"math display\">\\[\r\n\\min(nlen-llen,mlen)\r\n\\]</span></p></li>\r\n</ol>\r\n<p>两者再取大者即为最长公共子序列长度</p>\r\n<p><span class=\"math display\">\\[\r\n\\max\\left(\\min(mlen-rlen,nlen),\\min(nlen-llen,mlen)\\right)\r\n\\]</span></p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">unordered_map&lt;ll, ll&gt; mmap;</span><br><span class=\"line\">ll n,m,P,x,a,b,c;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a+b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a*b)%P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">next</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">add</span>(<span class=\"built_in\">add</span>(<span class=\"built_in\">mul</span>(a,<span class=\"built_in\">mul</span>(x,x)),<span class=\"built_in\">mul</span>(b,x)),c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mmap.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;P&gt;&gt;x&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">1</span>; i &lt;= n+m; i++)&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">next</span>(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mmap[x] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ll begin = mmap[x];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(begin&gt;n)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            ll t = i - begin;</span><br><span class=\"line\">            ll nlen = n-begin<span class=\"number\">+1</span>;</span><br><span class=\"line\">            ll llen = nlen%t;</span><br><span class=\"line\">            ll rlen = t - llen;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"built_in\">max</span>(<span class=\"built_in\">min</span>(nlen-llen,m),<span class=\"built_in\">min</span>(m-rlen,nlen))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">            mmap[x] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;0&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营09","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# A-Car Show\n\n来源: 牛客多校训练营9\n算法: 双指针, 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33194/A\n补完: Yes\n完成时间: August 16, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33194/A)\n\n## 题意简述\n\n有$n$个城市，$m$种汽车，对第$i$个城市，第$T_i$种的汽车最受欢迎。选择连续的区间，让编号区间内的城市一起办汽车展，均展示本城市最受欢迎的汽车。要求每种汽车都出现，求满足条件的区间总数。$m$和$n$的范围在$1e5$内。\n\n## 题目分析\n\n根据题意，$[1,m]$内所有数字都出现的区间是有效的区间。\n\n怎么判断数字是否都出现呢？\n\n根据数据范围，汽车种类编号在$1e5$以内，这意味着我们可以直接使用一个**访问数组**进行类似**桶**排序的操作来统计目前遍历的区间的各个种类的数量，再另外使用一个**计数变量**来记录目前共有多少种不同的汽车在区间内出现。即遍历新的区间成员时，访问数组若为$0$，则这是一个新的汽车，计数变量值$+1$，否则值不变。当计数变量为$m$，这段区间合法。\n\n$1e5$的范围显然不支持暴力遍历所有的区间。然而我们需要遍历所有的区间吗？\n\n显然是**没有必要**的。\n\n有效区间只要求了数字**均出现**，而没有其他的附加要求。这意味着如果有一个区间$[l,r]$是合法区间，那么$[l-i,r+j]$**一定**也是合法的区间，i和j是使得区间在总区间范围内的所有非负整数。\n\n如果我们固定了左节点$l$，就意味着找到一个最小的$[l,r]$是合法区间后，$[l,r+i]$均合法，一直到右节点$=n$为止。总共的区间数量就是$n-j+1$，直接计算即可。\n\n也就是说，我们使用一个**双指针**型结构来找到对于每个左节点而言**最小的**满足区间有效的右节点即可。\n\n操作起来也就是，标记左节点，右节点不断向下遍历，过程中更新访问数组，直到计数变量**等于$m$**，这就是一个合法的区间，统计答案。找到合法区间之后，先尝试**直接**右移动左节点，暂时**不移动**右节点。\n\n如果计数变量**没有变化**，这就是对新的左节点而言的解。（由于一找到合法区间右节点就停滞，所以最后加入的这个右节点在的数值是前面区间范围内都没出现的，对构成合法答案是**必不可少**的。故而不存在左移右节点仍然合法的情况。）可以**继续**右移左节点进行下一次尝试。\n\n如果计数变量**变小**，这意味着上一个左节点退出区间之后，它关联的节点值**不存在**了，那么就需要继续向右移动右节点**找到**这个关键的数字，让区间内的种类再回到$m$。\n\n右节点到了尽头$n$，如果条件不满足，那就可以直接跳出循环了：$[l,n]$已经不是合法区间了，$[l-i,n]$更不可能满足条件。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nint vis[100010]={0};\nint t[100010];\ninline int read(){\n\tint x=0;\n\tchar c=getchar();\n\tint flag=1;\n\twhile(c<'0'||c>'9')if(c=='-')flag=0,c=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+(c-'0');\n\t\tc=getchar();\n\t}\n\tif(flag==1)\n\treturn x;\n\telse return x*(-1);\n}\n\nint main(){\n\tint n=read(),m=read();\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();\n\t}\n\tint head=1;\n\tint cnt=0;\n\tlong long ans=0;\n\tint i=1;\n\twhile(n-head+1>=m&&i<=n){\n\t\tif(vis[t[i]]==0) cnt++;\n\t\tvis[t[i]]++;\n\t\tif(cnt==m){\n\t\t\tans+=n-i+1;//区间数计入答案贡献\n\t\t\twhile(true){\n\t\t\t\tvis[t[head]]--;//原先的左节点退出区间\n\t\t\t\thead++;\n\t\t\t\tif(vis[t[head-1]]==0){\n\t\t\t\t\tcnt--;//区间里没有原来的值了，种类计数更新\n\t\t\t\t\ti++;//右节点往下遍历，找到这个值来补充\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans+=n-i+1;//仍然满足直接计入答案\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse i++;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n# B-Two Frogs\n\n来源: 牛客多校训练营9\n算法: 动态规划, 差分\n题目链接: https://ac.nowcoder.com/acm/contest/33194/B\n补完: Yes\n完成时间: August 15, 2022\n\n## 题解\n\n给$n$片荷叶, 每片有最大跳远距离$a_i$, 从$荷叶i$起跳可以到达$荷叶i+1~荷叶i+a_i$. \n\nAlice和Bob从$荷叶1$开始, 目的地是$荷叶n$, 问到达时步数相同的概率. \n\n设$dp[i][j]$为走了$i$步后到达$荷叶j$的概率, \n\n显然以相同步数到达$荷叶n$时的概率平方和即为答案. \n\n$$\nans=\\sum_{i=1}^{n-1} dp[i][n]\n$$\n\n从$荷叶i$起跳可以到达$荷叶i+1\\sim荷叶i+a_i$, 则跳到每片荷叶的概率有$\\frac1{a_i}$. \n\n题目保证$1≤a_i≤n-i$, 故每片荷叶都有机会向后跳, 最大只能跳到$荷叶n$. \n\n故每片荷叶都对其后的荷叶有贡献, $荷叶i$对$荷叶i+1\\sim荷叶i+a_i$有贡献$\\frac1{a_i}$. \n\n遍历每片荷叶计算其贡献复杂度为$n^3$, 最大走$n-1$步, 第$i$步最近从第$i$片开始. \n\n```cpp\nfor (int i = 1; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            for (int k = j+1; k <= j+a[j] && k < n; k++) {\n                dp[i][k] += dp[i-1][j]*(1/a[j]);\n            }\n        }\n    }\n```\n\n使用差分前缀和优化成$n^2$\n\n```cpp\nfor (int i = 1; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            ll temp = mul(dp[i-1][j],Div(1,a[j]));\n            dp[i][j+1]      +=  temp);\n            dp[i][j+a[j]+1] += -temp);\n        }\n        for (int j = i; j <= n; j++) {\n            dp[i][j] += dp[i][j-1]);\n        }\n    }\n```\n\n计算过程中经常重复计算$\\frac 1 {a_i}$, 使用快速幂计算逆元也会TLE, 提前记忆化储存优化.  \n\n## 题解\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 8005;\nint n;\nint a[MAXN];\nll inv[MAXN];\nll dp[MAXN][MAXN];//概率=dp[步数][位置]\n\nll add(ll a, ll b){\n    return (a + b) % P;\n}\nll sub(ll a, ll b){\n    return (a - b + P) % P;\n}\nll mul(ll a, ll b){\n    return (a * b) % P;\n}\nll qpow(ll a, ll n) {\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = mul(a, ans);\n        a = mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\nll Div(ll a, ll b){\n    return mul(a, inv[b]);\n}\n\nvoid solve() {\n    cin>>n;\n    for (int i = 1; i < n; i++) {\n        cin>>a[i];\n        inv[a[i]] = qpow(a[i],P-2);\n    }\n    ll ans = 0;\n    dp[0][1] = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            ll temp = mul(dp[i-1][j],Div(1,a[j]));\n            dp[i][j+1]      = add(dp[i][j+1]     ,  temp);\n            dp[i][j+a[j]+1] = add(dp[i][j+a[j]+1], -temp);\n        }\n        for (int j = i; j <= n; j++) {\n            dp[i][j] = add(dp[i][j], dp[i][j-1]);\n        }\n        ans = add(ans, mul(dp[i][n],dp[i][n]));\n    }\n    cout<<ans<<\"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营09.md","raw":"---\ntitle: 2022牛客多校训练营09\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# A-Car Show\n\n来源: 牛客多校训练营9\n算法: 双指针, 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33194/A\n补完: Yes\n完成时间: August 16, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33194/A)\n\n## 题意简述\n\n有$n$个城市，$m$种汽车，对第$i$个城市，第$T_i$种的汽车最受欢迎。选择连续的区间，让编号区间内的城市一起办汽车展，均展示本城市最受欢迎的汽车。要求每种汽车都出现，求满足条件的区间总数。$m$和$n$的范围在$1e5$内。\n\n## 题目分析\n\n根据题意，$[1,m]$内所有数字都出现的区间是有效的区间。\n\n怎么判断数字是否都出现呢？\n\n根据数据范围，汽车种类编号在$1e5$以内，这意味着我们可以直接使用一个**访问数组**进行类似**桶**排序的操作来统计目前遍历的区间的各个种类的数量，再另外使用一个**计数变量**来记录目前共有多少种不同的汽车在区间内出现。即遍历新的区间成员时，访问数组若为$0$，则这是一个新的汽车，计数变量值$+1$，否则值不变。当计数变量为$m$，这段区间合法。\n\n$1e5$的范围显然不支持暴力遍历所有的区间。然而我们需要遍历所有的区间吗？\n\n显然是**没有必要**的。\n\n有效区间只要求了数字**均出现**，而没有其他的附加要求。这意味着如果有一个区间$[l,r]$是合法区间，那么$[l-i,r+j]$**一定**也是合法的区间，i和j是使得区间在总区间范围内的所有非负整数。\n\n如果我们固定了左节点$l$，就意味着找到一个最小的$[l,r]$是合法区间后，$[l,r+i]$均合法，一直到右节点$=n$为止。总共的区间数量就是$n-j+1$，直接计算即可。\n\n也就是说，我们使用一个**双指针**型结构来找到对于每个左节点而言**最小的**满足区间有效的右节点即可。\n\n操作起来也就是，标记左节点，右节点不断向下遍历，过程中更新访问数组，直到计数变量**等于$m$**，这就是一个合法的区间，统计答案。找到合法区间之后，先尝试**直接**右移动左节点，暂时**不移动**右节点。\n\n如果计数变量**没有变化**，这就是对新的左节点而言的解。（由于一找到合法区间右节点就停滞，所以最后加入的这个右节点在的数值是前面区间范围内都没出现的，对构成合法答案是**必不可少**的。故而不存在左移右节点仍然合法的情况。）可以**继续**右移左节点进行下一次尝试。\n\n如果计数变量**变小**，这意味着上一个左节点退出区间之后，它关联的节点值**不存在**了，那么就需要继续向右移动右节点**找到**这个关键的数字，让区间内的种类再回到$m$。\n\n右节点到了尽头$n$，如果条件不满足，那就可以直接跳出循环了：$[l,n]$已经不是合法区间了，$[l-i,n]$更不可能满足条件。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nint vis[100010]={0};\nint t[100010];\ninline int read(){\n\tint x=0;\n\tchar c=getchar();\n\tint flag=1;\n\twhile(c<'0'||c>'9')if(c=='-')flag=0,c=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+(c-'0');\n\t\tc=getchar();\n\t}\n\tif(flag==1)\n\treturn x;\n\telse return x*(-1);\n}\n\nint main(){\n\tint n=read(),m=read();\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();\n\t}\n\tint head=1;\n\tint cnt=0;\n\tlong long ans=0;\n\tint i=1;\n\twhile(n-head+1>=m&&i<=n){\n\t\tif(vis[t[i]]==0) cnt++;\n\t\tvis[t[i]]++;\n\t\tif(cnt==m){\n\t\t\tans+=n-i+1;//区间数计入答案贡献\n\t\t\twhile(true){\n\t\t\t\tvis[t[head]]--;//原先的左节点退出区间\n\t\t\t\thead++;\n\t\t\t\tif(vis[t[head-1]]==0){\n\t\t\t\t\tcnt--;//区间里没有原来的值了，种类计数更新\n\t\t\t\t\ti++;//右节点往下遍历，找到这个值来补充\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans+=n-i+1;//仍然满足直接计入答案\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse i++;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n# B-Two Frogs\n\n来源: 牛客多校训练营9\n算法: 动态规划, 差分\n题目链接: https://ac.nowcoder.com/acm/contest/33194/B\n补完: Yes\n完成时间: August 15, 2022\n\n## 题解\n\n给$n$片荷叶, 每片有最大跳远距离$a_i$, 从$荷叶i$起跳可以到达$荷叶i+1~荷叶i+a_i$. \n\nAlice和Bob从$荷叶1$开始, 目的地是$荷叶n$, 问到达时步数相同的概率. \n\n设$dp[i][j]$为走了$i$步后到达$荷叶j$的概率, \n\n显然以相同步数到达$荷叶n$时的概率平方和即为答案. \n\n$$\nans=\\sum_{i=1}^{n-1} dp[i][n]\n$$\n\n从$荷叶i$起跳可以到达$荷叶i+1\\sim荷叶i+a_i$, 则跳到每片荷叶的概率有$\\frac1{a_i}$. \n\n题目保证$1≤a_i≤n-i$, 故每片荷叶都有机会向后跳, 最大只能跳到$荷叶n$. \n\n故每片荷叶都对其后的荷叶有贡献, $荷叶i$对$荷叶i+1\\sim荷叶i+a_i$有贡献$\\frac1{a_i}$. \n\n遍历每片荷叶计算其贡献复杂度为$n^3$, 最大走$n-1$步, 第$i$步最近从第$i$片开始. \n\n```cpp\nfor (int i = 1; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            for (int k = j+1; k <= j+a[j] && k < n; k++) {\n                dp[i][k] += dp[i-1][j]*(1/a[j]);\n            }\n        }\n    }\n```\n\n使用差分前缀和优化成$n^2$\n\n```cpp\nfor (int i = 1; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            ll temp = mul(dp[i-1][j],Div(1,a[j]));\n            dp[i][j+1]      +=  temp);\n            dp[i][j+a[j]+1] += -temp);\n        }\n        for (int j = i; j <= n; j++) {\n            dp[i][j] += dp[i][j-1]);\n        }\n    }\n```\n\n计算过程中经常重复计算$\\frac 1 {a_i}$, 使用快速幂计算逆元也会TLE, 提前记忆化储存优化.  \n\n## 题解\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 8005;\nint n;\nint a[MAXN];\nll inv[MAXN];\nll dp[MAXN][MAXN];//概率=dp[步数][位置]\n\nll add(ll a, ll b){\n    return (a + b) % P;\n}\nll sub(ll a, ll b){\n    return (a - b + P) % P;\n}\nll mul(ll a, ll b){\n    return (a * b) % P;\n}\nll qpow(ll a, ll n) {\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = mul(a, ans);\n        a = mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\nll Div(ll a, ll b){\n    return mul(a, inv[b]);\n}\n\nvoid solve() {\n    cin>>n;\n    for (int i = 1; i < n; i++) {\n        cin>>a[i];\n        inv[a[i]] = qpow(a[i],P-2);\n    }\n    ll ans = 0;\n    dp[0][1] = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            ll temp = mul(dp[i-1][j],Div(1,a[j]));\n            dp[i][j+1]      = add(dp[i][j+1]     ,  temp);\n            dp[i][j+a[j]+1] = add(dp[i][j+a[j]+1], -temp);\n        }\n        for (int j = i; j <= n; j++) {\n            dp[i][j] = add(dp[i][j], dp[i][j-1]);\n        }\n        ans = add(ans, mul(dp[i][n],dp[i][n]));\n    }\n    cout<<ans<<\"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营09","published":1,"updated":"2023-10-29T06:27:36.390Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexe000in0um72cp0gil","content":"<h1 id=\"a-car-show\">A-Car Show</h1>\r\n<p>来源: 牛客多校训练营9 算法: 双指针, 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33194/A 补完: Yes 完成时间: August\r\n16, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33194/A\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>有<span class=\"math inline\">\\(n\\)</span>个城市，<span\r\nclass=\"math inline\">\\(m\\)</span>种汽车，对第<span\r\nclass=\"math inline\">\\(i\\)</span>个城市，第<span\r\nclass=\"math inline\">\\(T_i\\)</span>种的汽车最受欢迎。选择连续的区间，让编号区间内的城市一起办汽车展，均展示本城市最受欢迎的汽车。要求每种汽车都出现，求满足条件的区间总数。<span\r\nclass=\"math inline\">\\(m\\)</span>和<span\r\nclass=\"math inline\">\\(n\\)</span>的范围在<span\r\nclass=\"math inline\">\\(1e5\\)</span>内。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>根据题意，<span\r\nclass=\"math inline\">\\([1,m]\\)</span>内所有数字都出现的区间是有效的区间。</p>\r\n<p>怎么判断数字是否都出现呢？</p>\r\n<p>根据数据范围，汽车种类编号在<span\r\nclass=\"math inline\">\\(1e5\\)</span>以内，这意味着我们可以直接使用一个<strong>访问数组</strong>进行类似<strong>桶</strong>排序的操作来统计目前遍历的区间的各个种类的数量，再另外使用一个<strong>计数变量</strong>来记录目前共有多少种不同的汽车在区间内出现。即遍历新的区间成员时，访问数组若为<span\r\nclass=\"math inline\">\\(0\\)</span>，则这是一个新的汽车，计数变量值<span\r\nclass=\"math inline\">\\(+1\\)</span>，否则值不变。当计数变量为<span\r\nclass=\"math inline\">\\(m\\)</span>，这段区间合法。</p>\r\n<p><span\r\nclass=\"math inline\">\\(1e5\\)</span>的范围显然不支持暴力遍历所有的区间。然而我们需要遍历所有的区间吗？</p>\r\n<p>显然是<strong>没有必要</strong>的。</p>\r\n<p>有效区间只要求了数字<strong>均出现</strong>，而没有其他的附加要求。这意味着如果有一个区间<span\r\nclass=\"math inline\">\\([l,r]\\)</span>是合法区间，那么<span\r\nclass=\"math inline\">\\([l-i,r+j]\\)</span><strong>一定</strong>也是合法的区间，i和j是使得区间在总区间范围内的所有非负整数。</p>\r\n<p>如果我们固定了左节点<span\r\nclass=\"math inline\">\\(l\\)</span>，就意味着找到一个最小的<span\r\nclass=\"math inline\">\\([l,r]\\)</span>是合法区间后，<span\r\nclass=\"math inline\">\\([l,r+i]\\)</span>均合法，一直到右节点<span\r\nclass=\"math inline\">\\(=n\\)</span>为止。总共的区间数量就是<span\r\nclass=\"math inline\">\\(n-j+1\\)</span>，直接计算即可。</p>\r\n<p>也就是说，我们使用一个<strong>双指针</strong>型结构来找到对于每个左节点而言<strong>最小的</strong>满足区间有效的右节点即可。</p>\r\n<p>操作起来也就是，标记左节点，右节点不断向下遍历，过程中更新访问数组，直到计数变量<strong>等于<span\r\nclass=\"math inline\">\\(m\\)</span></strong>，这就是一个合法的区间，统计答案。找到合法区间之后，先尝试<strong>直接</strong>右移动左节点，暂时<strong>不移动</strong>右节点。</p>\r\n<p>如果计数变量<strong>没有变化</strong>，这就是对新的左节点而言的解。（由于一找到合法区间右节点就停滞，所以最后加入的这个右节点在的数值是前面区间范围内都没出现的，对构成合法答案是<strong>必不可少</strong>的。故而不存在左移右节点仍然合法的情况。）可以<strong>继续</strong>右移左节点进行下一次尝试。</p>\r\n<p>如果计数变量<strong>变小</strong>，这意味着上一个左节点退出区间之后，它关联的节点值<strong>不存在</strong>了，那么就需要继续向右移动右节点<strong>找到</strong>这个关键的数字，让区间内的种类再回到<span\r\nclass=\"math inline\">\\(m\\)</span>。</p>\r\n<p>右节点到了尽头<span\r\nclass=\"math inline\">\\(n\\)</span>，如果条件不满足，那就可以直接跳出循环了：<span\r\nclass=\"math inline\">\\([l,n]\\)</span>已经不是合法区间了，<span\r\nclass=\"math inline\">\\([l-i,n]\\)</span>更不可能满足条件。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">100010</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> t[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> c=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(c&lt;<span class=\"string\">&#x27;0&#x27;</span>||c&gt;<span class=\"string\">&#x27;9&#x27;</span>)<span class=\"keyword\">if</span>(c==<span class=\"string\">&#x27;-&#x27;</span>)flag=<span class=\"number\">0</span>,c=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(c&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tx=x*<span class=\"number\">10</span>+(c-<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\tc=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> x*(<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n=<span class=\"built_in\">read</span>(),m=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tt[i]=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> head=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(n-head<span class=\"number\">+1</span>&gt;=m&amp;&amp;i&lt;=n)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(vis[t[i]]==<span class=\"number\">0</span>) cnt++;</span><br><span class=\"line\">\t\tvis[t[i]]++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt==m)&#123;</span><br><span class=\"line\">\t\t\tans+=n-i<span class=\"number\">+1</span>;<span class=\"comment\">//区间数计入答案贡献</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t\t\tvis[t[head]]--;<span class=\"comment\">//原先的左节点退出区间</span></span><br><span class=\"line\">\t\t\t\thead++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(vis[t[head<span class=\"number\">-1</span>]]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt--;<span class=\"comment\">//区间里没有原来的值了，种类计数更新</span></span><br><span class=\"line\">\t\t\t\t\ti++;<span class=\"comment\">//右节点往下遍历，找到这个值来补充</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tans+=n-i<span class=\"number\">+1</span>;<span class=\"comment\">//仍然满足直接计入答案</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> i++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"b-two-frogs\">B-Two Frogs</h1>\r\n<p>来源: 牛客多校训练营9 算法: 动态规划, 差分 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33194/B 补完: Yes 完成时间: August\r\n15, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给<span class=\"math inline\">\\(n\\)</span>片荷叶,\r\n每片有最大跳远距离<span class=\"math inline\">\\(a_i\\)</span>, 从<span\r\nclass=\"math inline\">\\(荷叶i\\)</span>起跳可以到达<span\r\nclass=\"math inline\">\\(荷叶i+1~荷叶i+a_i\\)</span>.</p>\r\n<p>Alice和Bob从<span class=\"math inline\">\\(荷叶1\\)</span>开始,\r\n目的地是<span class=\"math inline\">\\(荷叶n\\)</span>,\r\n问到达时步数相同的概率.</p>\r\n<p>设<span class=\"math inline\">\\(dp[i][j]\\)</span>为走了<span\r\nclass=\"math inline\">\\(i\\)</span>步后到达<span\r\nclass=\"math inline\">\\(荷叶j\\)</span>的概率,</p>\r\n<p>显然以相同步数到达<span\r\nclass=\"math inline\">\\(荷叶n\\)</span>时的概率平方和即为答案.</p>\r\n<p><span class=\"math display\">\\[\r\nans=\\sum_{i=1}^{n-1} dp[i][n]\r\n\\]</span></p>\r\n<p>从<span class=\"math inline\">\\(荷叶i\\)</span>起跳可以到达<span\r\nclass=\"math inline\">\\(荷叶i+1\\sim荷叶i+a_i\\)</span>,\r\n则跳到每片荷叶的概率有<span\r\nclass=\"math inline\">\\(\\frac1{a_i}\\)</span>.</p>\r\n<p>题目保证<span class=\"math inline\">\\(1≤a_i≤n-i\\)</span>,\r\n故每片荷叶都有机会向后跳, 最大只能跳到<span\r\nclass=\"math inline\">\\(荷叶n\\)</span>.</p>\r\n<p>故每片荷叶都对其后的荷叶有贡献, <span\r\nclass=\"math inline\">\\(荷叶i\\)</span>对<span\r\nclass=\"math inline\">\\(荷叶i+1\\sim荷叶i+a_i\\)</span>有贡献<span\r\nclass=\"math inline\">\\(\\frac1{a_i}\\)</span>.</p>\r\n<p>遍历每片荷叶计算其贡献复杂度为<span\r\nclass=\"math inline\">\\(n^3\\)</span>, 最大走<span\r\nclass=\"math inline\">\\(n-1\\)</span>步, 第<span\r\nclass=\"math inline\">\\(i\\)</span>步最近从第<span\r\nclass=\"math inline\">\\(i\\)</span>片开始.</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = j<span class=\"number\">+1</span>; k &lt;= j+a[j] &amp;&amp; k &lt; n; k++) &#123;</span><br><span class=\"line\">                dp[i][k] += dp[i<span class=\"number\">-1</span>][j]*(<span class=\"number\">1</span>/a[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<p>使用差分前缀和优化成<span class=\"math inline\">\\(n^2\\)</span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            ll temp = <span class=\"built_in\">mul</span>(dp[i<span class=\"number\">-1</span>][j],<span class=\"built_in\">Div</span>(<span class=\"number\">1</span>,a[j]));</span><br><span class=\"line\">            dp[i][j<span class=\"number\">+1</span>]      +=  temp);</span><br><span class=\"line\">            dp[i][j+a[j]<span class=\"number\">+1</span>] += -temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            dp[i][j] += dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<p>计算过程中经常重复计算<span class=\"math inline\">\\(\\frac 1\r\n{a_i}\\)</span>, 使用快速幂计算逆元也会TLE, 提前记忆化储存优化.</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">8005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">int</span> a[MAXN];</span><br><span class=\"line\">ll inv[MAXN];</span><br><span class=\"line\">ll dp[MAXN][MAXN];<span class=\"comment\">//概率=dp[步数][位置]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">sub</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a - b + P) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll a, ll n)</span> </span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Div</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">mul</span>(a, inv[b]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">        inv[a[i]] = <span class=\"built_in\">qpow</span>(a[i],P<span class=\"number\">-2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            ll temp = <span class=\"built_in\">mul</span>(dp[i<span class=\"number\">-1</span>][j],<span class=\"built_in\">Div</span>(<span class=\"number\">1</span>,a[j]));</span><br><span class=\"line\">            dp[i][j<span class=\"number\">+1</span>]      = <span class=\"built_in\">add</span>(dp[i][j<span class=\"number\">+1</span>]     ,  temp);</span><br><span class=\"line\">            dp[i][j+a[j]<span class=\"number\">+1</span>] = <span class=\"built_in\">add</span>(dp[i][j+a[j]<span class=\"number\">+1</span>], -temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            dp[i][j] = <span class=\"built_in\">add</span>(dp[i][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">add</span>(ans, <span class=\"built_in\">mul</span>(dp[i][n],dp[i][n]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"a-car-show\">A-Car Show</h1>\r\n<p>来源: 牛客多校训练营9 算法: 双指针, 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33194/A 补完: Yes 完成时间: August\r\n16, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33194/A\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>有<span class=\"math inline\">\\(n\\)</span>个城市，<span\r\nclass=\"math inline\">\\(m\\)</span>种汽车，对第<span\r\nclass=\"math inline\">\\(i\\)</span>个城市，第<span\r\nclass=\"math inline\">\\(T_i\\)</span>种的汽车最受欢迎。选择连续的区间，让编号区间内的城市一起办汽车展，均展示本城市最受欢迎的汽车。要求每种汽车都出现，求满足条件的区间总数。<span\r\nclass=\"math inline\">\\(m\\)</span>和<span\r\nclass=\"math inline\">\\(n\\)</span>的范围在<span\r\nclass=\"math inline\">\\(1e5\\)</span>内。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>根据题意，<span\r\nclass=\"math inline\">\\([1,m]\\)</span>内所有数字都出现的区间是有效的区间。</p>\r\n<p>怎么判断数字是否都出现呢？</p>\r\n<p>根据数据范围，汽车种类编号在<span\r\nclass=\"math inline\">\\(1e5\\)</span>以内，这意味着我们可以直接使用一个<strong>访问数组</strong>进行类似<strong>桶</strong>排序的操作来统计目前遍历的区间的各个种类的数量，再另外使用一个<strong>计数变量</strong>来记录目前共有多少种不同的汽车在区间内出现。即遍历新的区间成员时，访问数组若为<span\r\nclass=\"math inline\">\\(0\\)</span>，则这是一个新的汽车，计数变量值<span\r\nclass=\"math inline\">\\(+1\\)</span>，否则值不变。当计数变量为<span\r\nclass=\"math inline\">\\(m\\)</span>，这段区间合法。</p>\r\n<p><span\r\nclass=\"math inline\">\\(1e5\\)</span>的范围显然不支持暴力遍历所有的区间。然而我们需要遍历所有的区间吗？</p>\r\n<p>显然是<strong>没有必要</strong>的。</p>\r\n<p>有效区间只要求了数字<strong>均出现</strong>，而没有其他的附加要求。这意味着如果有一个区间<span\r\nclass=\"math inline\">\\([l,r]\\)</span>是合法区间，那么<span\r\nclass=\"math inline\">\\([l-i,r+j]\\)</span><strong>一定</strong>也是合法的区间，i和j是使得区间在总区间范围内的所有非负整数。</p>\r\n<p>如果我们固定了左节点<span\r\nclass=\"math inline\">\\(l\\)</span>，就意味着找到一个最小的<span\r\nclass=\"math inline\">\\([l,r]\\)</span>是合法区间后，<span\r\nclass=\"math inline\">\\([l,r+i]\\)</span>均合法，一直到右节点<span\r\nclass=\"math inline\">\\(=n\\)</span>为止。总共的区间数量就是<span\r\nclass=\"math inline\">\\(n-j+1\\)</span>，直接计算即可。</p>\r\n<p>也就是说，我们使用一个<strong>双指针</strong>型结构来找到对于每个左节点而言<strong>最小的</strong>满足区间有效的右节点即可。</p>\r\n<p>操作起来也就是，标记左节点，右节点不断向下遍历，过程中更新访问数组，直到计数变量<strong>等于<span\r\nclass=\"math inline\">\\(m\\)</span></strong>，这就是一个合法的区间，统计答案。找到合法区间之后，先尝试<strong>直接</strong>右移动左节点，暂时<strong>不移动</strong>右节点。</p>\r\n<p>如果计数变量<strong>没有变化</strong>，这就是对新的左节点而言的解。（由于一找到合法区间右节点就停滞，所以最后加入的这个右节点在的数值是前面区间范围内都没出现的，对构成合法答案是<strong>必不可少</strong>的。故而不存在左移右节点仍然合法的情况。）可以<strong>继续</strong>右移左节点进行下一次尝试。</p>\r\n<p>如果计数变量<strong>变小</strong>，这意味着上一个左节点退出区间之后，它关联的节点值<strong>不存在</strong>了，那么就需要继续向右移动右节点<strong>找到</strong>这个关键的数字，让区间内的种类再回到<span\r\nclass=\"math inline\">\\(m\\)</span>。</p>\r\n<p>右节点到了尽头<span\r\nclass=\"math inline\">\\(n\\)</span>，如果条件不满足，那就可以直接跳出循环了：<span\r\nclass=\"math inline\">\\([l,n]\\)</span>已经不是合法区间了，<span\r\nclass=\"math inline\">\\([l-i,n]\\)</span>更不可能满足条件。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">100010</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> t[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> c=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(c&lt;<span class=\"string\">&#x27;0&#x27;</span>||c&gt;<span class=\"string\">&#x27;9&#x27;</span>)<span class=\"keyword\">if</span>(c==<span class=\"string\">&#x27;-&#x27;</span>)flag=<span class=\"number\">0</span>,c=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(c&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">\t\tx=x*<span class=\"number\">10</span>+(c-<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\tc=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> x*(<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n=<span class=\"built_in\">read</span>(),m=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tt[i]=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> head=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(n-head<span class=\"number\">+1</span>&gt;=m&amp;&amp;i&lt;=n)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(vis[t[i]]==<span class=\"number\">0</span>) cnt++;</span><br><span class=\"line\">\t\tvis[t[i]]++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt==m)&#123;</span><br><span class=\"line\">\t\t\tans+=n-i<span class=\"number\">+1</span>;<span class=\"comment\">//区间数计入答案贡献</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t\t\tvis[t[head]]--;<span class=\"comment\">//原先的左节点退出区间</span></span><br><span class=\"line\">\t\t\t\thead++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(vis[t[head<span class=\"number\">-1</span>]]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt--;<span class=\"comment\">//区间里没有原来的值了，种类计数更新</span></span><br><span class=\"line\">\t\t\t\t\ti++;<span class=\"comment\">//右节点往下遍历，找到这个值来补充</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tans+=n-i<span class=\"number\">+1</span>;<span class=\"comment\">//仍然满足直接计入答案</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> i++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"b-two-frogs\">B-Two Frogs</h1>\r\n<p>来源: 牛客多校训练营9 算法: 动态规划, 差分 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33194/B 补完: Yes 完成时间: August\r\n15, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给<span class=\"math inline\">\\(n\\)</span>片荷叶,\r\n每片有最大跳远距离<span class=\"math inline\">\\(a_i\\)</span>, 从<span\r\nclass=\"math inline\">\\(荷叶i\\)</span>起跳可以到达<span\r\nclass=\"math inline\">\\(荷叶i+1~荷叶i+a_i\\)</span>.</p>\r\n<p>Alice和Bob从<span class=\"math inline\">\\(荷叶1\\)</span>开始,\r\n目的地是<span class=\"math inline\">\\(荷叶n\\)</span>,\r\n问到达时步数相同的概率.</p>\r\n<p>设<span class=\"math inline\">\\(dp[i][j]\\)</span>为走了<span\r\nclass=\"math inline\">\\(i\\)</span>步后到达<span\r\nclass=\"math inline\">\\(荷叶j\\)</span>的概率,</p>\r\n<p>显然以相同步数到达<span\r\nclass=\"math inline\">\\(荷叶n\\)</span>时的概率平方和即为答案.</p>\r\n<p><span class=\"math display\">\\[\r\nans=\\sum_{i=1}^{n-1} dp[i][n]\r\n\\]</span></p>\r\n<p>从<span class=\"math inline\">\\(荷叶i\\)</span>起跳可以到达<span\r\nclass=\"math inline\">\\(荷叶i+1\\sim荷叶i+a_i\\)</span>,\r\n则跳到每片荷叶的概率有<span\r\nclass=\"math inline\">\\(\\frac1{a_i}\\)</span>.</p>\r\n<p>题目保证<span class=\"math inline\">\\(1≤a_i≤n-i\\)</span>,\r\n故每片荷叶都有机会向后跳, 最大只能跳到<span\r\nclass=\"math inline\">\\(荷叶n\\)</span>.</p>\r\n<p>故每片荷叶都对其后的荷叶有贡献, <span\r\nclass=\"math inline\">\\(荷叶i\\)</span>对<span\r\nclass=\"math inline\">\\(荷叶i+1\\sim荷叶i+a_i\\)</span>有贡献<span\r\nclass=\"math inline\">\\(\\frac1{a_i}\\)</span>.</p>\r\n<p>遍历每片荷叶计算其贡献复杂度为<span\r\nclass=\"math inline\">\\(n^3\\)</span>, 最大走<span\r\nclass=\"math inline\">\\(n-1\\)</span>步, 第<span\r\nclass=\"math inline\">\\(i\\)</span>步最近从第<span\r\nclass=\"math inline\">\\(i\\)</span>片开始.</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = j<span class=\"number\">+1</span>; k &lt;= j+a[j] &amp;&amp; k &lt; n; k++) &#123;</span><br><span class=\"line\">                dp[i][k] += dp[i<span class=\"number\">-1</span>][j]*(<span class=\"number\">1</span>/a[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<p>使用差分前缀和优化成<span class=\"math inline\">\\(n^2\\)</span></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            ll temp = <span class=\"built_in\">mul</span>(dp[i<span class=\"number\">-1</span>][j],<span class=\"built_in\">Div</span>(<span class=\"number\">1</span>,a[j]));</span><br><span class=\"line\">            dp[i][j<span class=\"number\">+1</span>]      +=  temp);</span><br><span class=\"line\">            dp[i][j+a[j]<span class=\"number\">+1</span>] += -temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            dp[i][j] += dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\r\n<p>计算过程中经常重复计算<span class=\"math inline\">\\(\\frac 1\r\n{a_i}\\)</span>, 使用快速幂计算逆元也会TLE, 提前记忆化储存优化.</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">8005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">int</span> a[MAXN];</span><br><span class=\"line\">ll inv[MAXN];</span><br><span class=\"line\">ll dp[MAXN][MAXN];<span class=\"comment\">//概率=dp[步数][位置]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">sub</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a - b + P) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll a, ll n)</span> </span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Div</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">mul</span>(a, inv[b]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">        inv[a[i]] = <span class=\"built_in\">qpow</span>(a[i],P<span class=\"number\">-2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            ll temp = <span class=\"built_in\">mul</span>(dp[i<span class=\"number\">-1</span>][j],<span class=\"built_in\">Div</span>(<span class=\"number\">1</span>,a[j]));</span><br><span class=\"line\">            dp[i][j<span class=\"number\">+1</span>]      = <span class=\"built_in\">add</span>(dp[i][j<span class=\"number\">+1</span>]     ,  temp);</span><br><span class=\"line\">            dp[i][j+a[j]<span class=\"number\">+1</span>] = <span class=\"built_in\">add</span>(dp[i][j+a[j]<span class=\"number\">+1</span>], -temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            dp[i][j] = <span class=\"built_in\">add</span>(dp[i][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">add</span>(ans, <span class=\"built_in\">mul</span>(dp[i][n],dp[i][n]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营10","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# F-Shannon Switching Game?\n\n来源: 牛客多校训练营10\n算法: DFS, 博弈论\n题目链接: https://ac.nowcoder.com/acm/contest/33195/F\n补完: Yes\n完成时间: August 20, 2022\n\n## 题解\n\n给无向图和起始点, 轮流删边和移动, 问可否抵达. \n\n发现想要到达终点$t$, 从上一个点$t-1$出发, 则在$t-1$到$t$之间必须要有多重边, 若仅为单边则在删去该条边后无法抵达. \n\n递归可得想要从点$t-i-1$出发直接到达到达点$t-i$, 则必须有点$t-i-1$和$t-i$之间有多重边. \n\n对于如此形成的多重边链$t-i-k$, 发现对于不在链上的点, 若可达一点即为可达其余带点, 想要任意点可达多重边链, 则必须有该点有多条边连向多重边链. \n\n使用DFS从终点构造可达图, 判断起点是否在图上即可. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\nusing namespace std;\n\nconst int MAXN = 10005;\n\nint n, m, s, t;\nint u, v;\nvector<int> e[MAXN];\nint vis[MAXN];\n\nvoid dfs(int u) {\n    vis[u]++;\n    if (vis[u]!=2)return;\n    for (auto v : e[u])dfs(v);\n}\n\nvoid solve() {\n    cin>>n>>m>>s>>t;\n    rep (u, 1, n) {\n        e[u].clear();\n        vis[u] = 0;\n    }\n    rep (i, 1, m) {\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    vis[t]++;\n    dfs(t);\n    if(vis[s]>=2) printf(\"Join Player\\n\");\n    else  printf(\"Cut Player\\n\");\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;// 无多组数据注释这一行\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# H-Wheel of Fortune\n\n来源: 牛客多校训练营10\n算法: 排列组合, 逆元\n题目链接: https://ac.nowcoder.com/acm/contest/33195/H\n补完: Yes\n完成时间: August 20, 2022\n\n## 题解\n\n设我受$A$次攻击死亡, 对方受$B$次攻击死亡, 则想赢得游戏需要在我受$A$次攻击前, 对方先受$B$次攻击, 此过程与随从无关, 若不攻击随从, 击中我们和对方的概率都为$\\frac12$. \n\n则赢得游戏时, 对方已经受到$B$次攻击, 设我已经受到$k$次攻击, 则我们总共被攻击了$B+k$次, 发生概率为: \n\n$$\n(\\frac{1}{2}) ^{B+k}\n$$\n\n这$B+k$次攻击中最后一次必是是对方受击, 则其余的$B+k-1$次攻击中有$B-1$次攻击对方, 在$B+k-1$次攻击中任取$B-1$次攻击, 为组合数, 故有概率: \n\n$$\nC_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\n$$\n\n只要我被攻击的次数不超过$A$就可以赢得游戏, 故我有$A$种赢法, 分别为我受$0\\sim A-1$次攻击, 累加得答案: \n\n$$\nans=\\sum_{k=0}^{A-1}C_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\n$$\n\n公式整理出: \n\n$$\nans=\\sum_{k=0}^{A-1}\\frac{(B+k-1)!}{(B+k)!k!2^{B+k}}\n$$\n\n阶乘和幂提前计算, 同余除法用逆元处理. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 2000005;\n\nll Add(ll a, ll b){\n    return (a + b + P) % P;\n}\nll Sub(ll a, ll b){\n    return (a - b + P) % P;\n}\nll Mul(ll a, ll b){\n    return (a * b) % P;\n}\nll Pow(ll a, ll n){\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = Mul(a, ans);\n        a = Mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\nll Div(ll a, ll b){\n    b = Pow(b, P - 2);\n    return Mul(a, b);\n}\n\nll fact[MAXN];\nvoid initFact(){\n    fact[0] = 1;\n    for (int i = 1; i<= MAXN; ++i) fact[i] = Mul(fact[i-1], i);\n}\nll pow2[MAXN];\nvoid initPow2(){\n    pow2[0] = 1;\n    for (int i = 1; i<= MAXN; ++i) pow2[i] = Mul(pow2[i-1], 2);\n}\n\nll temp;\nll A, B;\nll ans;\n\nvoid solve() {\n    cin>>A;\n    rep (i, 1, 7) cin>>temp;\n    cin>>B;\n    rep (i, 1, 7) cin>>temp;\n    A = (A + 9) / 10;\n    B = (B + 9) / 10;\n    initFact();\n    initPow2();\n    rep (k, 0, A-1) {\n        ans = Add(ans, Div(fact[B-1+k], Mul(Mul(fact[B-1], fact[k]), pow2[B+k])));\n    }\n    cout<<ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# I-Yet Another FFT Problem?\n\n来源: 牛客多校训练营10\n算法: 抽屉原理, 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33195/I\n补完: Yes\n完成时间: August 26, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33195/I)\n\n## 题意简述\n\n给定两个数组，a和b，问是否存在$1≤i,j≤n,1≤k,l≤m$, 其中i和j不相等，k和l不相等，使得$|a_i-a_j|=|b_k-b_l|$。\n\n输出$i，j，k，l$。\n\n$n，m$在$1e6$范围内，数组内数在$1e7$范围内。\n\n## 题目分析\n\n本题题意非常清晰，找到两个数组内的两对数差值相等。\n\n但很显然，朴素地去枚举差值再去判断相等，时间上肯定来不及。\n\n尽管记录一个数组中的结果，让第二个数组查询是否有解的时候可以做到O（1）的复杂度，但在一个数组中枚举数对做差就是$n^2$级别的复杂度了，且这个过程需要进行两次。\n\n那么如何提升效率呢？\n\n如果把要求中的$|a_i-a_j|=|b_k-b_l|$，变成$a_i+b_l=b_k+a_j$呢？\n\n（由于下标没有谁大于谁的限制，所以不管去掉绝对值是否需要倒置，结果都没什么差别。）\n\n这样一个移项的变换，把枚举同个数组中的数对**差**变为枚举两个数组中的数对**和**，看起来好像完全没有优化到。\n\n然而，需要注意的是，在数据量比较大的时候，做差存储仍然是$n^2$级别，可以预见的，数据中会有不少的重复。（意思是一个差值在多个数对中出现）\n\n但是，做和的复杂度将会大大下降。\n\n做和不仅不需要像做差一样，一个数组的所有数对枚举标记之后才能进入判断，而是在枚举过程中就可以和先前的结果进行比对；更重要的是，由于数据范围在$1e7$，那么和的范围是$2e7$，假设，跑的时候实在脸黑，每次都没找到和前面一样的结果，那**最多**从$1$跑到$2e7$，每个数字都跑出来一次，那再跑一次，由于数据在这个范围内，**一定**会出现重复，有了一组结果，遍历就可以结束了。\n\n挺耳熟吧？是的，这是**抽屉原理**。\n\n方案有了，思考一下操作起来的细节。\n\n首先这个数据还是不小的，我们可以用桶数组**去重**。（代码中的$cnta$和$cntb$），由于我们只需要**一组**合法的数对，那么原始数据中重复的数字，只要保留一个就行。由于题目要输出下标，使用**结构体**记录下标以防丢失。\n\n接着，考虑到重复数字可能构成**差为0**的情况，加入标记变量（代码中的$flaga$和$flagb$）记录这种情况，特殊处理一下，可以更快跑出这种特殊情况的解。并且处理掉相同数字带来的答案也是每个数字只保留一个的**前提**。（或者不跑这个的话去重的时候每个数字留最多两个也行）\n\n最后，在对比的时候，怎么确定这个数对有没有出现过呢？\n\n和的范围在$2e7$内，勉强还能开出这个规模的数组。一个数组记录访问情况，另一个结构体用法类似桶，记录各个和对应的坐标即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nstruct number{\n\tint num;\n\tint id;\n}a[1000005],b[1000005];\nint cnta[10000005]={0},cntb[10000005]={0};\nint visit[20000005]={0};\nstruct mark{\n\tint i;\n\tint j;\n}mk[20000005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint stpa=0,stpb=0;\n\tint flaga=0,flagb=0;\n\tint numa,numb;\n\tfor(int i=1;i<=n;i++){\n\t\tint num;\n\t\tcin>>num;\n\t\tif(cnta[num]==1){\n\t\t\t//已经访问过即是第二次出现，标记后跳过。\n\t\t\tif(flaga!=0)continue;\n\t\t\tflaga=i;\n\t\t\tnuma=num;\n\t\t\tcontinue;\n\t\t}\n\t\tcnta[num]++;\n\t\ta[stpa].num=num;\n\t\ta[stpa++].id=i;\n\t}\n\t\n\tfor(int i=1;i<=m;i++){\n\t\tint num;\n\t\tcin>>num;\n\t\tif(cntb[num]==1){\n\t\t\tif(flagb!=0)continue;\n\t\t\tflagb=i;\n\t\t\tnumb=num;\n\t\t\tcontinue;\n\t\t}\n\t\tcntb[num]++;\n\t\tb[stpb].num=num;\n\t\tb[stpb++].id=i;\n\t}\n\t\n\tif(flaga!=0&&flagb!=0){//输出差值为0的答案\n\t\tfor(int i=0;i<stpa;i++)\n\t\t\tif(a[i].num==numa){\n\t\t\t\tcout<<a[i].id<<' '<<flaga<<' ';\n\t\t\t}\n\t\tfor(int i=0;i<stpb;i++)\n\t\t\tif(b[i].num==numb){\n\t\t\t\tcout<<b[i].id<<' '<<flagb<<'\\n';\n\t\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=0;i<stpa;i++){\n\t\tfor(int j=0;j<stpb;j++){\n\t\t\tint ad=a[i].num+b[j].num;\n\t\t\tif(visit[ad]){\n\t\t\t\tcout<<mk[ad].i<<' '<<a[i].id<<' '<<mk[ad].j<<' '<<b[j].id<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvisit[ad]=1;\n\t\t\tmk[ad].i=a[i].id;//记录和为ad的数对的坐标\n\t\t\tmk[ad].j=b[j].id;\n\t\t}\n\t}\n    cout<<\"-1\";\n\treturn 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营10.md","raw":"---\ntitle: 2022牛客多校训练营10\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# F-Shannon Switching Game?\n\n来源: 牛客多校训练营10\n算法: DFS, 博弈论\n题目链接: https://ac.nowcoder.com/acm/contest/33195/F\n补完: Yes\n完成时间: August 20, 2022\n\n## 题解\n\n给无向图和起始点, 轮流删边和移动, 问可否抵达. \n\n发现想要到达终点$t$, 从上一个点$t-1$出发, 则在$t-1$到$t$之间必须要有多重边, 若仅为单边则在删去该条边后无法抵达. \n\n递归可得想要从点$t-i-1$出发直接到达到达点$t-i$, 则必须有点$t-i-1$和$t-i$之间有多重边. \n\n对于如此形成的多重边链$t-i-k$, 发现对于不在链上的点, 若可达一点即为可达其余带点, 想要任意点可达多重边链, 则必须有该点有多条边连向多重边链. \n\n使用DFS从终点构造可达图, 判断起点是否在图上即可. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\nusing namespace std;\n\nconst int MAXN = 10005;\n\nint n, m, s, t;\nint u, v;\nvector<int> e[MAXN];\nint vis[MAXN];\n\nvoid dfs(int u) {\n    vis[u]++;\n    if (vis[u]!=2)return;\n    for (auto v : e[u])dfs(v);\n}\n\nvoid solve() {\n    cin>>n>>m>>s>>t;\n    rep (u, 1, n) {\n        e[u].clear();\n        vis[u] = 0;\n    }\n    rep (i, 1, m) {\n        cin>>u>>v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    vis[t]++;\n    dfs(t);\n    if(vis[s]>=2) printf(\"Join Player\\n\");\n    else  printf(\"Cut Player\\n\");\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin>>T;// 无多组数据注释这一行\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# H-Wheel of Fortune\n\n来源: 牛客多校训练营10\n算法: 排列组合, 逆元\n题目链接: https://ac.nowcoder.com/acm/contest/33195/H\n补完: Yes\n完成时间: August 20, 2022\n\n## 题解\n\n设我受$A$次攻击死亡, 对方受$B$次攻击死亡, 则想赢得游戏需要在我受$A$次攻击前, 对方先受$B$次攻击, 此过程与随从无关, 若不攻击随从, 击中我们和对方的概率都为$\\frac12$. \n\n则赢得游戏时, 对方已经受到$B$次攻击, 设我已经受到$k$次攻击, 则我们总共被攻击了$B+k$次, 发生概率为: \n\n$$\n(\\frac{1}{2}) ^{B+k}\n$$\n\n这$B+k$次攻击中最后一次必是是对方受击, 则其余的$B+k-1$次攻击中有$B-1$次攻击对方, 在$B+k-1$次攻击中任取$B-1$次攻击, 为组合数, 故有概率: \n\n$$\nC_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\n$$\n\n只要我被攻击的次数不超过$A$就可以赢得游戏, 故我有$A$种赢法, 分别为我受$0\\sim A-1$次攻击, 累加得答案: \n\n$$\nans=\\sum_{k=0}^{A-1}C_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\n$$\n\n公式整理出: \n\n$$\nans=\\sum_{k=0}^{A-1}\\frac{(B+k-1)!}{(B+k)!k!2^{B+k}}\n$$\n\n阶乘和幂提前计算, 同余除法用逆元处理. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\nusing namespace std;\n\n#define ll long long\n\nconst ll P = 998244353;\nconst int MAXN = 2000005;\n\nll Add(ll a, ll b){\n    return (a + b + P) % P;\n}\nll Sub(ll a, ll b){\n    return (a - b + P) % P;\n}\nll Mul(ll a, ll b){\n    return (a * b) % P;\n}\nll Pow(ll a, ll n){\n    ll ans = 1;\n    while (n) {\n        if (n & 1) ans = Mul(a, ans);\n        a = Mul(a,a);\n        n >>= 1;\n    }\n    return ans;\n}\nll Div(ll a, ll b){\n    b = Pow(b, P - 2);\n    return Mul(a, b);\n}\n\nll fact[MAXN];\nvoid initFact(){\n    fact[0] = 1;\n    for (int i = 1; i<= MAXN; ++i) fact[i] = Mul(fact[i-1], i);\n}\nll pow2[MAXN];\nvoid initPow2(){\n    pow2[0] = 1;\n    for (int i = 1; i<= MAXN; ++i) pow2[i] = Mul(pow2[i-1], 2);\n}\n\nll temp;\nll A, B;\nll ans;\n\nvoid solve() {\n    cin>>A;\n    rep (i, 1, 7) cin>>temp;\n    cin>>B;\n    rep (i, 1, 7) cin>>temp;\n    A = (A + 9) / 10;\n    B = (B + 9) / 10;\n    initFact();\n    initPow2();\n    rep (k, 0, A-1) {\n        ans = Add(ans, Div(fact[B-1+k], Mul(Mul(fact[B-1], fact[k]), pow2[B+k])));\n    }\n    cout<<ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n# I-Yet Another FFT Problem?\n\n来源: 牛客多校训练营10\n算法: 抽屉原理, 模拟\n题目链接: https://ac.nowcoder.com/acm/contest/33195/I\n补完: Yes\n完成时间: August 26, 2022\n\n[题目链接](https://ac.nowcoder.com/acm/contest/33195/I)\n\n## 题意简述\n\n给定两个数组，a和b，问是否存在$1≤i,j≤n,1≤k,l≤m$, 其中i和j不相等，k和l不相等，使得$|a_i-a_j|=|b_k-b_l|$。\n\n输出$i，j，k，l$。\n\n$n，m$在$1e6$范围内，数组内数在$1e7$范围内。\n\n## 题目分析\n\n本题题意非常清晰，找到两个数组内的两对数差值相等。\n\n但很显然，朴素地去枚举差值再去判断相等，时间上肯定来不及。\n\n尽管记录一个数组中的结果，让第二个数组查询是否有解的时候可以做到O（1）的复杂度，但在一个数组中枚举数对做差就是$n^2$级别的复杂度了，且这个过程需要进行两次。\n\n那么如何提升效率呢？\n\n如果把要求中的$|a_i-a_j|=|b_k-b_l|$，变成$a_i+b_l=b_k+a_j$呢？\n\n（由于下标没有谁大于谁的限制，所以不管去掉绝对值是否需要倒置，结果都没什么差别。）\n\n这样一个移项的变换，把枚举同个数组中的数对**差**变为枚举两个数组中的数对**和**，看起来好像完全没有优化到。\n\n然而，需要注意的是，在数据量比较大的时候，做差存储仍然是$n^2$级别，可以预见的，数据中会有不少的重复。（意思是一个差值在多个数对中出现）\n\n但是，做和的复杂度将会大大下降。\n\n做和不仅不需要像做差一样，一个数组的所有数对枚举标记之后才能进入判断，而是在枚举过程中就可以和先前的结果进行比对；更重要的是，由于数据范围在$1e7$，那么和的范围是$2e7$，假设，跑的时候实在脸黑，每次都没找到和前面一样的结果，那**最多**从$1$跑到$2e7$，每个数字都跑出来一次，那再跑一次，由于数据在这个范围内，**一定**会出现重复，有了一组结果，遍历就可以结束了。\n\n挺耳熟吧？是的，这是**抽屉原理**。\n\n方案有了，思考一下操作起来的细节。\n\n首先这个数据还是不小的，我们可以用桶数组**去重**。（代码中的$cnta$和$cntb$），由于我们只需要**一组**合法的数对，那么原始数据中重复的数字，只要保留一个就行。由于题目要输出下标，使用**结构体**记录下标以防丢失。\n\n接着，考虑到重复数字可能构成**差为0**的情况，加入标记变量（代码中的$flaga$和$flagb$）记录这种情况，特殊处理一下，可以更快跑出这种特殊情况的解。并且处理掉相同数字带来的答案也是每个数字只保留一个的**前提**。（或者不跑这个的话去重的时候每个数字留最多两个也行）\n\n最后，在对比的时候，怎么确定这个数对有没有出现过呢？\n\n和的范围在$2e7$内，勉强还能开出这个规模的数组。一个数组记录访问情况，另一个结构体用法类似桶，记录各个和对应的坐标即可。\n\n## 完整代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nstruct number{\n\tint num;\n\tint id;\n}a[1000005],b[1000005];\nint cnta[10000005]={0},cntb[10000005]={0};\nint visit[20000005]={0};\nstruct mark{\n\tint i;\n\tint j;\n}mk[20000005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint stpa=0,stpb=0;\n\tint flaga=0,flagb=0;\n\tint numa,numb;\n\tfor(int i=1;i<=n;i++){\n\t\tint num;\n\t\tcin>>num;\n\t\tif(cnta[num]==1){\n\t\t\t//已经访问过即是第二次出现，标记后跳过。\n\t\t\tif(flaga!=0)continue;\n\t\t\tflaga=i;\n\t\t\tnuma=num;\n\t\t\tcontinue;\n\t\t}\n\t\tcnta[num]++;\n\t\ta[stpa].num=num;\n\t\ta[stpa++].id=i;\n\t}\n\t\n\tfor(int i=1;i<=m;i++){\n\t\tint num;\n\t\tcin>>num;\n\t\tif(cntb[num]==1){\n\t\t\tif(flagb!=0)continue;\n\t\t\tflagb=i;\n\t\t\tnumb=num;\n\t\t\tcontinue;\n\t\t}\n\t\tcntb[num]++;\n\t\tb[stpb].num=num;\n\t\tb[stpb++].id=i;\n\t}\n\t\n\tif(flaga!=0&&flagb!=0){//输出差值为0的答案\n\t\tfor(int i=0;i<stpa;i++)\n\t\t\tif(a[i].num==numa){\n\t\t\t\tcout<<a[i].id<<' '<<flaga<<' ';\n\t\t\t}\n\t\tfor(int i=0;i<stpb;i++)\n\t\t\tif(b[i].num==numb){\n\t\t\t\tcout<<b[i].id<<' '<<flagb<<'\\n';\n\t\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=0;i<stpa;i++){\n\t\tfor(int j=0;j<stpb;j++){\n\t\t\tint ad=a[i].num+b[j].num;\n\t\t\tif(visit[ad]){\n\t\t\t\tcout<<mk[ad].i<<' '<<a[i].id<<' '<<mk[ad].j<<' '<<b[j].id<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvisit[ad]=1;\n\t\t\tmk[ad].i=a[i].id;//记录和为ad的数对的坐标\n\t\t\tmk[ad].j=b[j].id;\n\t\t}\n\t}\n    cout<<\"-1\";\n\treturn 0;\n}\n```\n","slug":"2022牛客多校训练营10","published":1,"updated":"2023-10-29T06:35:02.371Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexf000jn0um8wly3pm3","content":"<h1 id=\"f-shannon-switching-game\">F-Shannon Switching Game?</h1>\r\n<p>来源: 牛客多校训练营10 算法: DFS, 博弈论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33195/F 补完: Yes 完成时间: August\r\n20, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给无向图和起始点, 轮流删边和移动, 问可否抵达.</p>\r\n<p>发现想要到达终点<span class=\"math inline\">\\(t\\)</span>,\r\n从上一个点<span class=\"math inline\">\\(t-1\\)</span>出发, 则在<span\r\nclass=\"math inline\">\\(t-1\\)</span>到<span\r\nclass=\"math inline\">\\(t\\)</span>之间必须要有多重边,\r\n若仅为单边则在删去该条边后无法抵达.</p>\r\n<p>递归可得想要从点<span\r\nclass=\"math inline\">\\(t-i-1\\)</span>出发直接到达到达点<span\r\nclass=\"math inline\">\\(t-i\\)</span>, 则必须有点<span\r\nclass=\"math inline\">\\(t-i-1\\)</span>和<span\r\nclass=\"math inline\">\\(t-i\\)</span>之间有多重边.</p>\r\n<p>对于如此形成的多重边链<span class=\"math inline\">\\(t-i-k\\)</span>,\r\n发现对于不在链上的点, 若可达一点即为可达其余带点,\r\n想要任意点可达多重边链, 则必须有该点有多条边连向多重边链.</p>\r\n<p>使用DFS从终点构造可达图, 判断起点是否在图上即可.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">10005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n, m, s, t;</span><br><span class=\"line\"><span class=\"type\">int</span> u, v;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> vis[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    vis[u]++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vis[u]!=<span class=\"number\">2</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : e[u])<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (u, <span class=\"number\">1</span>, n) &#123;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        vis[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (i, <span class=\"number\">1</span>, m) &#123;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        e[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vis[t]++;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vis[s]&gt;=<span class=\"number\">2</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Join Player\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Cut Player\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;<span class=\"comment\">// 无多组数据注释这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"h-wheel-of-fortune\">H-Wheel of Fortune</h1>\r\n<p>来源: 牛客多校训练营10 算法: 排列组合, 逆元 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33195/H 补完: Yes 完成时间: August\r\n20, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>设我受<span class=\"math inline\">\\(A\\)</span>次攻击死亡, 对方受<span\r\nclass=\"math inline\">\\(B\\)</span>次攻击死亡, 则想赢得游戏需要在我受<span\r\nclass=\"math inline\">\\(A\\)</span>次攻击前, 对方先受<span\r\nclass=\"math inline\">\\(B\\)</span>次攻击, 此过程与随从无关, 若不攻击随从,\r\n击中我们和对方的概率都为<span\r\nclass=\"math inline\">\\(\\frac12\\)</span>.</p>\r\n<p>则赢得游戏时, 对方已经受到<span\r\nclass=\"math inline\">\\(B\\)</span>次攻击, 设我已经受到<span\r\nclass=\"math inline\">\\(k\\)</span>次攻击, 则我们总共被攻击了<span\r\nclass=\"math inline\">\\(B+k\\)</span>次, 发生概率为:</p>\r\n<p><span class=\"math display\">\\[\r\n(\\frac{1}{2}) ^{B+k}\r\n\\]</span></p>\r\n<p>这<span\r\nclass=\"math inline\">\\(B+k\\)</span>次攻击中最后一次必是是对方受击,\r\n则其余的<span class=\"math inline\">\\(B+k-1\\)</span>次攻击中有<span\r\nclass=\"math inline\">\\(B-1\\)</span>次攻击对方, 在<span\r\nclass=\"math inline\">\\(B+k-1\\)</span>次攻击中任取<span\r\nclass=\"math inline\">\\(B-1\\)</span>次攻击, 为组合数, 故有概率:</p>\r\n<p><span class=\"math display\">\\[\r\nC_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\r\n\\]</span></p>\r\n<p>只要我被攻击的次数不超过<span\r\nclass=\"math inline\">\\(A\\)</span>就可以赢得游戏, 故我有<span\r\nclass=\"math inline\">\\(A\\)</span>种赢法, 分别为我受<span\r\nclass=\"math inline\">\\(0\\sim A-1\\)</span>次攻击, 累加得答案:</p>\r\n<p><span class=\"math display\">\\[\r\nans=\\sum_{k=0}^{A-1}C_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\r\n\\]</span></p>\r\n<p>公式整理出:</p>\r\n<p><span class=\"math display\">\\[\r\nans=\\sum_{k=0}^{A-1}\\frac{(B+k-1)!}{(B+k)!k!2^{B+k}}\r\n\\]</span></p>\r\n<p>阶乘和幂提前计算, 同余除法用逆元处理.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">2000005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b + P) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Sub</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a - b + P) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Pow</span><span class=\"params\">(ll a, ll n)</span></span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">Mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">Mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Div</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    b = <span class=\"built_in\">Pow</span>(b, P - <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Mul</span>(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ll fact[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initFact</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    fact[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;= MAXN; ++i) fact[i] = <span class=\"built_in\">Mul</span>(fact[i<span class=\"number\">-1</span>], i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ll pow2[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initPow2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pow2[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;= MAXN; ++i) pow2[i] = <span class=\"built_in\">Mul</span>(pow2[i<span class=\"number\">-1</span>], <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ll temp;</span><br><span class=\"line\">ll A, B;</span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;A;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (i, <span class=\"number\">1</span>, <span class=\"number\">7</span>) cin&gt;&gt;temp;</span><br><span class=\"line\">    cin&gt;&gt;B;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (i, <span class=\"number\">1</span>, <span class=\"number\">7</span>) cin&gt;&gt;temp;</span><br><span class=\"line\">    A = (A + <span class=\"number\">9</span>) / <span class=\"number\">10</span>;</span><br><span class=\"line\">    B = (B + <span class=\"number\">9</span>) / <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">initFact</span>();</span><br><span class=\"line\">    <span class=\"built_in\">initPow2</span>();</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (k, <span class=\"number\">0</span>, A<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">Add</span>(ans, <span class=\"built_in\">Div</span>(fact[B<span class=\"number\">-1</span>+k], <span class=\"built_in\">Mul</span>(<span class=\"built_in\">Mul</span>(fact[B<span class=\"number\">-1</span>], fact[k]), pow2[B+k])));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"i-yet-another-fft-problem\">I-Yet Another FFT Problem?</h1>\r\n<p>来源: 牛客多校训练营10 算法: 抽屉原理, 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33195/I 补完: Yes 完成时间: August\r\n26, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33195/I\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给定两个数组，a和b，问是否存在<span\r\nclass=\"math inline\">\\(1≤i,j≤n,1≤k,l≤m\\)</span>,\r\n其中i和j不相等，k和l不相等，使得<span\r\nclass=\"math inline\">\\(|a_i-a_j|=|b_k-b_l|\\)</span>。</p>\r\n<p>输出<span class=\"math inline\">\\(i，j，k，l\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(n，m\\)</span>在<span\r\nclass=\"math inline\">\\(1e6\\)</span>范围内，数组内数在<span\r\nclass=\"math inline\">\\(1e7\\)</span>范围内。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>本题题意非常清晰，找到两个数组内的两对数差值相等。</p>\r\n<p>但很显然，朴素地去枚举差值再去判断相等，时间上肯定来不及。</p>\r\n<p>尽管记录一个数组中的结果，让第二个数组查询是否有解的时候可以做到O（1）的复杂度，但在一个数组中枚举数对做差就是<span\r\nclass=\"math inline\">\\(n^2\\)</span>级别的复杂度了，且这个过程需要进行两次。</p>\r\n<p>那么如何提升效率呢？</p>\r\n<p>如果把要求中的<span\r\nclass=\"math inline\">\\(|a_i-a_j|=|b_k-b_l|\\)</span>，变成<span\r\nclass=\"math inline\">\\(a_i+b_l=b_k+a_j\\)</span>呢？</p>\r\n<p>（由于下标没有谁大于谁的限制，所以不管去掉绝对值是否需要倒置，结果都没什么差别。）</p>\r\n<p>这样一个移项的变换，把枚举同个数组中的数对<strong>差</strong>变为枚举两个数组中的数对<strong>和</strong>，看起来好像完全没有优化到。</p>\r\n<p>然而，需要注意的是，在数据量比较大的时候，做差存储仍然是<span\r\nclass=\"math inline\">\\(n^2\\)</span>级别，可以预见的，数据中会有不少的重复。（意思是一个差值在多个数对中出现）</p>\r\n<p>但是，做和的复杂度将会大大下降。</p>\r\n<p>做和不仅不需要像做差一样，一个数组的所有数对枚举标记之后才能进入判断，而是在枚举过程中就可以和先前的结果进行比对；更重要的是，由于数据范围在<span\r\nclass=\"math inline\">\\(1e7\\)</span>，那么和的范围是<span\r\nclass=\"math inline\">\\(2e7\\)</span>，假设，跑的时候实在脸黑，每次都没找到和前面一样的结果，那<strong>最多</strong>从<span\r\nclass=\"math inline\">\\(1\\)</span>跑到<span\r\nclass=\"math inline\">\\(2e7\\)</span>，每个数字都跑出来一次，那再跑一次，由于数据在这个范围内，<strong>一定</strong>会出现重复，有了一组结果，遍历就可以结束了。</p>\r\n<p>挺耳熟吧？是的，这是<strong>抽屉原理</strong>。</p>\r\n<p>方案有了，思考一下操作起来的细节。</p>\r\n<p>首先这个数据还是不小的，我们可以用桶数组<strong>去重</strong>。（代码中的<span\r\nclass=\"math inline\">\\(cnta\\)</span>和<span\r\nclass=\"math inline\">\\(cntb\\)</span>），由于我们只需要<strong>一组</strong>合法的数对，那么原始数据中重复的数字，只要保留一个就行。由于题目要输出下标，使用<strong>结构体</strong>记录下标以防丢失。</p>\r\n<p>接着，考虑到重复数字可能构成<strong>差为0</strong>的情况，加入标记变量（代码中的<span\r\nclass=\"math inline\">\\(flaga\\)</span>和<span\r\nclass=\"math inline\">\\(flagb\\)</span>）记录这种情况，特殊处理一下，可以更快跑出这种特殊情况的解。并且处理掉相同数字带来的答案也是每个数字只保留一个的<strong>前提</strong>。（或者不跑这个的话去重的时候每个数字留最多两个也行）</p>\r\n<p>最后，在对比的时候，怎么确定这个数对有没有出现过呢？</p>\r\n<p>和的范围在<span\r\nclass=\"math inline\">\\(2e7\\)</span>内，勉强还能开出这个规模的数组。一个数组记录访问情况，另一个结构体用法类似桶，记录各个和对应的坐标即可。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">number</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> num;</span><br><span class=\"line\">\t<span class=\"type\">int</span> id;</span><br><span class=\"line\">&#125;a[<span class=\"number\">1000005</span>],b[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> cnta[<span class=\"number\">10000005</span>]=&#123;<span class=\"number\">0</span>&#125;,cntb[<span class=\"number\">10000005</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> visit[<span class=\"number\">20000005</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mark</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"type\">int</span> j;</span><br><span class=\"line\">&#125;mk[<span class=\"number\">20000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,m;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stpa=<span class=\"number\">0</span>,stpb=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flaga=<span class=\"number\">0</span>,flagb=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> numa,numb;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> num;</span><br><span class=\"line\">\t\tcin&gt;&gt;num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnta[num]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//已经访问过即是第二次出现，标记后跳过。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flaga!=<span class=\"number\">0</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tflaga=i;</span><br><span class=\"line\">\t\t\tnuma=num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnta[num]++;</span><br><span class=\"line\">\t\ta[stpa].num=num;</span><br><span class=\"line\">\t\ta[stpa++].id=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> num;</span><br><span class=\"line\">\t\tcin&gt;&gt;num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cntb[num]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flagb!=<span class=\"number\">0</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tflagb=i;</span><br><span class=\"line\">\t\t\tnumb=num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcntb[num]++;</span><br><span class=\"line\">\t\tb[stpb].num=num;</span><br><span class=\"line\">\t\tb[stpb++].id=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flaga!=<span class=\"number\">0</span>&amp;&amp;flagb!=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//输出差值为0的答案</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;stpa;i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a[i].num==numa)&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;a[i].id&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;flaga&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;stpb;i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(b[i].num==numb)&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;b[i].id&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;flagb&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;stpa;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;stpb;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ad=a[i].num+b[j].num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(visit[ad])&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;mk[ad].i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;a[i].id&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;mk[ad].j&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;b[j].id&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tvisit[ad]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tmk[ad].i=a[i].id;<span class=\"comment\">//记录和为ad的数对的坐标</span></span><br><span class=\"line\">\t\t\tmk[ad].j=b[j].id;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"f-shannon-switching-game\">F-Shannon Switching Game?</h1>\r\n<p>来源: 牛客多校训练营10 算法: DFS, 博弈论 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33195/F 补完: Yes 完成时间: August\r\n20, 2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>给无向图和起始点, 轮流删边和移动, 问可否抵达.</p>\r\n<p>发现想要到达终点<span class=\"math inline\">\\(t\\)</span>,\r\n从上一个点<span class=\"math inline\">\\(t-1\\)</span>出发, 则在<span\r\nclass=\"math inline\">\\(t-1\\)</span>到<span\r\nclass=\"math inline\">\\(t\\)</span>之间必须要有多重边,\r\n若仅为单边则在删去该条边后无法抵达.</p>\r\n<p>递归可得想要从点<span\r\nclass=\"math inline\">\\(t-i-1\\)</span>出发直接到达到达点<span\r\nclass=\"math inline\">\\(t-i\\)</span>, 则必须有点<span\r\nclass=\"math inline\">\\(t-i-1\\)</span>和<span\r\nclass=\"math inline\">\\(t-i\\)</span>之间有多重边.</p>\r\n<p>对于如此形成的多重边链<span class=\"math inline\">\\(t-i-k\\)</span>,\r\n发现对于不在链上的点, 若可达一点即为可达其余带点,\r\n想要任意点可达多重边链, 则必须有该点有多条边连向多重边链.</p>\r\n<p>使用DFS从终点构造可达图, 判断起点是否在图上即可.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">10005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n, m, s, t;</span><br><span class=\"line\"><span class=\"type\">int</span> u, v;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; e[MAXN];</span><br><span class=\"line\"><span class=\"type\">int</span> vis[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    vis[u]++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vis[u]!=<span class=\"number\">2</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : e[u])<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (u, <span class=\"number\">1</span>, n) &#123;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        vis[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (i, <span class=\"number\">1</span>, m) &#123;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        e[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        e[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vis[t]++;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vis[s]&gt;=<span class=\"number\">2</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Join Player\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Cut Player\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin&gt;&gt;T;<span class=\"comment\">// 无多组数据注释这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"h-wheel-of-fortune\">H-Wheel of Fortune</h1>\r\n<p>来源: 牛客多校训练营10 算法: 排列组合, 逆元 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33195/H 补完: Yes 完成时间: August\r\n20, 2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>设我受<span class=\"math inline\">\\(A\\)</span>次攻击死亡, 对方受<span\r\nclass=\"math inline\">\\(B\\)</span>次攻击死亡, 则想赢得游戏需要在我受<span\r\nclass=\"math inline\">\\(A\\)</span>次攻击前, 对方先受<span\r\nclass=\"math inline\">\\(B\\)</span>次攻击, 此过程与随从无关, 若不攻击随从,\r\n击中我们和对方的概率都为<span\r\nclass=\"math inline\">\\(\\frac12\\)</span>.</p>\r\n<p>则赢得游戏时, 对方已经受到<span\r\nclass=\"math inline\">\\(B\\)</span>次攻击, 设我已经受到<span\r\nclass=\"math inline\">\\(k\\)</span>次攻击, 则我们总共被攻击了<span\r\nclass=\"math inline\">\\(B+k\\)</span>次, 发生概率为:</p>\r\n<p><span class=\"math display\">\\[\r\n(\\frac{1}{2}) ^{B+k}\r\n\\]</span></p>\r\n<p>这<span\r\nclass=\"math inline\">\\(B+k\\)</span>次攻击中最后一次必是是对方受击,\r\n则其余的<span class=\"math inline\">\\(B+k-1\\)</span>次攻击中有<span\r\nclass=\"math inline\">\\(B-1\\)</span>次攻击对方, 在<span\r\nclass=\"math inline\">\\(B+k-1\\)</span>次攻击中任取<span\r\nclass=\"math inline\">\\(B-1\\)</span>次攻击, 为组合数, 故有概率:</p>\r\n<p><span class=\"math display\">\\[\r\nC_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\r\n\\]</span></p>\r\n<p>只要我被攻击的次数不超过<span\r\nclass=\"math inline\">\\(A\\)</span>就可以赢得游戏, 故我有<span\r\nclass=\"math inline\">\\(A\\)</span>种赢法, 分别为我受<span\r\nclass=\"math inline\">\\(0\\sim A-1\\)</span>次攻击, 累加得答案:</p>\r\n<p><span class=\"math display\">\\[\r\nans=\\sum_{k=0}^{A-1}C_{B+k-1}^{B-1}(\\frac{1}{2}) ^{B+k}\r\n\\]</span></p>\r\n<p>公式整理出:</p>\r\n<p><span class=\"math display\">\\[\r\nans=\\sum_{k=0}^{A-1}\\frac{(B+k-1)!}{(B+k)!k!2^{B+k}}\r\n\\]</span></p>\r\n<p>阶乘和幂提前计算, 同余除法用逆元处理.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> ll P = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">2000005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Add</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b + P) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Sub</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a - b + P) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Mul</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a * b) % P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Pow</span><span class=\"params\">(ll a, ll n)</span></span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">1</span>) ans = <span class=\"built_in\">Mul</span>(a, ans);</span><br><span class=\"line\">        a = <span class=\"built_in\">Mul</span>(a,a);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">Div</span><span class=\"params\">(ll a, ll b)</span></span>&#123;</span><br><span class=\"line\">    b = <span class=\"built_in\">Pow</span>(b, P - <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Mul</span>(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ll fact[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initFact</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    fact[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;= MAXN; ++i) fact[i] = <span class=\"built_in\">Mul</span>(fact[i<span class=\"number\">-1</span>], i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ll pow2[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initPow2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pow2[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;= MAXN; ++i) pow2[i] = <span class=\"built_in\">Mul</span>(pow2[i<span class=\"number\">-1</span>], <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ll temp;</span><br><span class=\"line\">ll A, B;</span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;A;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (i, <span class=\"number\">1</span>, <span class=\"number\">7</span>) cin&gt;&gt;temp;</span><br><span class=\"line\">    cin&gt;&gt;B;</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (i, <span class=\"number\">1</span>, <span class=\"number\">7</span>) cin&gt;&gt;temp;</span><br><span class=\"line\">    A = (A + <span class=\"number\">9</span>) / <span class=\"number\">10</span>;</span><br><span class=\"line\">    B = (B + <span class=\"number\">9</span>) / <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">initFact</span>();</span><br><span class=\"line\">    <span class=\"built_in\">initPow2</span>();</span><br><span class=\"line\">    <span class=\"built_in\">rep</span> (k, <span class=\"number\">0</span>, A<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">Add</span>(ans, <span class=\"built_in\">Div</span>(fact[B<span class=\"number\">-1</span>+k], <span class=\"built_in\">Mul</span>(<span class=\"built_in\">Mul</span>(fact[B<span class=\"number\">-1</span>], fact[k]), pow2[B+k])));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"i-yet-another-fft-problem\">I-Yet Another FFT Problem?</h1>\r\n<p>来源: 牛客多校训练营10 算法: 抽屉原理, 模拟 题目链接:\r\nhttps://ac.nowcoder.com/acm/contest/33195/I 补完: Yes 完成时间: August\r\n26, 2022</p>\r\n<p><a\r\nhref=\"https://ac.nowcoder.com/acm/contest/33195/I\">题目链接</a></p>\r\n<h2 id=\"题意简述\">题意简述</h2>\r\n<p>给定两个数组，a和b，问是否存在<span\r\nclass=\"math inline\">\\(1≤i,j≤n,1≤k,l≤m\\)</span>,\r\n其中i和j不相等，k和l不相等，使得<span\r\nclass=\"math inline\">\\(|a_i-a_j|=|b_k-b_l|\\)</span>。</p>\r\n<p>输出<span class=\"math inline\">\\(i，j，k，l\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(n，m\\)</span>在<span\r\nclass=\"math inline\">\\(1e6\\)</span>范围内，数组内数在<span\r\nclass=\"math inline\">\\(1e7\\)</span>范围内。</p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>本题题意非常清晰，找到两个数组内的两对数差值相等。</p>\r\n<p>但很显然，朴素地去枚举差值再去判断相等，时间上肯定来不及。</p>\r\n<p>尽管记录一个数组中的结果，让第二个数组查询是否有解的时候可以做到O（1）的复杂度，但在一个数组中枚举数对做差就是<span\r\nclass=\"math inline\">\\(n^2\\)</span>级别的复杂度了，且这个过程需要进行两次。</p>\r\n<p>那么如何提升效率呢？</p>\r\n<p>如果把要求中的<span\r\nclass=\"math inline\">\\(|a_i-a_j|=|b_k-b_l|\\)</span>，变成<span\r\nclass=\"math inline\">\\(a_i+b_l=b_k+a_j\\)</span>呢？</p>\r\n<p>（由于下标没有谁大于谁的限制，所以不管去掉绝对值是否需要倒置，结果都没什么差别。）</p>\r\n<p>这样一个移项的变换，把枚举同个数组中的数对<strong>差</strong>变为枚举两个数组中的数对<strong>和</strong>，看起来好像完全没有优化到。</p>\r\n<p>然而，需要注意的是，在数据量比较大的时候，做差存储仍然是<span\r\nclass=\"math inline\">\\(n^2\\)</span>级别，可以预见的，数据中会有不少的重复。（意思是一个差值在多个数对中出现）</p>\r\n<p>但是，做和的复杂度将会大大下降。</p>\r\n<p>做和不仅不需要像做差一样，一个数组的所有数对枚举标记之后才能进入判断，而是在枚举过程中就可以和先前的结果进行比对；更重要的是，由于数据范围在<span\r\nclass=\"math inline\">\\(1e7\\)</span>，那么和的范围是<span\r\nclass=\"math inline\">\\(2e7\\)</span>，假设，跑的时候实在脸黑，每次都没找到和前面一样的结果，那<strong>最多</strong>从<span\r\nclass=\"math inline\">\\(1\\)</span>跑到<span\r\nclass=\"math inline\">\\(2e7\\)</span>，每个数字都跑出来一次，那再跑一次，由于数据在这个范围内，<strong>一定</strong>会出现重复，有了一组结果，遍历就可以结束了。</p>\r\n<p>挺耳熟吧？是的，这是<strong>抽屉原理</strong>。</p>\r\n<p>方案有了，思考一下操作起来的细节。</p>\r\n<p>首先这个数据还是不小的，我们可以用桶数组<strong>去重</strong>。（代码中的<span\r\nclass=\"math inline\">\\(cnta\\)</span>和<span\r\nclass=\"math inline\">\\(cntb\\)</span>），由于我们只需要<strong>一组</strong>合法的数对，那么原始数据中重复的数字，只要保留一个就行。由于题目要输出下标，使用<strong>结构体</strong>记录下标以防丢失。</p>\r\n<p>接着，考虑到重复数字可能构成<strong>差为0</strong>的情况，加入标记变量（代码中的<span\r\nclass=\"math inline\">\\(flaga\\)</span>和<span\r\nclass=\"math inline\">\\(flagb\\)</span>）记录这种情况，特殊处理一下，可以更快跑出这种特殊情况的解。并且处理掉相同数字带来的答案也是每个数字只保留一个的<strong>前提</strong>。（或者不跑这个的话去重的时候每个数字留最多两个也行）</p>\r\n<p>最后，在对比的时候，怎么确定这个数对有没有出现过呢？</p>\r\n<p>和的范围在<span\r\nclass=\"math inline\">\\(2e7\\)</span>内，勉强还能开出这个规模的数组。一个数组记录访问情况，另一个结构体用法类似桶，记录各个和对应的坐标即可。</p>\r\n<h2 id=\"完整代码\">完整代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">number</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> num;</span><br><span class=\"line\">\t<span class=\"type\">int</span> id;</span><br><span class=\"line\">&#125;a[<span class=\"number\">1000005</span>],b[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> cnta[<span class=\"number\">10000005</span>]=&#123;<span class=\"number\">0</span>&#125;,cntb[<span class=\"number\">10000005</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> visit[<span class=\"number\">20000005</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mark</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"type\">int</span> j;</span><br><span class=\"line\">&#125;mk[<span class=\"number\">20000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n,m;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> stpa=<span class=\"number\">0</span>,stpb=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flaga=<span class=\"number\">0</span>,flagb=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> numa,numb;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> num;</span><br><span class=\"line\">\t\tcin&gt;&gt;num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnta[num]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//已经访问过即是第二次出现，标记后跳过。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flaga!=<span class=\"number\">0</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tflaga=i;</span><br><span class=\"line\">\t\t\tnuma=num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnta[num]++;</span><br><span class=\"line\">\t\ta[stpa].num=num;</span><br><span class=\"line\">\t\ta[stpa++].id=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> num;</span><br><span class=\"line\">\t\tcin&gt;&gt;num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cntb[num]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(flagb!=<span class=\"number\">0</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tflagb=i;</span><br><span class=\"line\">\t\t\tnumb=num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcntb[num]++;</span><br><span class=\"line\">\t\tb[stpb].num=num;</span><br><span class=\"line\">\t\tb[stpb++].id=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flaga!=<span class=\"number\">0</span>&amp;&amp;flagb!=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//输出差值为0的答案</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;stpa;i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a[i].num==numa)&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;a[i].id&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;flaga&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;stpb;i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(b[i].num==numb)&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;b[i].id&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;flagb&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;stpa;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;stpb;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ad=a[i].num+b[j].num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(visit[ad])&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;mk[ad].i&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;a[i].id&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;mk[ad].j&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;b[j].id&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tvisit[ad]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tmk[ad].i=a[i].id;<span class=\"comment\">//记录和为ad的数对的坐标</span></span><br><span class=\"line\">\t\t\tmk[ad].j=b[j].id;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2022牛客多校训练营X1","mathjax":true,"date":"2022-08-31T16:00:00.000Z","_content":"# E-Everyone is bot\n\n来源: 牛客多校训练营加赛\n算法: 博弈论\n补完: Yes\n完成时间: August 17, 2022\n\n## 题解\n\n第$i$个人作为第$j$个复读的人时, 可以获得$a_{i,j}$瓶冰红茶, 复读的倒数第$p$人获得$-a_{i,j}$瓶冰红茶. \n\n若一共有$n$人复读, 则倒数第$p$人即第$n-p+1$人亏, 若此人复读, 则其后的共$p-1$人必定复读, 是其成为这次复读的失败者, 故其不会复读, 导致包括其的最后$p$人得不到冰红茶. \n\n当第$n-p+1$人不会复读后, 其前的$n-p$人成为新的复读序列, 新的倒数第$p$个复读的人就是第$n-2p+1$人, 以同样的逻辑处理, 他也不会复读, 又有新的最后$p$人得不到冰红茶. \n\n从导数第$p$人开始, 循环此逻辑, 不断有$p$个人不能复读得不到冰红茶, 直到复读序列小于$p$, 才不会有人因可能的游戏失败而不复读, 故最后复读成功的人一共有$n\\%p$人.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,p,a[1005][1005];\nint main() {\n    cin>>n>>p;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            cin>>a[i][j];\n    for (int i = 1; i <= n; i++)\n        if (i <= n%p)cout<<a[i][i]<<\" \";\n        else cout<<\"0 \";\n    return 0;\n}\n```\n# M-Maimai DX 2077\n\n来源: 牛客多校训练营加赛\n算法: 模拟\n补完: Yes\n完成时间: August 17, 2022\n\n## 题解\n\n打音游, 有不同的按键类型和打击时机, 组合成不同的得分情况, 问实际得分与最佳得分之比, 模拟得. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ndouble notes[4][5];\ndouble sp, ep, A, B;\ndouble standard[4][5] = {\n    {1.0, 1.0, 0.8, 0.5, 0.0},\n    {2.0, 2.0, 1.6, 1.0, 0.0},\n    {3.0, 3.0, 2.4, 1.5, 0.0},\n    {5.0, 5.0, 2.5, 2.0, 0.0}\n};\ndouble extra[5] = {\n     1.0, 0.5, 0.4, 0.3, 0.0\n};\n\nvoid solve() {\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 5; j++) {\n            cin>>notes[i][j];\n            sp += standard[i][j] * notes[i][j];\n            A  += standard[i][0] * notes[i][j];\n            if (i==3) {\n                ep += extra[j] * notes[i][j];\n                B  += extra[0] * notes[i][j];\n            }\n        }\n    }\n    printf(\"%.15lf\", sp/A*100+ep/B);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","source":"_posts/2022/09/2022牛客多校训练营X1.md","raw":"---\ntitle: 2022牛客多校训练营X1\nmathjax: true\ndate: 2022-09-01 00:00:00\ntags:\n---\n# E-Everyone is bot\n\n来源: 牛客多校训练营加赛\n算法: 博弈论\n补完: Yes\n完成时间: August 17, 2022\n\n## 题解\n\n第$i$个人作为第$j$个复读的人时, 可以获得$a_{i,j}$瓶冰红茶, 复读的倒数第$p$人获得$-a_{i,j}$瓶冰红茶. \n\n若一共有$n$人复读, 则倒数第$p$人即第$n-p+1$人亏, 若此人复读, 则其后的共$p-1$人必定复读, 是其成为这次复读的失败者, 故其不会复读, 导致包括其的最后$p$人得不到冰红茶. \n\n当第$n-p+1$人不会复读后, 其前的$n-p$人成为新的复读序列, 新的倒数第$p$个复读的人就是第$n-2p+1$人, 以同样的逻辑处理, 他也不会复读, 又有新的最后$p$人得不到冰红茶. \n\n从导数第$p$人开始, 循环此逻辑, 不断有$p$个人不能复读得不到冰红茶, 直到复读序列小于$p$, 才不会有人因可能的游戏失败而不复读, 故最后复读成功的人一共有$n\\%p$人.\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,p,a[1005][1005];\nint main() {\n    cin>>n>>p;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            cin>>a[i][j];\n    for (int i = 1; i <= n; i++)\n        if (i <= n%p)cout<<a[i][i]<<\" \";\n        else cout<<\"0 \";\n    return 0;\n}\n```\n# M-Maimai DX 2077\n\n来源: 牛客多校训练营加赛\n算法: 模拟\n补完: Yes\n完成时间: August 17, 2022\n\n## 题解\n\n打音游, 有不同的按键类型和打击时机, 组合成不同的得分情况, 问实际得分与最佳得分之比, 模拟得. \n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ndouble notes[4][5];\ndouble sp, ep, A, B;\ndouble standard[4][5] = {\n    {1.0, 1.0, 0.8, 0.5, 0.0},\n    {2.0, 2.0, 1.6, 1.0, 0.0},\n    {3.0, 3.0, 2.4, 1.5, 0.0},\n    {5.0, 5.0, 2.5, 2.0, 0.0}\n};\ndouble extra[5] = {\n     1.0, 0.5, 0.4, 0.3, 0.0\n};\n\nvoid solve() {\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 5; j++) {\n            cin>>notes[i][j];\n            sp += standard[i][j] * notes[i][j];\n            A  += standard[i][0] * notes[i][j];\n            if (i==3) {\n                ep += extra[j] * notes[i][j];\n                B  += extra[0] * notes[i][j];\n            }\n        }\n    }\n    printf(\"%.15lf\", sp/A*100+ep/B);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    // cin>>T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```\n","slug":"2022牛客多校训练营X1","published":1,"updated":"2023-10-29T06:37:43.410Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexf000kn0umh3lm5txd","content":"<h1 id=\"e-everyone-is-bot\">E-Everyone is bot</h1>\r\n<p>来源: 牛客多校训练营加赛 算法: 博弈论 补完: Yes 完成时间: August 17,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>第<span class=\"math inline\">\\(i\\)</span>个人作为第<span\r\nclass=\"math inline\">\\(j\\)</span>个复读的人时, 可以获得<span\r\nclass=\"math inline\">\\(a_{i,j}\\)</span>瓶冰红茶, 复读的倒数第<span\r\nclass=\"math inline\">\\(p\\)</span>人获得<span\r\nclass=\"math inline\">\\(-a_{i,j}\\)</span>瓶冰红茶.</p>\r\n<p>若一共有<span class=\"math inline\">\\(n\\)</span>人复读, 则倒数第<span\r\nclass=\"math inline\">\\(p\\)</span>人即第<span\r\nclass=\"math inline\">\\(n-p+1\\)</span>人亏, 若此人复读, 则其后的共<span\r\nclass=\"math inline\">\\(p-1\\)</span>人必定复读, 是其成为这次复读的失败者,\r\n故其不会复读, 导致包括其的最后<span\r\nclass=\"math inline\">\\(p\\)</span>人得不到冰红茶.</p>\r\n<p>当第<span class=\"math inline\">\\(n-p+1\\)</span>人不会复读后,\r\n其前的<span class=\"math inline\">\\(n-p\\)</span>人成为新的复读序列,\r\n新的倒数第<span class=\"math inline\">\\(p\\)</span>个复读的人就是第<span\r\nclass=\"math inline\">\\(n-2p+1\\)</span>人, 以同样的逻辑处理, 他也不会复读,\r\n又有新的最后<span class=\"math inline\">\\(p\\)</span>人得不到冰红茶.</p>\r\n<p>从导数第<span class=\"math inline\">\\(p\\)</span>人开始, 循环此逻辑,\r\n不断有<span class=\"math inline\">\\(p\\)</span>个人不能复读得不到冰红茶,\r\n直到复读序列小于<span class=\"math inline\">\\(p\\)</span>,\r\n才不会有人因可能的游戏失败而不复读, 故最后复读成功的人一共有<span\r\nclass=\"math inline\">\\(n\\%p\\)</span>人.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,p,a[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">            cin&gt;&gt;a[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= n%p)cout&lt;&lt;a[i][i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;0 &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"m-maimai-dx-2077\">M-Maimai DX 2077</h1>\r\n<p>来源: 牛客多校训练营加赛 算法: 模拟 补完: Yes 完成时间: August 17,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>打音游, 有不同的按键类型和打击时机, 组合成不同的得分情况,\r\n问实际得分与最佳得分之比, 模拟得.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> notes[<span class=\"number\">4</span>][<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"type\">double</span> sp, ep, A, B;</span><br><span class=\"line\"><span class=\"type\">double</span> standard[<span class=\"number\">4</span>][<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">2.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">1.6</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">3.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">2.4</span>, <span class=\"number\">1.5</span>, <span class=\"number\">0.0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">5.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">2.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">0.0</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">double</span> extra[<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">     <span class=\"number\">1.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.3</span>, <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">            cin&gt;&gt;notes[i][j];</span><br><span class=\"line\">            sp += standard[i][j] * notes[i][j];</span><br><span class=\"line\">            A  += standard[i][<span class=\"number\">0</span>] * notes[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                ep += extra[j] * notes[i][j];</span><br><span class=\"line\">                B  += extra[<span class=\"number\">0</span>] * notes[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf&quot;</span>, sp/A*<span class=\"number\">100</span>+ep/B);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"e-everyone-is-bot\">E-Everyone is bot</h1>\r\n<p>来源: 牛客多校训练营加赛 算法: 博弈论 补完: Yes 完成时间: August 17,\r\n2022</p>\r\n<h2 id=\"题解\">题解</h2>\r\n<p>第<span class=\"math inline\">\\(i\\)</span>个人作为第<span\r\nclass=\"math inline\">\\(j\\)</span>个复读的人时, 可以获得<span\r\nclass=\"math inline\">\\(a_{i,j}\\)</span>瓶冰红茶, 复读的倒数第<span\r\nclass=\"math inline\">\\(p\\)</span>人获得<span\r\nclass=\"math inline\">\\(-a_{i,j}\\)</span>瓶冰红茶.</p>\r\n<p>若一共有<span class=\"math inline\">\\(n\\)</span>人复读, 则倒数第<span\r\nclass=\"math inline\">\\(p\\)</span>人即第<span\r\nclass=\"math inline\">\\(n-p+1\\)</span>人亏, 若此人复读, 则其后的共<span\r\nclass=\"math inline\">\\(p-1\\)</span>人必定复读, 是其成为这次复读的失败者,\r\n故其不会复读, 导致包括其的最后<span\r\nclass=\"math inline\">\\(p\\)</span>人得不到冰红茶.</p>\r\n<p>当第<span class=\"math inline\">\\(n-p+1\\)</span>人不会复读后,\r\n其前的<span class=\"math inline\">\\(n-p\\)</span>人成为新的复读序列,\r\n新的倒数第<span class=\"math inline\">\\(p\\)</span>个复读的人就是第<span\r\nclass=\"math inline\">\\(n-2p+1\\)</span>人, 以同样的逻辑处理, 他也不会复读,\r\n又有新的最后<span class=\"math inline\">\\(p\\)</span>人得不到冰红茶.</p>\r\n<p>从导数第<span class=\"math inline\">\\(p\\)</span>人开始, 循环此逻辑,\r\n不断有<span class=\"math inline\">\\(p\\)</span>个人不能复读得不到冰红茶,\r\n直到复读序列小于<span class=\"math inline\">\\(p\\)</span>,\r\n才不会有人因可能的游戏失败而不复读, 故最后复读成功的人一共有<span\r\nclass=\"math inline\">\\(n\\%p\\)</span>人.</p>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,p,a[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">            cin&gt;&gt;a[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= n%p)cout&lt;&lt;a[i][i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;0 &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"m-maimai-dx-2077\">M-Maimai DX 2077</h1>\r\n<p>来源: 牛客多校训练营加赛 算法: 模拟 补完: Yes 完成时间: August 17,\r\n2022</p>\r\n<h2 id=\"题解-1\">题解</h2>\r\n<p>打音游, 有不同的按键类型和打击时机, 组合成不同的得分情况,\r\n问实际得分与最佳得分之比, 模拟得.</p>\r\n<h2 id=\"代码-1\">代码</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> notes[<span class=\"number\">4</span>][<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"type\">double</span> sp, ep, A, B;</span><br><span class=\"line\"><span class=\"type\">double</span> standard[<span class=\"number\">4</span>][<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">2.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">1.6</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">3.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">2.4</span>, <span class=\"number\">1.5</span>, <span class=\"number\">0.0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">5.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">2.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">0.0</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">double</span> extra[<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\">     <span class=\"number\">1.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.3</span>, <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">            cin&gt;&gt;notes[i][j];</span><br><span class=\"line\">            sp += standard[i][j] * notes[i][j];</span><br><span class=\"line\">            A  += standard[i][<span class=\"number\">0</span>] * notes[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                ep += extra[j] * notes[i][j];</span><br><span class=\"line\">                B  += extra[<span class=\"number\">0</span>] * notes[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.15lf&quot;</span>, sp/A*<span class=\"number\">100</span>+ep/B);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin&gt;&gt;T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"2023牛客寒假算法基础集训营1","mathjax":true,"date":"2023-01-16T11:56:54.000Z","_content":"# 2023牛客寒假算法基础集训营1\n\n比赛链接[https://ac.nowcoder.com/acm/contest/46800](https://ac.nowcoder.com/acm/contest/46800)\n\n# A\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    string a;\n    cin >> a;\n    int ans = -1;\n    int A = 0;\n    int B = 0;\n    int C = 5;\n    int D = 5;\n    for (int i = 0; i < 10; i++) {\n        if (a[i] == '1') {\n            if (i % 2) {\n                B++;\n            } else {\n                A++;\n            }\n        } else {\n            if (i % 2) {\n                D--;\n            } else {\n                C--;\n            }\n        }\n        if (A > D || B > C) {\n            ans = i + 1;\n            break;\n        }\n    }\n    cout << ans;\n    cout << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# C\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    int ans = 0;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int a;\n        cin >> a;\n        if (a)\n            ans++;\n    }\n    cout << ans << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# D\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\ndouble cal(int x, int y, int X, int Y, int XX, int YY) {\n    double cap = abs(min(x, X) - XX) * abs(min(y, Y) - YY);\n    double yuce = abs(X - XX) * abs(Y - YY);\n    double GT = x * y;\n    double cup = GT + yuce - cap;\n    double ans = cap / cup;\n    return ans;\n}\n\nvoid solve() {\n    int x, y, X, Y;\n    cin >> x >> y >> X >> Y;\n    double ans = 0;\n    ans = max(ans, cal(x, y, X, Y, 0, 0));\n    ans = max(ans, cal(x, y, X, Y, x, 0));\n    ans = max(ans, cal(x, y, X, Y, 0, y));\n    ans = max(ans, cal(x, y, X, Y, x, y));\n    printf(\"%.9lf\\n\", ans);\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｈ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int ans = 10;\n    int m = n * n - 1;\n    for (int i = 0; i < m; i++) {\n        string a;\n        cin >> a;\n        for (int j = 0; j < 4; j++) {\n            if (a[j] == '1')\n                ans++;\n            if (a[j] == '2')\n                ans--;\n        }\n    }\n    cout << ans << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｋ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    int n, one;\n    int ans = 0;\n    cin >> n >> one;\n    int zero = n - one;\n    if (n <= 2) {\n        cout << 0 << '\\n';\n        return;\n    }\n    if (n == one) {\n        cout << one - 2 << '\\n';\n        return;\n    }\n    if (zero >= 2) {\n        int pair = zero / 2;\n        zero -= pair * 2;\n        one -= min(one, pair);\n    }\n    ans = max(0ll, one - 1);\n    cout << ans << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｌ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n\n    cout << 32;\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｍ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 505;\nconst int INF = 0x3f3f3f3f;\n\ndouble dp[MAXN][MAXN];\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        dp[i][i] = 1;\n        for (int j = 1; j <= m; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[i][j] =\n                    max(dp[i][j], 1.0 * k / j + 1.0 * dp[i - 1][(j - k)]);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            cout << dp[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n    printf(\"%.9lf\\n\", dp[n][m]);\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```","source":"_posts/2023/01/2023牛客寒假算法基础集训营1.md","raw":"---\ntitle: 2023牛客寒假算法基础集训营1\nmathjax: true\ndate: 2023-01-16 19:56:54\ntags:\n---\n# 2023牛客寒假算法基础集训营1\n\n比赛链接[https://ac.nowcoder.com/acm/contest/46800](https://ac.nowcoder.com/acm/contest/46800)\n\n# A\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    string a;\n    cin >> a;\n    int ans = -1;\n    int A = 0;\n    int B = 0;\n    int C = 5;\n    int D = 5;\n    for (int i = 0; i < 10; i++) {\n        if (a[i] == '1') {\n            if (i % 2) {\n                B++;\n            } else {\n                A++;\n            }\n        } else {\n            if (i % 2) {\n                D--;\n            } else {\n                C--;\n            }\n        }\n        if (A > D || B > C) {\n            ans = i + 1;\n            break;\n        }\n    }\n    cout << ans;\n    cout << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# C\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    int ans = 0;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int a;\n        cin >> a;\n        if (a)\n            ans++;\n    }\n    cout << ans << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# D\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\ndouble cal(int x, int y, int X, int Y, int XX, int YY) {\n    double cap = abs(min(x, X) - XX) * abs(min(y, Y) - YY);\n    double yuce = abs(X - XX) * abs(Y - YY);\n    double GT = x * y;\n    double cup = GT + yuce - cap;\n    double ans = cap / cup;\n    return ans;\n}\n\nvoid solve() {\n    int x, y, X, Y;\n    cin >> x >> y >> X >> Y;\n    double ans = 0;\n    ans = max(ans, cal(x, y, X, Y, 0, 0));\n    ans = max(ans, cal(x, y, X, Y, x, 0));\n    ans = max(ans, cal(x, y, X, Y, 0, y));\n    ans = max(ans, cal(x, y, X, Y, x, y));\n    printf(\"%.9lf\\n\", ans);\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｈ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int ans = 10;\n    int m = n * n - 1;\n    for (int i = 0; i < m; i++) {\n        string a;\n        cin >> a;\n        for (int j = 0; j < 4; j++) {\n            if (a[j] == '1')\n                ans++;\n            if (a[j] == '2')\n                ans--;\n        }\n    }\n    cout << ans << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｋ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n    int n, one;\n    int ans = 0;\n    cin >> n >> one;\n    int zero = n - one;\n    if (n <= 2) {\n        cout << 0 << '\\n';\n        return;\n    }\n    if (n == one) {\n        cout << one - 2 << '\\n';\n        return;\n    }\n    if (zero >= 2) {\n        int pair = zero / 2;\n        zero -= pair * 2;\n        one -= min(one, pair);\n    }\n    ans = max(0ll, one - 1);\n    cout << ans << '\\n';\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｌ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 100005;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve() {\n\n    cout << 32;\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# Ｍ\n\n```python\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int P = 1000000007;\nconst int MAXN = 505;\nconst int INF = 0x3f3f3f3f;\n\ndouble dp[MAXN][MAXN];\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        dp[i][i] = 1;\n        for (int j = 1; j <= m; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[i][j] =\n                    max(dp[i][j], 1.0 * k / j + 1.0 * dp[i - 1][(j - k)]);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            cout << dp[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n    printf(\"%.9lf\\n\", dp[n][m]);\n    return;\n}\n\nsigned main() {\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```","slug":"2023牛客寒假算法基础集训营1","published":1,"updated":"2023-10-28T23:04:08.336Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexf000ln0umg2eaexig","content":"<h1 id=\"牛客寒假算法基础集训营1\">2023牛客寒假算法基础集训营1</h1>\r\n<p>比赛链接<a\r\nhref=\"https://ac.nowcoder.com/acm/contest/46800\">https://ac.nowcoder.com/acm/contest/46800</a></p>\r\n<h1 id=\"a\">A</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    cin &gt;&gt; a;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> A = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> B = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> C = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> D = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                B++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                A++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                D--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                C--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A &gt; D || B &gt; C) &#123;</span><br><span class=\"line\">            ans = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"c\">C</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> a;</span><br><span class=\"line\">        cin &gt;&gt; a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a)</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"d\">D</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">double cal(<span class=\"built_in\">int</span> x, <span class=\"built_in\">int</span> y, <span class=\"built_in\">int</span> X, <span class=\"built_in\">int</span> Y, <span class=\"built_in\">int</span> XX, <span class=\"built_in\">int</span> YY) &#123;</span><br><span class=\"line\">    double cap = <span class=\"built_in\">abs</span>(<span class=\"built_in\">min</span>(x, X) - XX) * <span class=\"built_in\">abs</span>(<span class=\"built_in\">min</span>(y, Y) - YY);</span><br><span class=\"line\">    double yuce = <span class=\"built_in\">abs</span>(X - XX) * <span class=\"built_in\">abs</span>(Y - YY);</span><br><span class=\"line\">    double GT = x * y;</span><br><span class=\"line\">    double cup = GT + yuce - cap;</span><br><span class=\"line\">    double ans = cap / cup;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> x, y, X, Y;</span><br><span class=\"line\">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; X &gt;&gt; Y;</span><br><span class=\"line\">    double ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, x, <span class=\"number\">0</span>));</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, <span class=\"number\">0</span>, y));</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, x, y));</span><br><span class=\"line\">    printf(<span class=\"string\">&quot;%.9lf\\n&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｈ\">Ｈ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> m = n * n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">        string a;</span><br><span class=\"line\">        cin &gt;&gt; a;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] == <span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">                ans--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｋ\">Ｋ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n, one;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; one;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> zero = n - one;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">0</span> &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == one) &#123;</span><br><span class=\"line\">        cout &lt;&lt; one - <span class=\"number\">2</span> &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> pair = zero / <span class=\"number\">2</span>;</span><br><span class=\"line\">        zero -= pair * <span class=\"number\">2</span>;</span><br><span class=\"line\">        one -= <span class=\"built_in\">min</span>(one, pair);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(0ll, one - <span class=\"number\">1</span>);</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    // cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｌ\">Ｌ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    // cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｍ\">Ｍ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">505</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">double dp[MAXN][MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n, m;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> k = <span class=\"number\">0</span>; k &lt;= j; k++) &#123;</span><br><span class=\"line\">                dp[i][j] =</span><br><span class=\"line\">                    <span class=\"built_in\">max</span>(dp[i][j], <span class=\"number\">1.0</span> * k / j + <span class=\"number\">1.0</span> * dp[i - <span class=\"number\">1</span>][(j - k)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</span><br><span class=\"line\">            cout &lt;&lt; dp[i][j] &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(<span class=\"string\">&quot;%.9lf\\n&quot;</span>, dp[n][m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    // cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","excerpt":"","more":"<h1 id=\"牛客寒假算法基础集训营1\">2023牛客寒假算法基础集训营1</h1>\r\n<p>比赛链接<a\r\nhref=\"https://ac.nowcoder.com/acm/contest/46800\">https://ac.nowcoder.com/acm/contest/46800</a></p>\r\n<h1 id=\"a\">A</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    cin &gt;&gt; a;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> A = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> B = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> C = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> D = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                B++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                A++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                D--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                C--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A &gt; D || B &gt; C) &#123;</span><br><span class=\"line\">            ans = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"c\">C</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> a;</span><br><span class=\"line\">        cin &gt;&gt; a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a)</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"d\">D</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">double cal(<span class=\"built_in\">int</span> x, <span class=\"built_in\">int</span> y, <span class=\"built_in\">int</span> X, <span class=\"built_in\">int</span> Y, <span class=\"built_in\">int</span> XX, <span class=\"built_in\">int</span> YY) &#123;</span><br><span class=\"line\">    double cap = <span class=\"built_in\">abs</span>(<span class=\"built_in\">min</span>(x, X) - XX) * <span class=\"built_in\">abs</span>(<span class=\"built_in\">min</span>(y, Y) - YY);</span><br><span class=\"line\">    double yuce = <span class=\"built_in\">abs</span>(X - XX) * <span class=\"built_in\">abs</span>(Y - YY);</span><br><span class=\"line\">    double GT = x * y;</span><br><span class=\"line\">    double cup = GT + yuce - cap;</span><br><span class=\"line\">    double ans = cap / cup;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> x, y, X, Y;</span><br><span class=\"line\">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; X &gt;&gt; Y;</span><br><span class=\"line\">    double ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, x, <span class=\"number\">0</span>));</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, <span class=\"number\">0</span>, y));</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(ans, cal(x, y, X, Y, x, y));</span><br><span class=\"line\">    printf(<span class=\"string\">&quot;%.9lf\\n&quot;</span>, ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｈ\">Ｈ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> m = n * n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">        string a;</span><br><span class=\"line\">        cin &gt;&gt; a;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] == <span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">                ans--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｋ\">Ｋ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n, one;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; one;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> zero = n - one;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">0</span> &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == one) &#123;</span><br><span class=\"line\">        cout &lt;&lt; one - <span class=\"number\">2</span> &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> pair = zero / <span class=\"number\">2</span>;</span><br><span class=\"line\">        zero -= pair * <span class=\"number\">2</span>;</span><br><span class=\"line\">        one -= <span class=\"built_in\">min</span>(one, pair);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">max</span>(0ll, one - <span class=\"number\">1</span>);</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    // cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｌ\">Ｌ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    // cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"ｍ\">Ｍ</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#define int long long</span></span><br><span class=\"line\"></span><br><span class=\"line\">const <span class=\"built_in\">int</span> P = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> MAXN = <span class=\"number\">505</span>;</span><br><span class=\"line\">const <span class=\"built_in\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">double dp[MAXN][MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\">void solve() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n, m;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> k = <span class=\"number\">0</span>; k &lt;= j; k++) &#123;</span><br><span class=\"line\">                dp[i][j] =</span><br><span class=\"line\">                    <span class=\"built_in\">max</span>(dp[i][j], <span class=\"number\">1.0</span> * k / j + <span class=\"number\">1.0</span> * dp[i - <span class=\"number\">1</span>][(j - k)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</span><br><span class=\"line\">            cout &lt;&lt; dp[i][j] &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(<span class=\"string\">&quot;%.9lf\\n&quot;</span>, dp[n][m]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">signed main() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    // cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n"},{"title":"再见了,青马易战","mathjax":true,"date":"2022-11-08T11:15:50.000Z","_content":"\n<aside>\n💡 自动化是送给自己最好的礼物——沃兹基硕德\n\n</aside>\n\nv-1.0 少年, 快送自己一个青马易战自动答题机吧!\n\n> 免责声明: 本文仅为个人学习交流日志, 禁止复制/下载等内容迁移行为!\n>\n\n# 起因\n\n又是网课摸鱼的一天, 我在QQ空间上冲浪, 突然刷到同学转发的”青马易战代刷”. 只要支付7R~12R, 对方就会帮你刷完一科500题的青马易战.\n\n哦, 我才突然想起来还有这么一个作业要做, “其实青马的题挺好做的, 500题也就是一天半天的样子.”—来自其他同学. 那其实自己做也没什么大不了的嘛, 何必请人去刷呢.\n\n当我亲自做过大半百题后终于醒悟, 自己还是年轻了. 青马易战的题目并不好做, 需要不浅的知识储备. 少年, 快送自己一个青马易战自动答题机吧! 果然比起交钱给别人, 还是用自己双手解决作业更加殷实.\n\n简单搜索之后, 喜得前辈真传.\n\n[青马易战解决方案-QingmaKiller - Tawn's Blog](https://blog.tawnx.com/?p=172)\n\n[python实现青马易站自动刷题_跳墙网](https://www.tqwba.com/x_d/jishu/316922.html)\n\n理论存在, 实践开始! 虽然前辈说的东西完全没有接触, 但是看起来不难, 似乎是爬虫技术? 那就开学吧!\n\n[2021年最新Python爬虫教程+实战项目案例（最新录制）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1i54y1h75W/?vd_source=f538bf7f0a76787f3f19bc5c203190e7)\n\n# 前置\n\n## HTTP\n\n当你与网页交互时, 浏览器会通过http协议与服务器沟通, 你说你想要的, 然后服务器发给你想要的.\n\n你发出去的叫请求报文, 请求报文由三个部分构成:\n\n请求行 -> 请求方式 请求url地址 协议\n\n首部行 -> 附加信息\n\n请求体 -> 请求参数\n\n你接受到的叫响应报文, 响应报文由三个部分构成:\n\n状态行 -> 协议 状态码\n\n首部头 -> 附加信息\n\n响应体 -> 响应数据\n\n其中比较重要的是首部行中的:\n\n1. User-Agent: 你的访问设备, 记得伪装成手机哦\n2. cookie: 用户的登入信息, 就是标识你是你啦\n\n想要监控访问过程的报文可以直接浏览器’右键→检查→网络’查看\n\n![Untitled](./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled.png/)\n\n![Untitled](./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled%201.png)\n\n## Python\n\n不会Python怎么办? 菜鸟速通看一看! Python支持中文变量真的很棒.\n\n只要了解一下基础的流程控制就好了. 然后了解一下字典/JSON/文件操作, 用来存储答案.\n\n[Python3 教程 | 菜鸟教程](https://www.runoob.com/python3/python3-tutorial.html)\n\n## **Python Requests**\n\n选用Python的原因就在于此了, Requests可以非常方便的用来发送THHP请求\n\n```python\nimport requests\n```\n\n记得伪装吗, 先定义一下首部行\n\n```python\nheader = {\n    \"User-Agent\": \"XXX\",\n 'Cookie': \"XXX\"\n}\n```\n\n然后就可以访问网站啦\n\n```python\nres = requests.get(url = url, headers = header, params=param)\nres = requests.post(url = url, headers = header, data = data)\n```\n\n用JSON提取出响应报文中的数据\n\n```python\nimport json\n\n数据 = json.loads(res.text)\n```\n\n## 正则表达式\n\n拿到网页之后会需要从中找到的内容\n\n```python\nimport re\n```\n\n# 开发\n\n## 获取cookie\n\n参考了前辈的代码\n\n```python\n# 获取cookie\n    def updateCookie(self):\n        headers = {\n            'Accept-Encoding': 'gzip, deflate',\n            'Accept-Language': 'zh-CN,zh;q=0.9',\n            'Host': 'qm.linyisong.top',\n            'Proxy-Connection': 'keep-alive',\n            'Upgrade-Insecure-Requests': '1',\n            'User-Agent': 省略\n        }\n        res = requests.get(self.url, headers=headers)\n        headers['Cookie']=re.match(r'JSESSIONID=\\w*',res.headers['set-cookie']).group()\n        res = requests.get(self.url, headers=headers)\n        self.cookie=headers['Cookie']\n        print('成功取得cookie')\n        print(self.cookie)\n        res.close()\n```\n\n## 捕获通信\n\n先随便开一门做两题, 监控一下网络通信\n\n发现主要有两个通信行为, 一个nextSubject, 一个changeSituation, 看一下.\n\n### 在nextSubject里\n\n请求头\n\n```python\nPOST /yiban-web/stu/nextSubject.jhtml?_=省略 HTTP/1.1\nAccept: application/json\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nContent-Length: 10\nContent-Type: application/x-www-form-urlencoded\nCookie: 省略\nHost: qm.linyisong.top\nOrigin: http://qm.linyisong.top\nProxy-Connection: keep-alive\nReferer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=7\nUser-Agent: 省略\n```\n\n请求参数\n\n```python\ncourseId=7\n```\n\n响应数据\n\n```python\n{\n  \"data\": {\n    \"nextSubject\": {\n      \"courseId\": 7,\n      \"option0\": \"主张统一\",\n      \"option1\": \"主张独立\",\n      \"option2\": \"不统不独\",\n      \"option3\": \"一国两府\",\n      \"optionCount\": 4,\n      \"score\": 1,\n      \"subDescript\": \"当前国民党对两岸关系是\",\n      \"subType\": \"单选题\",\n      \"timeLimit\": 60\n    },\n    \"uuid\": 省略\n  },\n  \"isSuccess\": true\n}\n```\n\n### 在changeSituation里\n\n请求头\n\n```python\nPOST /yiban-web/stu/changeSituation.jhtml?_=省略 HTTP/1.1\nAccept: application/json\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nContent-Length: 69\nContent-Type: application/x-www-form-urlencoded\nCookie: 省略\nHost: qm.linyisong.top\nOrigin: http://qm.linyisong.top\nProxy-Connection: keep-alive\nReferer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=7\nUser-Agent: 省略\n```\n\n请求参数\n\n```python\nanswer: A\ncourseId: 7\nuuid: 省略\n```\n\n响应数据\n\n```python\n{\n  \"data\": {\n    \"rightAnswer\": false,\n    \"rightOption\": \"C.不统不独\"\n  },\n  \"isSuccess\": true,\n  \"message\": \"回答错误！\"\n}\n```\n\n## 分析通信\n\n多做几题对比之后, 可以发现:\n\n### 请求行中的数字是时间戳\n\n同样参考前辈的函数获取时间戳\n\n```python\n# 获取时间戳\ndef getTime():\n    t = str(time.time())\n    a = str(t[0:10])\n    b = str(t[11:14])\n    res = a + b\n    return res\n```\n\n### 使用courseId请求题目\n\n在请求题目时, 只要在参数附带courseId就可以得到完整的题目报文, 包括题面选项和类型\n\n```python\n 看题链接 = 'http://qm.linyisong.top/yiban-web/stu/nextSubject.jhtml?_={}'.format(getTime())\n    headers = {\n  'Cookie': cookie,\n    }\n    让我看看 = {\n        'courseId': courseId\n    }\n    res = requests.post(看题链接, headers = headers, data = 让我看看)\n```\n\n在响应报文里我们可以得到我们想要的题目和下面要用到的UUID\n\n```python\n uuid = json.loads(res.text)['data']['uuid']\n 题目 = json.loads(res.text)['data']['nextSubject']\n```\n\n### 使用UUID回答题目\n\n在回答题目时, 需要在参数中附带答案, courseId和UUID\n\n答案只是ABCD, 即使是判断题, 也是用AB表示的\n\ncourseId直接同科目即可\n\nUUID是题目报文中的一部分, 从中获取\n\n```python\n 答题链接 = 'http://qm.linyisong.top/yiban-web/stu/changeSituation.jhtml?_={}'.format(getTime())\n    headers = {\n  'Cookie': cookie,\n    }\n    让我猜猜 = {\n        'answer': 答案,\n        'courseId': courseId,\n        'uuid': uuid\n    }\n    res_ = requests.post(答题链接, headers = headers, data = 让我猜猜)\n```\n\n在响应报文里我们可以得到正确答案和作答情况\n\n```python\n   正确答案 = json.loads(res_.text)['data']\n    作答情况 = json.loads(res_.text)['message']\n```\n\n## 正确做题\n\n既然我们可以得到完整题目和正确答案, 又能提交自己想要的答案, 那么就可以收集题库了, 然后在做题时到题库中检索, 如果有答案就回答正确答案, 没有答案就随便回答一个吧\n\n### **查询答案**\n\n用题目和答案建立一个字典, 然后在字典里查\n\n这部分也不知道在使用Python时怎样更高效, 有大佬可以教教QWQ\n\n```python\nif 题目 in 题库:\n    print('匹配答案!')\n    答案 = 题库[题目]\n    匹配到答案 = 1\nelse:\n    print('没有答案!')\n    答案 = 'A'\n    匹配到答案 = 0\n```\n\n### 录入题库\n\n把获取到的题目写入文件本地保存\n\n```python\nif 匹配到答案 == 0:\n     新题目 = {题目,正确答案}\n     with open('database_{}.json'.format(courseId), 'a+', encoding=\"utf-8\") as f:\n         json.dump(新题目, f, ensure_ascii=False)\n         f.write('\\n')\n         f.close()\n     print('题目入库!')\n```\n\n### 加载题库\n\n把本地文件加载成题库\n\n```python\n题库 = {}\nwith open('database_{}.json'.format(courseId), 'r', encoding=\"utf-8\") as f:\n     for line in f.readlines():\n         题目 = json.loads(line)\n     f.close()\nprint('-->题库预载成功,有题目:'+str(len(题库))+'道<--')\n```\n\n## 自动化\n\n最后, 把上述零件进行一个拼接就可以运行啦!\n\n收集足够多的题目即可保证正确率.\n\n# 后记\n\n这是一次成果导向的学习, 不得不说在一个目标的指引下, 人会非常有动力. 不过迷茫也是真的迷茫, 全程百度和问人: “啊你会Python吗?”. 哈哈哈.\n\n从上午十点钟有想法开始, 一直做到了凌晨三点, 晚饭甚至也不记得吃了~~奶茶没忘记喝~~, 虽然效率很低, 但是成就感很足.\n\n在最后的凌晨几个小时里, 就是不断地调试一些BUG和优化打包了, 包括网络问题和文件读写, 就留给读者自己尝试吧.\n\n虽然我是从不想给别人交钱开始, 但是在成品完成之后, 也有了商业化的想法, 但是果然还是太麻烦了吧, 我不想和陌生人讲话.\n\n最后感谢前辈的文章, 首先可行先给我信心, 然后内容也给我帮助, 大佬太多啦, 我还是要努力才行.\n","source":"_posts/2022/11/再见了-青马易战.md","raw":"---\ntitle: '再见了,青马易战'\nmathjax: true\ndate: 2022-11-08 19:15:50\ntags:\n---\n\n<aside>\n💡 自动化是送给自己最好的礼物——沃兹基硕德\n\n</aside>\n\nv-1.0 少年, 快送自己一个青马易战自动答题机吧!\n\n> 免责声明: 本文仅为个人学习交流日志, 禁止复制/下载等内容迁移行为!\n>\n\n# 起因\n\n又是网课摸鱼的一天, 我在QQ空间上冲浪, 突然刷到同学转发的”青马易战代刷”. 只要支付7R~12R, 对方就会帮你刷完一科500题的青马易战.\n\n哦, 我才突然想起来还有这么一个作业要做, “其实青马的题挺好做的, 500题也就是一天半天的样子.”—来自其他同学. 那其实自己做也没什么大不了的嘛, 何必请人去刷呢.\n\n当我亲自做过大半百题后终于醒悟, 自己还是年轻了. 青马易战的题目并不好做, 需要不浅的知识储备. 少年, 快送自己一个青马易战自动答题机吧! 果然比起交钱给别人, 还是用自己双手解决作业更加殷实.\n\n简单搜索之后, 喜得前辈真传.\n\n[青马易战解决方案-QingmaKiller - Tawn's Blog](https://blog.tawnx.com/?p=172)\n\n[python实现青马易站自动刷题_跳墙网](https://www.tqwba.com/x_d/jishu/316922.html)\n\n理论存在, 实践开始! 虽然前辈说的东西完全没有接触, 但是看起来不难, 似乎是爬虫技术? 那就开学吧!\n\n[2021年最新Python爬虫教程+实战项目案例（最新录制）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1i54y1h75W/?vd_source=f538bf7f0a76787f3f19bc5c203190e7)\n\n# 前置\n\n## HTTP\n\n当你与网页交互时, 浏览器会通过http协议与服务器沟通, 你说你想要的, 然后服务器发给你想要的.\n\n你发出去的叫请求报文, 请求报文由三个部分构成:\n\n请求行 -> 请求方式 请求url地址 协议\n\n首部行 -> 附加信息\n\n请求体 -> 请求参数\n\n你接受到的叫响应报文, 响应报文由三个部分构成:\n\n状态行 -> 协议 状态码\n\n首部头 -> 附加信息\n\n响应体 -> 响应数据\n\n其中比较重要的是首部行中的:\n\n1. User-Agent: 你的访问设备, 记得伪装成手机哦\n2. cookie: 用户的登入信息, 就是标识你是你啦\n\n想要监控访问过程的报文可以直接浏览器’右键→检查→网络’查看\n\n![Untitled](./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled.png/)\n\n![Untitled](./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled%201.png)\n\n## Python\n\n不会Python怎么办? 菜鸟速通看一看! Python支持中文变量真的很棒.\n\n只要了解一下基础的流程控制就好了. 然后了解一下字典/JSON/文件操作, 用来存储答案.\n\n[Python3 教程 | 菜鸟教程](https://www.runoob.com/python3/python3-tutorial.html)\n\n## **Python Requests**\n\n选用Python的原因就在于此了, Requests可以非常方便的用来发送THHP请求\n\n```python\nimport requests\n```\n\n记得伪装吗, 先定义一下首部行\n\n```python\nheader = {\n    \"User-Agent\": \"XXX\",\n 'Cookie': \"XXX\"\n}\n```\n\n然后就可以访问网站啦\n\n```python\nres = requests.get(url = url, headers = header, params=param)\nres = requests.post(url = url, headers = header, data = data)\n```\n\n用JSON提取出响应报文中的数据\n\n```python\nimport json\n\n数据 = json.loads(res.text)\n```\n\n## 正则表达式\n\n拿到网页之后会需要从中找到的内容\n\n```python\nimport re\n```\n\n# 开发\n\n## 获取cookie\n\n参考了前辈的代码\n\n```python\n# 获取cookie\n    def updateCookie(self):\n        headers = {\n            'Accept-Encoding': 'gzip, deflate',\n            'Accept-Language': 'zh-CN,zh;q=0.9',\n            'Host': 'qm.linyisong.top',\n            'Proxy-Connection': 'keep-alive',\n            'Upgrade-Insecure-Requests': '1',\n            'User-Agent': 省略\n        }\n        res = requests.get(self.url, headers=headers)\n        headers['Cookie']=re.match(r'JSESSIONID=\\w*',res.headers['set-cookie']).group()\n        res = requests.get(self.url, headers=headers)\n        self.cookie=headers['Cookie']\n        print('成功取得cookie')\n        print(self.cookie)\n        res.close()\n```\n\n## 捕获通信\n\n先随便开一门做两题, 监控一下网络通信\n\n发现主要有两个通信行为, 一个nextSubject, 一个changeSituation, 看一下.\n\n### 在nextSubject里\n\n请求头\n\n```python\nPOST /yiban-web/stu/nextSubject.jhtml?_=省略 HTTP/1.1\nAccept: application/json\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nContent-Length: 10\nContent-Type: application/x-www-form-urlencoded\nCookie: 省略\nHost: qm.linyisong.top\nOrigin: http://qm.linyisong.top\nProxy-Connection: keep-alive\nReferer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=7\nUser-Agent: 省略\n```\n\n请求参数\n\n```python\ncourseId=7\n```\n\n响应数据\n\n```python\n{\n  \"data\": {\n    \"nextSubject\": {\n      \"courseId\": 7,\n      \"option0\": \"主张统一\",\n      \"option1\": \"主张独立\",\n      \"option2\": \"不统不独\",\n      \"option3\": \"一国两府\",\n      \"optionCount\": 4,\n      \"score\": 1,\n      \"subDescript\": \"当前国民党对两岸关系是\",\n      \"subType\": \"单选题\",\n      \"timeLimit\": 60\n    },\n    \"uuid\": 省略\n  },\n  \"isSuccess\": true\n}\n```\n\n### 在changeSituation里\n\n请求头\n\n```python\nPOST /yiban-web/stu/changeSituation.jhtml?_=省略 HTTP/1.1\nAccept: application/json\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nContent-Length: 69\nContent-Type: application/x-www-form-urlencoded\nCookie: 省略\nHost: qm.linyisong.top\nOrigin: http://qm.linyisong.top\nProxy-Connection: keep-alive\nReferer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=7\nUser-Agent: 省略\n```\n\n请求参数\n\n```python\nanswer: A\ncourseId: 7\nuuid: 省略\n```\n\n响应数据\n\n```python\n{\n  \"data\": {\n    \"rightAnswer\": false,\n    \"rightOption\": \"C.不统不独\"\n  },\n  \"isSuccess\": true,\n  \"message\": \"回答错误！\"\n}\n```\n\n## 分析通信\n\n多做几题对比之后, 可以发现:\n\n### 请求行中的数字是时间戳\n\n同样参考前辈的函数获取时间戳\n\n```python\n# 获取时间戳\ndef getTime():\n    t = str(time.time())\n    a = str(t[0:10])\n    b = str(t[11:14])\n    res = a + b\n    return res\n```\n\n### 使用courseId请求题目\n\n在请求题目时, 只要在参数附带courseId就可以得到完整的题目报文, 包括题面选项和类型\n\n```python\n 看题链接 = 'http://qm.linyisong.top/yiban-web/stu/nextSubject.jhtml?_={}'.format(getTime())\n    headers = {\n  'Cookie': cookie,\n    }\n    让我看看 = {\n        'courseId': courseId\n    }\n    res = requests.post(看题链接, headers = headers, data = 让我看看)\n```\n\n在响应报文里我们可以得到我们想要的题目和下面要用到的UUID\n\n```python\n uuid = json.loads(res.text)['data']['uuid']\n 题目 = json.loads(res.text)['data']['nextSubject']\n```\n\n### 使用UUID回答题目\n\n在回答题目时, 需要在参数中附带答案, courseId和UUID\n\n答案只是ABCD, 即使是判断题, 也是用AB表示的\n\ncourseId直接同科目即可\n\nUUID是题目报文中的一部分, 从中获取\n\n```python\n 答题链接 = 'http://qm.linyisong.top/yiban-web/stu/changeSituation.jhtml?_={}'.format(getTime())\n    headers = {\n  'Cookie': cookie,\n    }\n    让我猜猜 = {\n        'answer': 答案,\n        'courseId': courseId,\n        'uuid': uuid\n    }\n    res_ = requests.post(答题链接, headers = headers, data = 让我猜猜)\n```\n\n在响应报文里我们可以得到正确答案和作答情况\n\n```python\n   正确答案 = json.loads(res_.text)['data']\n    作答情况 = json.loads(res_.text)['message']\n```\n\n## 正确做题\n\n既然我们可以得到完整题目和正确答案, 又能提交自己想要的答案, 那么就可以收集题库了, 然后在做题时到题库中检索, 如果有答案就回答正确答案, 没有答案就随便回答一个吧\n\n### **查询答案**\n\n用题目和答案建立一个字典, 然后在字典里查\n\n这部分也不知道在使用Python时怎样更高效, 有大佬可以教教QWQ\n\n```python\nif 题目 in 题库:\n    print('匹配答案!')\n    答案 = 题库[题目]\n    匹配到答案 = 1\nelse:\n    print('没有答案!')\n    答案 = 'A'\n    匹配到答案 = 0\n```\n\n### 录入题库\n\n把获取到的题目写入文件本地保存\n\n```python\nif 匹配到答案 == 0:\n     新题目 = {题目,正确答案}\n     with open('database_{}.json'.format(courseId), 'a+', encoding=\"utf-8\") as f:\n         json.dump(新题目, f, ensure_ascii=False)\n         f.write('\\n')\n         f.close()\n     print('题目入库!')\n```\n\n### 加载题库\n\n把本地文件加载成题库\n\n```python\n题库 = {}\nwith open('database_{}.json'.format(courseId), 'r', encoding=\"utf-8\") as f:\n     for line in f.readlines():\n         题目 = json.loads(line)\n     f.close()\nprint('-->题库预载成功,有题目:'+str(len(题库))+'道<--')\n```\n\n## 自动化\n\n最后, 把上述零件进行一个拼接就可以运行啦!\n\n收集足够多的题目即可保证正确率.\n\n# 后记\n\n这是一次成果导向的学习, 不得不说在一个目标的指引下, 人会非常有动力. 不过迷茫也是真的迷茫, 全程百度和问人: “啊你会Python吗?”. 哈哈哈.\n\n从上午十点钟有想法开始, 一直做到了凌晨三点, 晚饭甚至也不记得吃了~~奶茶没忘记喝~~, 虽然效率很低, 但是成就感很足.\n\n在最后的凌晨几个小时里, 就是不断地调试一些BUG和优化打包了, 包括网络问题和文件读写, 就留给读者自己尝试吧.\n\n虽然我是从不想给别人交钱开始, 但是在成品完成之后, 也有了商业化的想法, 但是果然还是太麻烦了吧, 我不想和陌生人讲话.\n\n最后感谢前辈的文章, 首先可行先给我信心, 然后内容也给我帮助, 大佬太多啦, 我还是要努力才行.\n","slug":"再见了-青马易战","published":1,"updated":"2024-11-20T06:35:37.218Z","comments":1,"layout":"post","photos":[],"_id":"cm3pihexg000mn0umfswr6pmd","content":"<aside>\r\n<p>💡 自动化是送给自己最好的礼物——沃兹基硕德</p>\r\n</aside>\r\n<p>v-1.0 少年, 快送自己一个青马易战自动答题机吧!</p>\r\n<blockquote>\r\n<p>免责声明: 本文仅为个人学习交流日志, 禁止复制/下载等内容迁移行为!</p>\r\n</blockquote>\r\n<h1 id=\"起因\">起因</h1>\r\n<p>又是网课摸鱼的一天, 我在QQ空间上冲浪,\r\n突然刷到同学转发的”青马易战代刷”. 只要支付7R~12R,\r\n对方就会帮你刷完一科500题的青马易战.</p>\r\n<p>哦, 我才突然想起来还有这么一个作业要做, “其实青马的题挺好做的,\r\n500题也就是一天半天的样子.”—来自其他同学.\r\n那其实自己做也没什么大不了的嘛, 何必请人去刷呢.</p>\r\n<p>当我亲自做过大半百题后终于醒悟, 自己还是年轻了.\r\n青马易战的题目并不好做, 需要不浅的知识储备. 少年,\r\n快送自己一个青马易战自动答题机吧! 果然比起交钱给别人,\r\n还是用自己双手解决作业更加殷实.</p>\r\n<p>简单搜索之后, 喜得前辈真传.</p>\r\n<p><a href=\"https://blog.tawnx.com/?p=172\">青马易战解决方案-QingmaKiller\r\n- Tawn's Blog</a></p>\r\n<p><a\r\nhref=\"https://www.tqwba.com/x_d/jishu/316922.html\">python实现青马易站自动刷题_跳墙网</a></p>\r\n<p>理论存在, 实践开始! 虽然前辈说的东西完全没有接触, 但是看起来不难,\r\n似乎是爬虫技术? 那就开学吧!</p>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV1i54y1h75W/?vd_source=f538bf7f0a76787f3f19bc5c203190e7\">2021年最新Python爬虫教程+实战项目案例（最新录制）_哔哩哔哩_bilibili</a></p>\r\n<h1 id=\"前置\">前置</h1>\r\n<h2 id=\"http\">HTTP</h2>\r\n<p>当你与网页交互时, 浏览器会通过http协议与服务器沟通, 你说你想要的,\r\n然后服务器发给你想要的.</p>\r\n<p>你发出去的叫请求报文, 请求报文由三个部分构成:</p>\r\n<p>请求行 -&gt; 请求方式 请求url地址 协议</p>\r\n<p>首部行 -&gt; 附加信息</p>\r\n<p>请求体 -&gt; 请求参数</p>\r\n<p>你接受到的叫响应报文, 响应报文由三个部分构成:</p>\r\n<p>状态行 -&gt; 协议 状态码</p>\r\n<p>首部头 -&gt; 附加信息</p>\r\n<p>响应体 -&gt; 响应数据</p>\r\n<p>其中比较重要的是首部行中的:</p>\r\n<ol type=\"1\">\r\n<li>User-Agent: 你的访问设备, 记得伪装成手机哦</li>\r\n<li>cookie: 用户的登入信息, 就是标识你是你啦</li>\r\n</ol>\r\n<p>想要监控访问过程的报文可以直接浏览器’右键→检查→网络’查看</p>\r\n<figure>\r\n<img\r\nsrc=\"./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled.png/\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<h2 id=\"python\">Python</h2>\r\n<p>不会Python怎么办? 菜鸟速通看一看! Python支持中文变量真的很棒.</p>\r\n<p>只要了解一下基础的流程控制就好了. 然后了解一下字典/JSON/文件操作,\r\n用来存储答案.</p>\r\n<p><a\r\nhref=\"https://www.runoob.com/python3/python3-tutorial.html\">Python3 教程\r\n| 菜鸟教程</a></p>\r\n<h2 id=\"python-requests\"><strong>Python Requests</strong></h2>\r\n<p>选用Python的原因就在于此了,\r\nRequests可以非常方便的用来发送THHP请求</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br></pre></td></tr></table></figure>\r\n<p>记得伪装吗, 先定义一下首部行</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">header = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;User-Agent&quot;</span>: <span class=\"string\">&quot;XXX&quot;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;Cookie&#x27;</span>: <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后就可以访问网站啦</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.get(url = url, headers = header, params=param)</span><br><span class=\"line\">res = requests.post(url = url, headers = header, data = data)</span><br></pre></td></tr></table></figure>\r\n<p>用JSON提取出响应报文中的数据</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">数据 = json.loads(res.text)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"正则表达式\">正则表达式</h2>\r\n<p>拿到网页之后会需要从中找到的内容</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"开发\">开发</h1>\r\n<h2 id=\"获取cookie\">获取cookie</h2>\r\n<p>参考了前辈的代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取cookie</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">updateCookie</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        headers = &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;Accept-Encoding&#x27;</span>: <span class=\"string\">&#x27;gzip, deflate&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Accept-Language&#x27;</span>: <span class=\"string\">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Host&#x27;</span>: <span class=\"string\">&#x27;qm.linyisong.top&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Proxy-Connection&#x27;</span>: <span class=\"string\">&#x27;keep-alive&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;User-Agent&#x27;</span>: 省略</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = requests.get(<span class=\"variable language_\">self</span>.url, headers=headers)</span><br><span class=\"line\">        headers[<span class=\"string\">&#x27;Cookie&#x27;</span>]=re.<span class=\"keyword\">match</span>(<span class=\"string\">r&#x27;JSESSIONID=\\w*&#x27;</span>,res.headers[<span class=\"string\">&#x27;set-cookie&#x27;</span>]).group()</span><br><span class=\"line\">        res = requests.get(<span class=\"variable language_\">self</span>.url, headers=headers)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.cookie=headers[<span class=\"string\">&#x27;Cookie&#x27;</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;成功取得cookie&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"variable language_\">self</span>.cookie)</span><br><span class=\"line\">        res.close()</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"捕获通信\">捕获通信</h2>\r\n<p>先随便开一门做两题, 监控一下网络通信</p>\r\n<p>发现主要有两个通信行为, 一个nextSubject, 一个changeSituation,\r\n看一下.</p>\r\n<h3 id=\"在nextsubject里\">在nextSubject里</h3>\r\n<p>请求头</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /yiban-web/stu/nextSubject.jhtml?_=省略 HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Accept: application/json</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=<span class=\"number\">0.9</span>,en;q=<span class=\"number\">0.8</span></span><br><span class=\"line\">Content-Length: <span class=\"number\">10</span></span><br><span class=\"line\">Content-<span class=\"type\">Type</span>: application/x-www-form-urlencoded</span><br><span class=\"line\">Cookie: 省略</span><br><span class=\"line\">Host: qm.linyisong.top</span><br><span class=\"line\">Origin: http://qm.linyisong.top</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Referer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=<span class=\"number\">7</span></span><br><span class=\"line\">User-Agent: 省略</span><br></pre></td></tr></table></figure>\r\n<p>请求参数</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">courseId=<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\r\n<p>响应数据</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;data&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;nextSubject&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;courseId&quot;</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option0&quot;</span>: <span class=\"string\">&quot;主张统一&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option1&quot;</span>: <span class=\"string\">&quot;主张独立&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option2&quot;</span>: <span class=\"string\">&quot;不统不独&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option3&quot;</span>: <span class=\"string\">&quot;一国两府&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;optionCount&quot;</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;score&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;subDescript&quot;</span>: <span class=\"string\">&quot;当前国民党对两岸关系是&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;subType&quot;</span>: <span class=\"string\">&quot;单选题&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;timeLimit&quot;</span>: <span class=\"number\">60</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;uuid&quot;</span>: 省略</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;isSuccess&quot;</span>: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"在changesituation里\">在changeSituation里</h3>\r\n<p>请求头</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /yiban-web/stu/changeSituation.jhtml?_=省略 HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Accept: application/json</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=<span class=\"number\">0.9</span>,en;q=<span class=\"number\">0.8</span></span><br><span class=\"line\">Content-Length: <span class=\"number\">69</span></span><br><span class=\"line\">Content-<span class=\"type\">Type</span>: application/x-www-form-urlencoded</span><br><span class=\"line\">Cookie: 省略</span><br><span class=\"line\">Host: qm.linyisong.top</span><br><span class=\"line\">Origin: http://qm.linyisong.top</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Referer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=<span class=\"number\">7</span></span><br><span class=\"line\">User-Agent: 省略</span><br></pre></td></tr></table></figure>\r\n<p>请求参数</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer: A</span><br><span class=\"line\">courseId: <span class=\"number\">7</span></span><br><span class=\"line\">uuid: 省略</span><br></pre></td></tr></table></figure>\r\n<p>响应数据</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;data&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;rightAnswer&quot;</span>: false,</span><br><span class=\"line\">    <span class=\"string\">&quot;rightOption&quot;</span>: <span class=\"string\">&quot;C.不统不独&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;isSuccess&quot;</span>: true,</span><br><span class=\"line\">  <span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;回答错误！&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分析通信\">分析通信</h2>\r\n<p>多做几题对比之后, 可以发现:</p>\r\n<h3 id=\"请求行中的数字是时间戳\">请求行中的数字是时间戳</h3>\r\n<p>同样参考前辈的函数获取时间戳</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getTime</span>():</span><br><span class=\"line\">    t = <span class=\"built_in\">str</span>(time.time())</span><br><span class=\"line\">    a = <span class=\"built_in\">str</span>(t[<span class=\"number\">0</span>:<span class=\"number\">10</span>])</span><br><span class=\"line\">    b = <span class=\"built_in\">str</span>(t[<span class=\"number\">11</span>:<span class=\"number\">14</span>])</span><br><span class=\"line\">    res = a + b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用courseid请求题目\">使用courseId请求题目</h3>\r\n<p>在请求题目时, 只要在参数附带courseId就可以得到完整的题目报文,\r\n包括题面选项和类型</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">看题链接 = <span class=\"string\">&#x27;http://qm.linyisong.top/yiban-web/stu/nextSubject.jhtml?_=&#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(getTime())</span><br><span class=\"line\">   headers = &#123;</span><br><span class=\"line\"> <span class=\"string\">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   让我看看 = &#123;</span><br><span class=\"line\">       <span class=\"string\">&#x27;courseId&#x27;</span>: courseId</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   res = requests.post(看题链接, headers = headers, data = 让我看看)</span><br></pre></td></tr></table></figure>\r\n<p>在响应报文里我们可以得到我们想要的题目和下面要用到的UUID</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uuid = json.loads(res.text)[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;uuid&#x27;</span>]</span><br><span class=\"line\">题目 = json.loads(res.text)[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;nextSubject&#x27;</span>]</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用uuid回答题目\">使用UUID回答题目</h3>\r\n<p>在回答题目时, 需要在参数中附带答案, courseId和UUID</p>\r\n<p>答案只是ABCD, 即使是判断题, 也是用AB表示的</p>\r\n<p>courseId直接同科目即可</p>\r\n<p>UUID是题目报文中的一部分, 从中获取</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答题链接 = <span class=\"string\">&#x27;http://qm.linyisong.top/yiban-web/stu/changeSituation.jhtml?_=&#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(getTime())</span><br><span class=\"line\">   headers = &#123;</span><br><span class=\"line\"> <span class=\"string\">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   让我猜猜 = &#123;</span><br><span class=\"line\">       <span class=\"string\">&#x27;answer&#x27;</span>: 答案,</span><br><span class=\"line\">       <span class=\"string\">&#x27;courseId&#x27;</span>: courseId,</span><br><span class=\"line\">       <span class=\"string\">&#x27;uuid&#x27;</span>: uuid</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   res_ = requests.post(答题链接, headers = headers, data = 让我猜猜)</span><br></pre></td></tr></table></figure>\r\n<p>在响应报文里我们可以得到正确答案和作答情况</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正确答案 = json.loads(res_.text)[<span class=\"string\">&#x27;data&#x27;</span>]</span><br><span class=\"line\"> 作答情况 = json.loads(res_.text)[<span class=\"string\">&#x27;message&#x27;</span>]</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"正确做题\">正确做题</h2>\r\n<p>既然我们可以得到完整题目和正确答案, 又能提交自己想要的答案,\r\n那么就可以收集题库了, 然后在做题时到题库中检索,\r\n如果有答案就回答正确答案, 没有答案就随便回答一个吧</p>\r\n<h3 id=\"查询答案\"><strong>查询答案</strong></h3>\r\n<p>用题目和答案建立一个字典, 然后在字典里查</p>\r\n<p>这部分也不知道在使用Python时怎样更高效, 有大佬可以教教QWQ</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 题目 <span class=\"keyword\">in</span> 题库:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;匹配答案!&#x27;</span>)</span><br><span class=\"line\">    答案 = 题库[题目]</span><br><span class=\"line\">    匹配到答案 = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;没有答案!&#x27;</span>)</span><br><span class=\"line\">    答案 = <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\">    匹配到答案 = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"录入题库\">录入题库</h3>\r\n<p>把获取到的题目写入文件本地保存</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 匹配到答案 == <span class=\"number\">0</span>:</span><br><span class=\"line\">     新题目 = &#123;题目,正确答案&#125;</span><br><span class=\"line\">     <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;database_&#123;&#125;.json&#x27;</span>.<span class=\"built_in\">format</span>(courseId), <span class=\"string\">&#x27;a+&#x27;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">         json.dump(新题目, f, ensure_ascii=<span class=\"literal\">False</span>)</span><br><span class=\"line\">         f.write(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">         f.close()</span><br><span class=\"line\">     <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;题目入库!&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"加载题库\">加载题库</h3>\r\n<p>把本地文件加载成题库</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题库 = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;database_&#123;&#125;.json&#x27;</span>.<span class=\"built_in\">format</span>(courseId), <span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">     <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f.readlines():</span><br><span class=\"line\">         题目 = json.loads(line)</span><br><span class=\"line\">     f.close()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;--&gt;题库预载成功,有题目:&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"built_in\">len</span>(题库))+<span class=\"string\">&#x27;道&lt;--&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"自动化\">自动化</h2>\r\n<p>最后, 把上述零件进行一个拼接就可以运行啦!</p>\r\n<p>收集足够多的题目即可保证正确率.</p>\r\n<h1 id=\"后记\">后记</h1>\r\n<p>这是一次成果导向的学习, 不得不说在一个目标的指引下, 人会非常有动力.\r\n不过迷茫也是真的迷茫, 全程百度和问人: “啊你会Python吗?”. 哈哈哈.</p>\r\n<p>从上午十点钟有想法开始, 一直做到了凌晨三点,\r\n晚饭甚至也不记得吃了<del>奶茶没忘记喝</del>, 虽然效率很低,\r\n但是成就感很足.</p>\r\n<p>在最后的凌晨几个小时里, 就是不断地调试一些BUG和优化打包了,\r\n包括网络问题和文件读写, 就留给读者自己尝试吧.</p>\r\n<p>虽然我是从不想给别人交钱开始, 但是在成品完成之后, 也有了商业化的想法,\r\n但是果然还是太麻烦了吧, 我不想和陌生人讲话.</p>\r\n<p>最后感谢前辈的文章, 首先可行先给我信心, 然后内容也给我帮助,\r\n大佬太多啦, 我还是要努力才行.</p>\r\n","excerpt":"","more":"<aside>\r\n<p>💡 自动化是送给自己最好的礼物——沃兹基硕德</p>\r\n</aside>\r\n<p>v-1.0 少年, 快送自己一个青马易战自动答题机吧!</p>\r\n<blockquote>\r\n<p>免责声明: 本文仅为个人学习交流日志, 禁止复制/下载等内容迁移行为!</p>\r\n</blockquote>\r\n<h1 id=\"起因\">起因</h1>\r\n<p>又是网课摸鱼的一天, 我在QQ空间上冲浪,\r\n突然刷到同学转发的”青马易战代刷”. 只要支付7R~12R,\r\n对方就会帮你刷完一科500题的青马易战.</p>\r\n<p>哦, 我才突然想起来还有这么一个作业要做, “其实青马的题挺好做的,\r\n500题也就是一天半天的样子.”—来自其他同学.\r\n那其实自己做也没什么大不了的嘛, 何必请人去刷呢.</p>\r\n<p>当我亲自做过大半百题后终于醒悟, 自己还是年轻了.\r\n青马易战的题目并不好做, 需要不浅的知识储备. 少年,\r\n快送自己一个青马易战自动答题机吧! 果然比起交钱给别人,\r\n还是用自己双手解决作业更加殷实.</p>\r\n<p>简单搜索之后, 喜得前辈真传.</p>\r\n<p><a href=\"https://blog.tawnx.com/?p=172\">青马易战解决方案-QingmaKiller\r\n- Tawn's Blog</a></p>\r\n<p><a\r\nhref=\"https://www.tqwba.com/x_d/jishu/316922.html\">python实现青马易站自动刷题_跳墙网</a></p>\r\n<p>理论存在, 实践开始! 虽然前辈说的东西完全没有接触, 但是看起来不难,\r\n似乎是爬虫技术? 那就开学吧!</p>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV1i54y1h75W/?vd_source=f538bf7f0a76787f3f19bc5c203190e7\">2021年最新Python爬虫教程+实战项目案例（最新录制）_哔哩哔哩_bilibili</a></p>\r\n<h1 id=\"前置\">前置</h1>\r\n<h2 id=\"http\">HTTP</h2>\r\n<p>当你与网页交互时, 浏览器会通过http协议与服务器沟通, 你说你想要的,\r\n然后服务器发给你想要的.</p>\r\n<p>你发出去的叫请求报文, 请求报文由三个部分构成:</p>\r\n<p>请求行 -&gt; 请求方式 请求url地址 协议</p>\r\n<p>首部行 -&gt; 附加信息</p>\r\n<p>请求体 -&gt; 请求参数</p>\r\n<p>你接受到的叫响应报文, 响应报文由三个部分构成:</p>\r\n<p>状态行 -&gt; 协议 状态码</p>\r\n<p>首部头 -&gt; 附加信息</p>\r\n<p>响应体 -&gt; 响应数据</p>\r\n<p>其中比较重要的是首部行中的:</p>\r\n<ol type=\"1\">\r\n<li>User-Agent: 你的访问设备, 记得伪装成手机哦</li>\r\n<li>cookie: 用户的登入信息, 就是标识你是你啦</li>\r\n</ol>\r\n<p>想要监控访问过程的报文可以直接浏览器’右键→检查→网络’查看</p>\r\n<figure>\r\n<img\r\nsrc=\"./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled.png/\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<figure>\r\n<img\r\nsrc=\"./%E5%86%8D%E8%A7%81%E4%BA%86-%E9%9D%92%E9%A9%AC%E6%98%93%E6%88%98/Untitled%201.png\"\r\nalt=\"Untitled\" />\r\n<figcaption aria-hidden=\"true\">Untitled</figcaption>\r\n</figure>\r\n<h2 id=\"python\">Python</h2>\r\n<p>不会Python怎么办? 菜鸟速通看一看! Python支持中文变量真的很棒.</p>\r\n<p>只要了解一下基础的流程控制就好了. 然后了解一下字典/JSON/文件操作,\r\n用来存储答案.</p>\r\n<p><a\r\nhref=\"https://www.runoob.com/python3/python3-tutorial.html\">Python3 教程\r\n| 菜鸟教程</a></p>\r\n<h2 id=\"python-requests\"><strong>Python Requests</strong></h2>\r\n<p>选用Python的原因就在于此了,\r\nRequests可以非常方便的用来发送THHP请求</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br></pre></td></tr></table></figure>\r\n<p>记得伪装吗, 先定义一下首部行</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">header = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;User-Agent&quot;</span>: <span class=\"string\">&quot;XXX&quot;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;Cookie&#x27;</span>: <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>然后就可以访问网站啦</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = requests.get(url = url, headers = header, params=param)</span><br><span class=\"line\">res = requests.post(url = url, headers = header, data = data)</span><br></pre></td></tr></table></figure>\r\n<p>用JSON提取出响应报文中的数据</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">数据 = json.loads(res.text)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"正则表达式\">正则表达式</h2>\r\n<p>拿到网页之后会需要从中找到的内容</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"开发\">开发</h1>\r\n<h2 id=\"获取cookie\">获取cookie</h2>\r\n<p>参考了前辈的代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取cookie</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">updateCookie</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        headers = &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;Accept-Encoding&#x27;</span>: <span class=\"string\">&#x27;gzip, deflate&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Accept-Language&#x27;</span>: <span class=\"string\">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Host&#x27;</span>: <span class=\"string\">&#x27;qm.linyisong.top&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Proxy-Connection&#x27;</span>: <span class=\"string\">&#x27;keep-alive&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;User-Agent&#x27;</span>: 省略</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = requests.get(<span class=\"variable language_\">self</span>.url, headers=headers)</span><br><span class=\"line\">        headers[<span class=\"string\">&#x27;Cookie&#x27;</span>]=re.<span class=\"keyword\">match</span>(<span class=\"string\">r&#x27;JSESSIONID=\\w*&#x27;</span>,res.headers[<span class=\"string\">&#x27;set-cookie&#x27;</span>]).group()</span><br><span class=\"line\">        res = requests.get(<span class=\"variable language_\">self</span>.url, headers=headers)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.cookie=headers[<span class=\"string\">&#x27;Cookie&#x27;</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;成功取得cookie&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"variable language_\">self</span>.cookie)</span><br><span class=\"line\">        res.close()</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"捕获通信\">捕获通信</h2>\r\n<p>先随便开一门做两题, 监控一下网络通信</p>\r\n<p>发现主要有两个通信行为, 一个nextSubject, 一个changeSituation,\r\n看一下.</p>\r\n<h3 id=\"在nextsubject里\">在nextSubject里</h3>\r\n<p>请求头</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /yiban-web/stu/nextSubject.jhtml?_=省略 HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Accept: application/json</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=<span class=\"number\">0.9</span>,en;q=<span class=\"number\">0.8</span></span><br><span class=\"line\">Content-Length: <span class=\"number\">10</span></span><br><span class=\"line\">Content-<span class=\"type\">Type</span>: application/x-www-form-urlencoded</span><br><span class=\"line\">Cookie: 省略</span><br><span class=\"line\">Host: qm.linyisong.top</span><br><span class=\"line\">Origin: http://qm.linyisong.top</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Referer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=<span class=\"number\">7</span></span><br><span class=\"line\">User-Agent: 省略</span><br></pre></td></tr></table></figure>\r\n<p>请求参数</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">courseId=<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\r\n<p>响应数据</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;data&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;nextSubject&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;courseId&quot;</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option0&quot;</span>: <span class=\"string\">&quot;主张统一&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option1&quot;</span>: <span class=\"string\">&quot;主张独立&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option2&quot;</span>: <span class=\"string\">&quot;不统不独&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;option3&quot;</span>: <span class=\"string\">&quot;一国两府&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;optionCount&quot;</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;score&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;subDescript&quot;</span>: <span class=\"string\">&quot;当前国民党对两岸关系是&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;subType&quot;</span>: <span class=\"string\">&quot;单选题&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;timeLimit&quot;</span>: <span class=\"number\">60</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;uuid&quot;</span>: 省略</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;isSuccess&quot;</span>: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"在changesituation里\">在changeSituation里</h3>\r\n<p>请求头</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /yiban-web/stu/changeSituation.jhtml?_=省略 HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Accept: application/json</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=<span class=\"number\">0.9</span>,en;q=<span class=\"number\">0.8</span></span><br><span class=\"line\">Content-Length: <span class=\"number\">69</span></span><br><span class=\"line\">Content-<span class=\"type\">Type</span>: application/x-www-form-urlencoded</span><br><span class=\"line\">Cookie: 省略</span><br><span class=\"line\">Host: qm.linyisong.top</span><br><span class=\"line\">Origin: http://qm.linyisong.top</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Referer: http://qm.linyisong.top/yiban-web/stu/toSubject.jhtml?courseId=<span class=\"number\">7</span></span><br><span class=\"line\">User-Agent: 省略</span><br></pre></td></tr></table></figure>\r\n<p>请求参数</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer: A</span><br><span class=\"line\">courseId: <span class=\"number\">7</span></span><br><span class=\"line\">uuid: 省略</span><br></pre></td></tr></table></figure>\r\n<p>响应数据</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;data&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;rightAnswer&quot;</span>: false,</span><br><span class=\"line\">    <span class=\"string\">&quot;rightOption&quot;</span>: <span class=\"string\">&quot;C.不统不独&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;isSuccess&quot;</span>: true,</span><br><span class=\"line\">  <span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;回答错误！&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分析通信\">分析通信</h2>\r\n<p>多做几题对比之后, 可以发现:</p>\r\n<h3 id=\"请求行中的数字是时间戳\">请求行中的数字是时间戳</h3>\r\n<p>同样参考前辈的函数获取时间戳</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getTime</span>():</span><br><span class=\"line\">    t = <span class=\"built_in\">str</span>(time.time())</span><br><span class=\"line\">    a = <span class=\"built_in\">str</span>(t[<span class=\"number\">0</span>:<span class=\"number\">10</span>])</span><br><span class=\"line\">    b = <span class=\"built_in\">str</span>(t[<span class=\"number\">11</span>:<span class=\"number\">14</span>])</span><br><span class=\"line\">    res = a + b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用courseid请求题目\">使用courseId请求题目</h3>\r\n<p>在请求题目时, 只要在参数附带courseId就可以得到完整的题目报文,\r\n包括题面选项和类型</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">看题链接 = <span class=\"string\">&#x27;http://qm.linyisong.top/yiban-web/stu/nextSubject.jhtml?_=&#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(getTime())</span><br><span class=\"line\">   headers = &#123;</span><br><span class=\"line\"> <span class=\"string\">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   让我看看 = &#123;</span><br><span class=\"line\">       <span class=\"string\">&#x27;courseId&#x27;</span>: courseId</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   res = requests.post(看题链接, headers = headers, data = 让我看看)</span><br></pre></td></tr></table></figure>\r\n<p>在响应报文里我们可以得到我们想要的题目和下面要用到的UUID</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uuid = json.loads(res.text)[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;uuid&#x27;</span>]</span><br><span class=\"line\">题目 = json.loads(res.text)[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;nextSubject&#x27;</span>]</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用uuid回答题目\">使用UUID回答题目</h3>\r\n<p>在回答题目时, 需要在参数中附带答案, courseId和UUID</p>\r\n<p>答案只是ABCD, 即使是判断题, 也是用AB表示的</p>\r\n<p>courseId直接同科目即可</p>\r\n<p>UUID是题目报文中的一部分, 从中获取</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答题链接 = <span class=\"string\">&#x27;http://qm.linyisong.top/yiban-web/stu/changeSituation.jhtml?_=&#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(getTime())</span><br><span class=\"line\">   headers = &#123;</span><br><span class=\"line\"> <span class=\"string\">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   让我猜猜 = &#123;</span><br><span class=\"line\">       <span class=\"string\">&#x27;answer&#x27;</span>: 答案,</span><br><span class=\"line\">       <span class=\"string\">&#x27;courseId&#x27;</span>: courseId,</span><br><span class=\"line\">       <span class=\"string\">&#x27;uuid&#x27;</span>: uuid</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   res_ = requests.post(答题链接, headers = headers, data = 让我猜猜)</span><br></pre></td></tr></table></figure>\r\n<p>在响应报文里我们可以得到正确答案和作答情况</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正确答案 = json.loads(res_.text)[<span class=\"string\">&#x27;data&#x27;</span>]</span><br><span class=\"line\"> 作答情况 = json.loads(res_.text)[<span class=\"string\">&#x27;message&#x27;</span>]</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"正确做题\">正确做题</h2>\r\n<p>既然我们可以得到完整题目和正确答案, 又能提交自己想要的答案,\r\n那么就可以收集题库了, 然后在做题时到题库中检索,\r\n如果有答案就回答正确答案, 没有答案就随便回答一个吧</p>\r\n<h3 id=\"查询答案\"><strong>查询答案</strong></h3>\r\n<p>用题目和答案建立一个字典, 然后在字典里查</p>\r\n<p>这部分也不知道在使用Python时怎样更高效, 有大佬可以教教QWQ</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 题目 <span class=\"keyword\">in</span> 题库:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;匹配答案!&#x27;</span>)</span><br><span class=\"line\">    答案 = 题库[题目]</span><br><span class=\"line\">    匹配到答案 = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;没有答案!&#x27;</span>)</span><br><span class=\"line\">    答案 = <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\">    匹配到答案 = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"录入题库\">录入题库</h3>\r\n<p>把获取到的题目写入文件本地保存</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 匹配到答案 == <span class=\"number\">0</span>:</span><br><span class=\"line\">     新题目 = &#123;题目,正确答案&#125;</span><br><span class=\"line\">     <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;database_&#123;&#125;.json&#x27;</span>.<span class=\"built_in\">format</span>(courseId), <span class=\"string\">&#x27;a+&#x27;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">         json.dump(新题目, f, ensure_ascii=<span class=\"literal\">False</span>)</span><br><span class=\"line\">         f.write(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">         f.close()</span><br><span class=\"line\">     <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;题目入库!&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"加载题库\">加载题库</h3>\r\n<p>把本地文件加载成题库</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题库 = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;database_&#123;&#125;.json&#x27;</span>.<span class=\"built_in\">format</span>(courseId), <span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">     <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f.readlines():</span><br><span class=\"line\">         题目 = json.loads(line)</span><br><span class=\"line\">     f.close()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;--&gt;题库预载成功,有题目:&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"built_in\">len</span>(题库))+<span class=\"string\">&#x27;道&lt;--&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"自动化\">自动化</h2>\r\n<p>最后, 把上述零件进行一个拼接就可以运行啦!</p>\r\n<p>收集足够多的题目即可保证正确率.</p>\r\n<h1 id=\"后记\">后记</h1>\r\n<p>这是一次成果导向的学习, 不得不说在一个目标的指引下, 人会非常有动力.\r\n不过迷茫也是真的迷茫, 全程百度和问人: “啊你会Python吗?”. 哈哈哈.</p>\r\n<p>从上午十点钟有想法开始, 一直做到了凌晨三点,\r\n晚饭甚至也不记得吃了<del>奶茶没忘记喝</del>, 虽然效率很低,\r\n但是成就感很足.</p>\r\n<p>在最后的凌晨几个小时里, 就是不断地调试一些BUG和优化打包了,\r\n包括网络问题和文件读写, 就留给读者自己尝试吧.</p>\r\n<p>虽然我是从不想给别人交钱开始, 但是在成品完成之后, 也有了商业化的想法,\r\n但是果然还是太麻烦了吧, 我不想和陌生人讲话.</p>\r\n<p>最后感谢前辈的文章, 首先可行先给我信心, 然后内容也给我帮助,\r\n大佬太多啦, 我还是要努力才行.</p>\r\n"},{"title":"Space SHMUP 拆解和拓展","mathjax":true,"date":"2024-11-19T11:56:54.000Z","_content":" \n\n# 游戏内容分析\n\nSHMUP （Shoot 'em up），又称STG，即清版射击游戏, 是一种游戏类型，通常以玩家控制飞行器或角色为基础，目标是消灭敌人并躲避子弹和障碍物。SHMUP游戏通常具有快节奏的动作、丰富的视觉效果和多样化的武器系统。\n\n\n![image.png](image.png)\n\n本项目来自***Introduction to Game Design, Prototyping, and Development*** 的 Space SHMUP. 含有五种敌人角色和两种武器类型, 玩家需要操纵飞船躲避敌人, 攻击敌人, 当击败敌人时可以获得加成道具.\n\n## 玩家角色\n\n![image.png](image%201.png)\n<!--more-->\n### 玩家飞船的意义\n\n1. 当游戏开始时出现在地图中\n2. 当玩家飞船被消灭后游戏结束\n\n### 玩家飞船的能力\n\n1. 在地图上移动\n2. 控制武器开火\n\n### 玩家飞船与其他对象的交互\n\n1. 碰撞到敌人, 导致自生护盾减少, 当自身无护盾时被消灭\n2. 碰撞到加成道具, 导致武器系统发生变化\n\n## 敌人角色\n\n![image.png](image%202.png)\n\n敌人包括五种\n\n### 敌人飞船的意义\n\n1. 根据游戏时间进行, 敌人飞船会随机在地图中生成, 给玩家飞船的生存带来负面影响\n\n    [待扩展]将敌人生成预设为波次进攻模式, 根据关卡难度控制生成情况\n\n### 敌人飞船的能力\n\n1. 在地图中移动, 不同的飞船有各自不同的移动能力\n    1. Enemy_0从地图上侧随机处生成, 向地图最下端直线移动, 从下侧离开地图\n    2. Enemy_1从地图上侧随机处生成, 向地图最下端移动的同时左右摇摆, 从下侧离开地图\n    3. Enemy_2从地图左右侧随机生成, 横向进入地图, 来回穿越一回合后从另一侧离开地图\n    4. Enemy_3从地图上侧随机处生成, 纵向进入地图, 抵达路径最低处后从上侧离开地图\n    5. Enemy_4从地图上侧随机处生成, 每隔一段时间, 在地图的四个象限没移动, 不会离开地图\n2. 掉落武器系统加成道具\n3. [可扩展]获得武器并控制武器开火\n\n### 敌人飞船与其他对象的交互\n\n1. 承受玩家武器的攻击(碰撞到子弹), 减少生命值, 当生命值归零时, 自身销毁.\n    1. Enemy_4持有护盾, 当收到攻击时, 优先消耗护盾的生命值\n2. 碰撞到玩家飞船, 导致自身销毁.\n\n## 武器系统\n\n![image.png](image%203.png)\n\n玩家护盾虽与暂时玩家飞船绑定, 但可改造为武器系统的一部分\n\n### 武器系统的意义\n\n1. 为玩家飞船提供清理敌人飞船的能力, 使得玩家飞船在游戏中生存下来\n2. 含有5个武器挂载点位, 为玩家提供了武器的选择和升级空间, 使游戏更加有趣\n\n### 武器系统的能力\n\n1. 当玩家控制开火时, 武器可以以不同形式发射弹药, 而弹药可以攻击并消灭敌人\n    1. Blaster 每次开火向正前方发射一枚子弹, 子弹会向前移动直到地图边缘, 发射间隔较短\n    2. Spread 每次开火向前方扇形排布发射多枚子弹, , 子弹会向前移动直到地图边缘, 发射间隔较长\n    3. [待扩展]Missile 每次开火发射一枚导弹, 导弹可以自动跟踪敌人\n\n### 武器系统与其他对象的交互\n\n1. 武器本身不与敌人交互, 而是通过弹药来与敌人交互, 武器的职责是是生成弹药, 当弹药接触到敌人时, 给敌人造成伤害\n2. 武器系统会根据玩家接触到的加成道具进行改变\n    1. 玩家最多持有五个武器\n    2. 当玩家获得的加成和已持有的武器类型一致时, 武器系统得到强化\n    3. 当玩家获得的加成和已持有武器类型不一致时, 将玩家的武器替换为所加成的武器, 此时武器系统可能强化或弱化\n\n## 加成道具\n\n![image.png](image%204.png)\n\n### 加成道具的意义\n\n1. 加成道具可以为玩家提供武器系统的加成选项\n2. 加成道具可以让玩家提供一个选择, 是否需要穿越危险的交战区, 去获得加成道具, 使得游戏局面变得复杂有趣\n\n### 加成道具的能力\n\n1. 不同的加成道具可以给玩家提供不同的升级\n    1. Shield 增强玩家的护盾\n    2. Spread 给玩家添加Spread 武器\n    3. Blaster 给玩家添加Blaster 武器\n    4. [可扩展] 同步武器系统的武器类型, 提供加成\n    5. [可扩展] 对游戏局势产生重大效果, 如对所有敌人造成伤害\n\n### 加成道具与其他对象的交互\n\n1. 与玩家飞船碰撞, 导致自身被消耗, 对玩家飞船造成相应影响\n2. 当敌人被消灭时, 根据概率设定, 生成不同的加成道具\n3. [可扩展]与敌人飞船碰撞, 导致自身被销毁\n4. [可扩展]与敌人飞船碰撞, 对敌人飞船产生影响\n\n# 系统分析与实现\n\n## BoundsCheck\n\n一个通用组件, 用于判断游戏对象是否在屏幕中, 获取相对屏幕的位置.\n\n可以用来管理游戏对象, 包括玩家\\敌人\\子弹的移动范围限制和移出屏幕后销毁.\n\n使用了复合枚举来保存位置信息.\n\n为每一个游戏对象添加BoundsCheck 组件, 通过调用boundsCheck.isOnScreen()或boundsCheck.LocIs来获取信息.\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\npublic class BoundsCheck : MonoBehaviour {\n    [System.Flags]\n    public enum eScreenLocs {\n        onScreen = 0,\n        offRight = 1,\n        offLeft = 2,\n        offTop = 4,\n        offBottom = 8,\n    }\n    public enum eType { center, inset, outset }\n    [Header(\"Inscribed\")]\n    public eType boundsType = eType.center;\n    public float radius = 1f;\n    public bool keepOnScreen = true;\n\n    [Header(\"Dynamic\")]\n    public eScreenLocs screenLocs = eScreenLocs.onScreen;\n    public float camWidth;\n    public float camHeight;\n\n    void LateUpdate() {\n        //更新screenLocs \n    }\n    public bool isOnScreen {\n        get { return screenLocs == eScreenLocs.onScreen; }\n    }\n    public bool LocIs(eScreenLocs checkLoc) {\n        if (checkLoc == eScreenLocs.onScreen) {\n            return isOnScreen;\n        }\n        return (screenLocs & checkLoc) == checkLoc;\n    }\n}\n\n```\n\n## Enemy\n\n```mermaid\nclassDiagram\n    class Main {\n        - static Main S\n        - GameObject[] prefabEnemies\n        - float enemySpawnPerSecond\n        + Awake()\n        + SpawnEnemy()\n    }\n\n    class Enemy {\n        <<abstract>>\n        + float speed\n        + float health\n        + Vector3 pos\n        + Move()\n        + OnCollisionEnter(Collision coll)\n    }\n\n    class Enemy_1 {\n        + float waveFrequency\n        + float waveWidth\n        - float x0\n        - float birthTime\n        + Move()\n    }\n\n    class ProjectileHero {\n        + float damageOnHit\n    }\n\n    Main --> Enemy : \"生成\"\n    Main --> prefabEnemies : \"管理预制件\"\n    Enemy_1 --> Enemy : \"继承\"\n    Enemy --> ProjectileHero : \"检测碰撞\"\n\n```\n\n### Enemy生成\n\nEnemy的生成为全局管理, 由游戏唯一Main对象管理, Main为单例, 且保存所有Enemy的预制件.\n\n当Main对象被创建后, 每隔一段时间调用SpawnEnemy()方法, 由SpawnEnemy()生成一个Enemy, 在SpawnEnemy中选取要生成的具体Enemy可以要生成的具体坐标, 然后通过Invoke延时递归调用自身.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing Random = UnityEngine.Random;\n\npublic class Main : MonoBehaviour\n{\n    static private Main S;\n    public GameObject[] prefabEnemies;\n    public float enemySpawnPerSecond = 0.5f;\n\n    void Awake()\n    {\n        S = this;\n        Invoke(nameof(SpawnEnemy), 1f / enemySpawnPerSecond);\n    }\n\n    public void SpawnEnemy()\n    {\n        // 随机选取一个要生成的Enemy\n        int ndx = Random.Range(0, prefabEnemies.Length);\n        GameObject newEnemy = Instantiate<GameObject>(prefabEnemies[ndx]);\n        // 获取Enemy要生成的坐标\n        Vector3 pos = Vector3.zero;\n        newEnemy.transform.position = pos;\n        // 根据配置生成下一个Enemy\n        Invoke(nameof(SpawnEnemy), 1f / enemySpawnPerSecond);\n    }\n}\n```\n\n![image.png](image%205.png)\n\n### Enemy基类和扩展类\n\nEnemy预制件附带有对应的Enemy脚本, 控制对应Enemy的行为.\n\n![image.png](image%206.png)\n\n每一种Enemy的通用属性, 如移动速度, 血量, 可以定义在基类中\n\n![image.png](image%207.png)\n\n每一种Enemy的移动方式不同, 可以再基类中实现基本移动功能, 在具体类中实现扩展功能.\n\nEnemy基类, 实现基本向下移动\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class Enemy : MonoBehaviour {\n    [Header(\"Inscribed\")]\n    public float speed = 10f;\n    public float fireRate = 0.3f;\n    public float health = 10;\n    public int score = 100;\n    public Vector3 pos {\n        get {\n            return transform.position;\n        }\n        set {\n            transform.position = value;\n        }\n    }\n    void Update() {\n        Move();\n    }\n\n    public virtual void Move() {\n        Vector3 tempPos = pos;\n        tempPos.y -= speed * Time.deltaTime;\n        pos = tempPos;\n    }\n}\n\n```\n\n例如: Enemy_1子类, 重写Move方法, 实现带有摆动的移动.\n\n通过Sin函数和存货时间计算摆动横向偏移量, 而基础的向下移动功能, 又由Enemy基类完成.\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_1 : Enemy {\n    [Header(\"Enemy_1 Inscribed Fields\")]\n    [Tooltip(\"# of seconds for a full sine wave\")]\n    public float waveFrequency = 2;\n    [Tooltip(\"Sine wave width in meters\")]\n    public float waveWidth = 6;\n    private float x0;\n    private float birthTime;\n\n    void Start() {\n        x0 = pos.x;\n        birthTime = Time.time;\n    }\n\n    public override void Move() {\n        Vector3 tempPos = pos;\n        float age = Time.time - birthTime;\n        float theta = Mathf.PI * 2 * age / waveFrequency;\n        float sin = Mathf.Sin(theta);\n        tempPos.x = x0 + sin * waveWidth;\n        pos = tempPos;\n        \n        base.Move();\n    }\n}\n\n```\n\n### Enemy受击处理\n\nEnemy可以和弹药类ProjectileHero进行碰撞, 通过Layer设置是否可以碰撞, 然后在OnCollisionEnter中处理具体碰撞逻辑.\n\n弹药由武器生成, 弹药有伤害数值, 下文另谈.\n\n弹药游戏对象持有ProjectileHero组件, 可用来判断Enemy碰撞到的是否是弹药.\n\n当Enemy碰撞到弹药后, 销毁弹药. 同时扣除自身血量, 血量耗尽后销毁Enemy.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class Enemy : MonoBehaviour {\n\n    public float health = 10;\n    \n    void OnCollisionEnter(Collision coll) {\n        GameObject otherGO = coll.gameObject;\n        ProjectileHero projectileHero = otherGO.GetComponent<ProjectileHero>();\n        if (projectileHero != null) {\n            if (bndCheck.isOnScreen) {\n                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;\n                if (health < 0) {\n                    if (!calledShipDestroyed) {\n                        calledShipDestroyed = true;\n                        Main.SHIP_DESTROYED(this);\n                    }\n                    Destroy(gameObject);\n                }\n            }\n            Destroy(otherGO);\n        } else {\n            Debug.Log(\"Enemy hit by non-ProjectileHero: \" + otherGO.name);\n        }\n    }\n}\n\n```\n\n## Hero\n\n### Hero生成\n\n玩家飞船也为全局唯一对象, 使用单例模式, 使用Hero脚本控制行为.\n\n因为不会重复生成, 所以游戏开始时直接布置在场景Scene中.\n\n![image.png](image%208.png)\n\n### 玩家移动控制\n\n有参数最大速度. 根据帧间时间计算移动后所处位置, 直接改变.\n\n每帧读取移动虚拟轴输入, 实现平滑移动.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n\n    [Header(\"Inscribed\")]\n    public float maxSpeed = 30;\n\n    void Awake() {\n        if (S == null) {\n            S = this;\n        } else {\n            Debug.LogError(\"Hero.Awake() - Attempted to assign second Hero.S!\");\n        }\n    }\n\n    void Update() {\n        float hAxis = Input.GetAxis(\"Horizontal\");\n        float vAxis = Input.GetAxis(\"Vertical\");\n\n        Vector3 pos = transform.position;\n        pos.x += hAxis * maxSpeed * Time.deltaTime;\n        pos.y += vAxis * maxSpeed * Time.deltaTime;\n        transform.position = pos;\n\n    }\n}\n\n```\n\n### 玩家开火控制\n\n每帧读取开火虚拟轴输入, 触发开火事件. 具体开火实现见武器系统.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    public delegate void WeaponFireDelegate();\n    public event WeaponFireDelegate fireEvent;\n\n    void Update() {\n      if (Input.GetAxis(\"Jump\") == 1 && fireEvent != null) {\n            fireEven();\n        }\n    }\n\n}\n\n```\n\n## Weapon\n\n### Weapon配置管理和切换\n\n```mermaid\nclassDiagram\n    class Main {\n        - Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT\n        + WeaponDefinition[] weaponDefinitions\n        + WeaponDefinition GET_WEAPON_DEFINITION(eWeaponType wt)\n        + Awake()\n    }\n    \n    class Weapon {\n        - eWeaponType _type\n        - WeaponDefinition def\n        - float nextShotTime\n        - GameObject weaponModel\n        + SetType(eWeaponType type)\n    }\n\n    class WeaponDefinition {\n        + eWeaponType type\n        + GameObject weaponModelPrefab\n        + GameObject projectilePrefab\n        + float delayBetweenShots\n        + float velocity\n    }\n\n    class eWeaponType {\n        <<enumeration>>\n        none\n        blaster\n        spread\n    }\n\n    Main --> WeaponDefinition : \"管理\"\n    Weapon --> WeaponDefinition : \"获取和应用\"\n    Main --> eWeaponType : \"依赖\"\n    Weapon --> eWeaponType : \"依赖\"\n    WeaponDefinition --> eWeaponType : \"定义\"\n  WeaponDefinition --> weaponModelPrefab: \"管理预制件\"\n  WeaponDefinition --> projectilePrefab: \"管理预制件\"\n```\n\n在本系统中, 武器被实现为一个可以通过类型枚举来配置武器行为的对象. 武器对象是一直存在的, 会根据类型的切换改变表现的形态.\n\n武器的具体参数又保存在具体的武器定义类中. 不仅仅是数值参数, 还有模型预制体参数和子弹预制体参数.\n\n```csharp\n// 武器类型的枚举\npublic enum eWeaponType {\n    none,       // 无\n    blaster,    // 爆能枪\n    spread,     // 散射枪\n}\n\n// 武器定义类，描述每种武器的属性\n[System.Serializable]\npublic class WeaponDefinition {\n    public eWeaponType type = eWeaponType.none;  // 武器类型，默认无\n    [Tooltip(\"附加到玩家飞船上的武器模型预制件\")]  // 提示：武器模型的预制件\n    public GameObject weaponModelPrefab;\n    [Tooltip(\"发射的投射物预制件\")]  // 提示：发射的投射物的预制件\n    public GameObject projectilePrefab;\n    [Tooltip(\"每次射击之间的延迟秒数\")]  // 提示：射击间隔时间\n    public float delayBetweenShots = 0;\n    [Tooltip(\"单个投射物的速度\")]  // 提示：投射物速度\n    public float velocity = 50;\n}\n```\n\n所有的武器定义类被保存在Main对象中, 便于统一修改.\n\n使用一个列表weaponDefinitions来保存所有的武器定义类, 在Unity中进行修改.\n\n![image.png](image%209.png)\n\n然后在Main脚本激活时将weaponDefinitions中的参数保存到字典Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT中, 这样就可以通过GET_WEAPON_DEFINITION()方法, 在具体武器类想要获得具体武器参数是获得在Unity中写好的配置.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing Random = UnityEngine.Random;\n\n[RequireComponent(typeof(BoundsCheck))]\npublic class Main : MonoBehaviour {\n    static private Main S;\n    static private Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT;\n    public WeaponDefinition[] weaponDefinitions;\n    \n    void Awake() {\n        //单例模式\n        S = this;\n        bndCheck = GetComponent<BoundsCheck>();\n        Invoke(nameof(SpawnEnemy), 1f / enemySpawnPerSecond);\n        WEAP_DICT = new Dictionary<eWeaponType, WeaponDefinition>();\n        foreach (WeaponDefinition def in weaponDefinitions) { WEAP_DICT[def.type] = def; }\n    }\n\n    }\n    static public WeaponDefinition GET_WEAPON_DEFINITION(eWeaponType wt) {\n        if (WEAP_DICT.ContainsKey(wt)) return WEAP_DICT[wt];\n        return new WeaponDefinition();\n    }\n}\n\n```\n\n通过在具体武器类中保存武器类型定义类eWeaponType _type, 每次修改类型时, 武器对象通过Main.GET_WEAPON_DEFINITION(_type); 方法更新武器的定义, 从而加载不同的模型, 以及获取一些武器参数.\n\n```csharp\n// 武器类\npublic class Weapon : MonoBehaviour {\n    private eWeaponType _type = eWeaponType.none;  // 当前武器类型，默认无\n    public WeaponDefinition def;   // 武器定义\n    private GameObject weaponModel; // 武器模型\n\n    void Start() {\n        SetType(_type);  // 设置武器类型\n\n    }\n\n    // 武器类型的属性\n    public eWeaponType type {\n        get { return _type; }\n        set { SetType(value); }\n    }\n\n    // 设置武器类型\n    public void SetType(eWeaponType type) {\n        _type = type;\n\n        def = Main.GET_WEAPON_DEFINITION(_type);  // 获取武器的定义\n\n        // 如果已有武器模型，销毁它\n        if (weaponModel != null) Destroy(weaponModel);\n        // 实例化新的武器模型\n        weaponModel = Instantiate<GameObject>(def.weaponModelPrefab, transform);\n        weaponModel.transform.localPosition = Vector3.zero;\n        weaponModel.transform.localScale = Vector3.one;\n\n    }\n}\n```\n\n图示\n\n### Weapon对象载入\n\n```mermaid\nclassDiagram\n    class Weapon {\n        - eWeaponType _type\n        + SetType(eWeaponType type)\n    }\n    class Hero{\n      + Weapon[] weapons\n      + ClearWeapons()\n    }\n    class eWeaponType {\n        <<enumeration>>\n        none\n        blaster\n        spread\n    }\n    Weapon --> eWeaponType :依赖\n    Hero--> eWeaponType :依赖\n    Hero--> Weapon :管理\n    \n```\n\n武器的实际挂载对象是玩家飞船, 通过Hero脚本进行管理.\n\n在游戏场景的Hero游戏对象上, 有五个子游戏对象hardpoint, 每个绑定在玩家飞船的不同位置上, 然后在游戏对象hardpoint上有子游戏对象Weapon预制件实例, Weapon脚本作为Weapon预制件的组件, Hero脚本作为Hero游戏对象的组件. 在Hero脚本中有Weapon列表, 绑定这些Weapon预制件实例来进行管理.\n\n通过调用Weapon.SetType(eWeaponType), 就可以设置具体的Weapon预制件实例的类型.\n\nClearWeapons()方法可以将所有的Weapon预制件实例类型改为eWeaponType.none.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n    public Weapon[] weapons;\n\n    void Awake() {\n        if (S == null) {\n            S = this;\n        } else {\n            Debug.LogError(\"Hero.Awake() - Attempted to assign second Hero.S!\");\n        }\n        ClearWeapons();\n        weapons[0].SetType(eWeaponType.blaster);\n    }\n    public void ClearWeapons() {\n        foreach (Weapon w in weapons) {\n            w.SetType(eWeaponType.none);\n        }\n    }\n\n}\n\n```\n\n### Weapon开火\n\n```mermaid\nclassDiagram\n    class Weapon {\n        +WeaponDefinition def\n        +float nextShotTime\n        +Transform shotPointTrans\n        +Start()\n        +Fire()\n        +MakeProjectile()\n    }\n    \n    class ProjectileHero {\n        +Rigidbody rigid\n        +BoundsCheck boundsCheck\n        +Renderer rend\n        +eWeaponType type\n        +SetType(eWeaponType eType)\n        +Vector3 vel\n        +Awake()\n        +Update()\n    }\n\n    class WeaponDefinition {\n        +GameObject projectilePrefab\n        +float delayBetweenShots\n        +float velocity\n        +Color projectileColor\n    }\n\n    Weapon --> ProjectileHero : \"生成弹药实例\"\n    ProjectileHero --> WeaponDefinition : \"获取弹药定义\"\n    Weapon --> WeaponDefinition : \"根据武器类型获取参数\"\n    ProjectileHero --> Rigidbody : \"控制物理运动\"\n    ProjectileHero --> BoundsCheck : \"检测屏幕外销毁\"\n\n```\n\n对于每一个Weapon游戏对象实例, 由Weapon预制体的子对象ShotPoint提供射击点, 也就是弹药生成的位置.\n\nWeapon 脚本通过WeaponDefinition def上保存的武器定义, 来获取弹药的参数, 包括弹药预制体和弹药速度等.\n\nFire()方法作为Weapon的开火方法, 当被触发时, 根据保存的武器类型, 进行相对应的弹药生成方法. 例如blaster就生成一个弹药, spread就生成三个弹药. 弹药\n\n```csharp\n// 武器类\npublic class Weapon : MonoBehaviour {\n    public WeaponDefinition def;   // 武器定义\n    public float nextShotTime;     // 下一次射击的时间\n    private Transform shotPointTrans; // 射击点的Transform\n    \n  void Start() {\n        shotPointTrans = transform.GetChild(0);  // 获取子物体的Transform作为射击点\n    }\n    \n    // 触发射击\n    private void Fire() {\n        if (Time.time < nextShotTime) return;  // 如果还没到下一次射击时间，返回\n\n        ProjectileHero projectileHero;  // 投射物\n        Vector3 vel = Vector3.up * def.velocity;  // 投射物速度\n\n        // 根据武器类型发射不同的投射物\n        switch (type) {\n            case eWeaponType.blaster:  // 爆能枪\n                projectileHero = MakeProjectile();  // 创建投射物\n                projectileHero.vel = vel;  // 设置投射物速度\n                break;\n            case eWeaponType.spread:  // 散射武器\n                projectileHero = MakeProjectile();\n                projectileHero.vel = vel;\n\n                // 创建左侧散射投射物\n                projectileHero = MakeProjectile();\n                projectileHero.transform.rotation = Quaternion.AngleAxis(10, Vector3.back);\n                projectileHero.vel = projectileHero.transform.rotation * vel;\n\n                // 创建右侧散射投射物\n                projectileHero = MakeProjectile();\n                projectileHero.transform.rotation = Quaternion.AngleAxis(-10, Vector3.back);\n                projectileHero.vel = projectileHero.transform.rotation * vel;\n\n                break;\n        }\n    }\n\n    // 创建投射物实例\n    private ProjectileHero MakeProjectile() {\n        GameObject gameObject = Instantiate<GameObject>(def.projectilePrefab, PROJECTILE_ANCHOR);  // 实例化投射物\n        ProjectileHero projectileHero = gameObject.GetComponent<ProjectileHero>();  // 获取投射物组件\n\n        Vector3 pos = shotPointTrans.position;  // 获取射击点的位置\n        pos.z = 0;  // 设置Z轴为0\n        projectileHero.transform.position = pos;  // 设置投射物位置\n\n        projectileHero.type = type;  // 设置投射物类型\n        nextShotTime = Time.time + def.delayBetweenShots;  // 设置下一次射击的时间\n        return projectileHero;  // 返回投射物实例\n    }\n}\n\n```\n\n弹药ProjectileHero 实例由Weapon生成,\n\n由Weapon控制其速度, 由刚体组件控制其运动,\n\n由BoundsCheck组件提供是否飞出屏幕, 判断销毁,\n\n由Enemy判断碰撞逻辑销毁.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class ProjectileHero : MonoBehaviour {\n    private BoundsCheck boundsCheck;\n    private Renderer rend;\n    [Header(\"Dynamic\")]\n    public Rigidbody rigid;\n    private eWeaponType _type;\n    public eWeaponType type {\n        get { return _type; }\n        set { SetType(value); }\n    }\n    \n    public void SetType(eWeaponType eType) {\n        _type = eType;\n        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(_type);\n        rend.material.color = def.projectileColor;\n    }\n    public Vector3 vel {\n        get { return rigid.velocity; }\n        set { rigid.velocity = value; }\n    }\n\n    void Awake() {\n        boundsCheck = GetComponent<BoundsCheck>();\n        rend = GetComponent<Renderer>();\n        rigid = GetComponent<Rigidbody>();\n    }\n\n    void Update() {\n        if (boundsCheck.LocIs(BoundsCheck.eScreenLocs.offTop)) {\n            Destroy(gameObject);\n        }\n    }\n}\n\n```\n\n### Hero开火事件\n\n```mermaid\nclassDiagram\n    class Hero {\n        +delegate WeaponFireDelegate\n        +event WeaponFireDelegate fireEvent\n        +Update() \"检测开火输入\"\n    }\n    \n    class Weapon {\n        +Start()\n        +Fire()\"触发射击\"\n    }\n\n    Hero o-- Weapon : \"注册开火事件\"\n    Hero : +fireEvent()\n    Weapon --> Hero : \"fireEvent 事件触发\"\n\n```\n\nWeapon的开火事件由Hero控制触发.\n\n在Hero上保存有委托fireEvent, 每帧检测是否有开火控制型号, 然后触发fireEvent.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n\n    public delegate void WeaponFireDelegate();\n    public event WeaponFireDelegate fireEvent;\n\n    void Update() {\n        if (Input.GetAxis(\"Jump\") == 1 && fireEvent != null) {\n            fireEvent();\n        }\n    }\n\n}\n\n```\n\n在Weapon上注册事件, 将Weapon的Fire方法绑定到Hero的fireEvent上.\n\n这样当Hero触发开火时, 所有的Weapon都会开火.\n\n```csharp\n// 武器类\npublic class Weapon : MonoBehaviour {\n\n    void Start() {\n      // 如果该武器附加在玩家上，注册射击事件\n        Hero hero = GetComponentInParent<Hero>();\n        if (hero != null) hero.fireEvent += Fire;\n    }\n    \n    // 触发射击\n    private void Fire() {\n    \n    }\n\n}\n\n```\n\n## PowerUp\n\n升级道具由Enemy死亡掉落, 可以触发Weapon改变\n\n### PowerUp生成\n\n```mermaid\nclassDiagram\n    class Enemy {\n        +OnCollisionEnter(Collision coll)\n        +bool calledShipDestroyed\n    }\n    \n    class PowerUp {\n        +eWeaponType type\n        +SetType(eWeaponType wt)\n    }\n    \n    class Main {\n        +static Main S\n        +GameObject prefabPowerUp\n        +eWeaponType[] powerUpFrequency\n        +static void SHIP_DESTROYED(Enemy e)\n    }\n\n    Enemy --> Main : \"通知SHIP_DESTROYED\"\n    Main --> PowerUp : \"生成PowerUp\"\n    PowerUp : +SetType()\n\n```\n\nPowerUp有其类型, 对应武器类型.\n\n```csharp\npublic class PowerUp : MonoBehaviour {\n\n    [Header(\"Dynamic\")]\n    public eWeaponType _type;          // PowerUp 的类型\n    public float birthTime;     // PowerUp 实例化时的 Time.time\n\n    void Awake() {\n    \n        birthTime = Time.time; // 记录实例化时的时间\n    }\n\n    // PowerUp 类型的属性\n    public eWeaponType type { get { return _type; } set { SetType(value); } } // h\n\n    // 设置 PowerUp 类型\n    public void SetType(eWeaponType wt) {\n        // 从 Main 中获取武器定义\n        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(wt);\n        cubeMat.color = def.powerUpColor;  // 设置 PowerCube 的颜色\n        letter.text = def.letter;          // 设置显示的字母\n        _type = wt;                         // 最终设置类型\n    }\n\n}\n\n```\n\n为了使系统保持简洁, 也就是可以生成实例的类不要太多, 这里吧生成PowerUP的职责放在Main中.\n\n当Enemy被销毁时, 通知Main.  使用Main.SHIP_DESTROYED(this);\n\n```csharp\npublic class Enemy : MonoBehaviour {\n\n    void OnCollisionEnter(Collision coll) {\n        GameObject otherGO = coll.gameObject;\n        ProjectileHero projectileHero = otherGO.GetComponent<ProjectileHero>();\n        if (projectileHero != null) {\n            if (bndCheck.isOnScreen) {\n                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;\n                if (health < 0) {\n                    if (!calledShipDestroyed) {\n                        calledShipDestroyed = true;\n                        Main.SHIP_DESTROYED(this);\n                    }\n                    Destroy(gameObject);\n                }\n            }\n            Destroy(otherGO);\n        } else {\n            Debug.Log(\"Enemy hit by non-ProjectileHero: \" + otherGO.name);\n        }\n    }\n}\n\n```\n\nMain中保存有PowerUP预制体, 以及一个eWeaponType列表, 用来控制PowerUP生成类型的概率.\n\n当Main.SHIP_DESTROYED被触发时, 生成PowerUP并设定类型.\n\n```csharp\nusing Random = UnityEngine.Random;\n\npublic class Main : MonoBehaviour {\n    static private Main S;\n    \n    public GameObject prefabPowerUp;\n    public eWeaponType[] powerUpFrequency = new eWeaponType[]{\n        eWeaponType.blaster,\n        eWeaponType.blaster,\n        eWeaponType.spread,\n        eWeaponType.shield,\n    };\n    \n    static public void SHIP_DESTROYED(Enemy e) {\n        // 有可能生成一个PowerUp\n        if (Random.value <= e.powerUpDropChance) {  // 有一定几率生成 PowerUp\n            // 从powerUpFrequency数组中选择一个PowerUp类型\n            eWeaponType pUpType = S.powerUpFrequency[Random.Range(0, S.powerUpFrequency.Length)];  // 选择 PowerUp 类型\n\n            // 生成一个PowerUp对象\n            GameObject go = Instantiate<GameObject>(S.prefabPowerUp);  // 实例化 PowerUp 对象\n            PowerUp pUp = go.GetComponent<PowerUp>();  // 获取 PowerUp 脚本组件\n            // 设置生成的PowerUp为选定的武器类型\n            pUp.SetType(pUpType);  // 设置 PowerUp 的类型\n\n            // 设置 PowerUp 的位置为被摧毁的飞船的位置\n            pUp.transform.position = e.transform.position;\n        }\n    }\n\n}\n\n```\n\n### PowerUp触发\n\n```mermaid\nclassDiagram\n    class Hero {\n        +void OnTriggerEnter(Collider other)\n        +void AbsorbPowerUp(PowerUp powerUp)\n    }\n    \n    class PowerUp {\n        +eWeaponType type\n        +void AbsorbedBy(GameObject go) \n    }\n\n    class Weapon {\n        +void SetType(eWeaponType type)\n    }\n\n    Hero --> PowerUp : \"碰撞检测\"\n    Hero --> Weapon : \"改变武器类型\"\n    PowerUp --> Hero : \"触发PowerUp效果\"\n    PowerUp : +type \"PowerUp类型\"\n\n```\n\n当PowerUP被Hero碰撞后, 被消化使用. 在Hero中判断powerUp.type, 根据具体类型产生不同效果, 同时销毁powerUp.\n\n若powerUp.type为一种武器, 触发weapon.SetType(powerUp.type), 到Weapon类型被改变.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n    private GameObject lastTriggerGo = null;\n\n    void OnTriggerEnter(Collider other) {\n        Transform rootT = other.gameObject.transform.root;\n        GameObject gameObject = rootT.gameObject;\n        if (gameObject == lastTriggerGo) return;\n        lastTriggerGo = gameObject;\n\n        Enemy enemy = gameObject.GetComponent<Enemy>();\n        PowerUp powerUp = gameObject.GetComponent<PowerUp>();\n\n        if (enemy != null) {\n            shieldLevel--;\n            Destroy(gameObject);\n        } else if (powerUp != null) {\n            AbsorbPowerUp(powerUp);\n        } else {\n            Debug.LogWarning(\"Shield trigger hit by non-Enemy: \" + gameObject.name);\n        }\n\n    }\n\n    public void AbsorbPowerUp(PowerUp powerUp) {\n        Debug.Log(\"Absorbed PowerUp: \" + powerUp.type);\n        switch (powerUp.type) {\n            case eWeaponType.shield:\n                shieldLevel++;\n                break;\n            default:\n                if (powerUp.type == weapons[0].type) {\n                    Weapon weapon = GetEmptyWeaponSlot();\n                    if (weapon != null) {\n                        weapon.SetType(powerUp.type);\n                    }\n                } else {\n                    ClearWeapons();\n                    weapons[0].SetType(powerUp.type);\n                }\n                break;\n        }\n        powerUp.AbsorbedBy(gameObject);\n    }\n\n}\n\n```\n\n当PowerUP被触发时, 销毁自己\n\n```csharp\npublic class PowerUp : MonoBehaviour {\n    public void AbsorbedBy(GameObject target) {\n        Destroy(this.gameObject);\n    }\n\n}\n\n```\n\n# 视觉效果\n\n## 飞船运动倾角\n\n### Hero中的应用\n\n移动时, 根据虚拟轴输入, 计算旋转角度\n\n![image.png](image%2010.png)\n\n![image.png](image%2011.png)\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n\n    [Header(\"Inscribed\")]\n    public float maxSpeed = 30;\n    public float rollMult = -45;\n    public float pitchMult = 30;\n\n    void Update() {\n        float hAxis = Input.GetAxis(\"Horizontal\");\n        float vAxis = Input.GetAxis(\"Vertical\");\n\n        transform.rotation = Quaternion.Euler(vAxis * pitchMult, hAxis * rollMult, 0);\n\n    }\n}\n\n```\n\n### Enemy_1中的应用\n\n移动时, 根据侧向偏移量, 计算旋转角度\n\n![image.png](image%2012.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_1 : Enemy {\n    [Header(\"Enemy_1 Inscribed Fields\")]\n    [Tooltip(\"# of seconds for a full sine wave\")]\n    public float waveFrequency = 2;\n    [Tooltip(\"Sine wave width in meters\")]\n    public float waveWidth = 6;\n    [Tooltip(\"Amount the ship will roll left and right with the sine wave\")]\n    public float waveRotY = 45;\n    private float x0;\n    private float birthTime;\n\n    void Start() {\n        x0 = pos.x;\n        birthTime = Time.time;\n    }\n\n    public override void Move() {\n        Vector3 tempPos = pos;\n        float age = Time.time - birthTime;\n        float theta = Mathf.PI * 2 * age / waveFrequency;\n        float sin = Mathf.Sin(theta);\n        tempPos.x = x0 + sin * waveWidth;\n        pos = tempPos;\n\n        Vector3 rot = new Vector3(0, sin * waveRotY, 0);\n        transform.rotation = Quaternion.Euler(rot);\n\n        base.Move();\n\n        // print(bndCheck.isOnScreen);\n    }\n}\n\n```\n\n### Enemy_2中的应用\n\n移动时, 根据AnimationCurve 曲线, 计算旋转角度\n\n![image.png](image%2013.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_2 : Enemy {\n    [Header(\"Enemy_2 Inscribed Field\")]\n    public float lifeTime = 10f;\n\n    [Tooltip(\"波幅控制\")]\n    public float sinEccentricity = 0.6f;\n    public AnimationCurve rotCurve;\n\n    [Header(\"Enemy_2 Private Fields\")]\n    [SerializeField] private float birthTime;\n    private Quaternion baseRotation;\n    [SerializeField] private Vector3 p0, p1;//插值控制点\n\n    void Start() {\n        p0 = Vector3.zero;\n        p0.x = -bndCheck.camWidth - bndCheck.radius;\n        p0.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);\n\n        p1 = Vector3.zero;\n        p1.x = bndCheck.camWidth + bndCheck.radius;\n        p1.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);\n\n        if (Random.value > 0.5f) {\n            p0.x *= -1;\n            p1.x *= -1;\n        }\n\n        birthTime = Time.time;\n\n        transform.position = p0;\n        transform.LookAt(p1, Vector3.back);\n        baseRotation = transform.rotation;\n    }\n\n    public override void Move() {\n        float u = (Time.time - birthTime) / birthTime;\n\n        if (u > 1) {\n            Destroy(gameObject);\n            return;\n        }\n\n        float shipRot = rotCurve.Evaluate(u) * 360;\n        transform.rotation = baseRotation * Quaternion.Euler(-shipRot, 0, 0);\n\n        u = u + sinEccentricity * Mathf.Sin(u * Mathf.PI * 2);\n\n        pos = (1 - u) * p0 + u * p1;\n\n    }\n}\n\n```\n\n## 平滑移动路径\n\n### 贝塞尔曲线\n\n```csharp\nusing System.Linq;\nusing UnityEngine;\n\npublic class Utils : MonoBehaviour {\n    /// <summary>\n    /// 递归计算任意数量控制点的 Bézier 曲线上的点\n    /// </summary>\n    /// <param name=\"t\">插值比例 [0..1]</param>\n    /// <param name=\"points\">控制点数组</param>\n    /// <returns>曲线上的插值点</returns>\n    static public Vector3 Bezier(float t, params Vector3[] points) {\n        // 当只有一个控制点时，返回该控制点\n        if (points.Length == 1) return points[0];\n\n        // 使用 LINQ 的 Select 和 Zip 进行插值计算\n        return Bezier(t, points.Take(points.Length - 1)\n                               .Zip(points.Skip(1), (p0, p1) => Vector3.LerpUnclamped(p0, p1, t))\n                               .ToArray());\n    }\n\n}\n\n```\n\n### Enemy_3中的应用\n\n![image.png](image%2014.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_3 : Enemy {            // Enemy_3 继承自 Enemy 类\n    [Header(\"Enemy_3 公共字段\")]\n    public float lifeTime = 5;            // 生命时长为5秒\n    public Vector2 midpointYRange = new Vector2(1.5f, 3);   // 中间点Y轴范围\n    [Tooltip(\"如果为true,则在Scene面板中绘制Bézier点和路径。\")]\n    public bool drawDebugInfo = true;     // 是否绘制调试信息\n\n    [Header(\"Enemy_3 私有字段\")]\n    [SerializeField]\n    private Vector3[] points;  // Bézier曲线的三个点\n    [SerializeField]\n    private float birthTime;   // 记录生成时间\n\n    // Start方法,因父类Enemy未使用,所以可以在此处使用\n    void Start() {\n        points = new Vector3[3];  // 初始化三个控制点\n\n        // 起始位置已经由 Main.SpawnEnemy() 设置\n        points[0] = pos;  // 第一个点是当前敌人的初始位置\n\n        // 设置x轴的最小和最大值,和Main.SpawnEnemy()方式一致\n        float xMin = -bndCheck.camWidth + bndCheck.radius;\n        float xMax = bndCheck.camWidth - bndCheck.radius;\n\n        // 随机选择屏幕下半部分的一个中间点\n        points[1] = Vector3.zero;  // 初始化第二个点\n        points[1].x = Random.Range(xMin, xMax);  // x轴随机范围\n        float midYMult = Random.Range(midpointYRange[0], midpointYRange[1]);  // 随机Y轴比例  // a\n        points[1].y = -bndCheck.camHeight * midYMult;  // 设置Y轴位置  // a\n\n        // 随机选择屏幕上方的一个最终点\n        points[2] = Vector3.zero;  // 初始化第三个点\n        points[2].y = pos.y;       // Y轴保持在初始位置上方\n        points[2].x = Random.Range(xMin, xMax);  // x轴随机范围\n\n        // 设置出生时间为当前时间\n        birthTime = Time.time;\n\n        // 如果需要绘制调试信息,则调用DrawDebug方法  // b\n        if (drawDebugInfo) DrawDebug();\n    }\n\n    public override void Move() {\n        // Bézier曲线基于u值,u的范围在0到1之间\n        float u = (Time.time - birthTime) / lifeTime;\n\n        if (u > 1) {\n            // 如果u超过1,表示该敌人生命周期已结束\n            Destroy(this.gameObject);  // 销毁游戏对象\n            return;\n        }\n\n        // 根据u值旋转对象  // c\n        transform.rotation = Quaternion.Euler(u * 180, 0, 0);\n\n        // 插值计算Bézier曲线上的三个点  // d\n        u = u - 0.1f * Mathf.Sin(u * Mathf.PI * 2);\n        pos = Utils.Bezier(u, points);\n\n        // Enemy_3 不调用父类的Move()\n    }\n\n    // 绘制调试信息,包括Bézier曲线和控制点  // e\n    void DrawDebug() {\n        // 绘制三个控制点之间的直线\n        Debug.DrawLine(points[0], points[1], Color.cyan, lifeTime);  // 绘制第1到第2个点的线  // f\n        Debug.DrawLine(points[1], points[2], Color.yellow, lifeTime); // 绘制第2到第3个点的线\n\n        // 绘制Bézier曲线\n        float numSections = 20;  // 曲线分为20段\n        Vector3 prevPoint = points[0];  // 上一个点,初始化为第一个控制点  // g\n        Color col;\n        Vector3 pt;\n        for (int i = 1; i < numSections; i++) {  // 绘制Bézier曲线的各段  // h\n            float u = i / numSections;  // u的值在0到1之间变化\n            pt = Utils.Bezier(u, points);  // 计算当前插值点\n            col = Color.Lerp(Color.cyan, Color.yellow, u);  // 根据u值插值颜色\n            Debug.DrawLine(prevPoint, pt, col, lifeTime);  // 绘制前一个点到当前点的线  // i\n            prevPoint = pt;  // 更新上一个点为当前点\n        }\n    }\n}\n\n```\n\n## 敌人受击反馈\n\n新建受击组件\n\n保存所有子对象材质\n\n检测碰撞, 当被子弹命中时改变材质, 产生效果.\n\n效果根据时间消失.\n\n![image.png](image%2015.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\n[DisallowMultipleComponent]  // 不允许在同一个GameObject上添加多个该组件  // a\npublic class BlinkColorOnHit : MonoBehaviour {\n    private static float blinkDuration = 0.1f;  // 闪烁颜色的持续时间（以秒为单位）  // b\n    private static Color blinkColor = Color.red;  // 受击时显示的颜色\n\n    [Header(\"动态参数\")]  // 在Inspector面板中分类显示动态参数\n    public bool showingColor = false;  // 是否正在显示闪烁颜色\n    public float blinkCompleteTime;    // 恢复原始颜色的时间\n    public bool ignoreOnCollisionEnter = false;\n\n    private Material[] materials;      // 当前GameObject及其子对象的所有材质\n    private Color[] originalColors;    // 材质的原始颜色数组\n    private BoundsCheck bndCheck;      // 用于检测对象是否在屏幕范围内的组件\n\n    void Awake() {\n        bndCheck = GetComponentInParent<BoundsCheck>();  // 获取父对象上的BoundsCheck组件  // c\n        // 获取该GameObject及其所有子对象的材质\n        materials = Utils.GetAllMaterials(gameObject);    // d\n        // 存储每个材质的原始颜色\n        originalColors = materials.Select(m => m.color).ToArray();\n    }\n\n    void Update() {\n        // 如果正在显示闪烁颜色且当前时间超过了恢复颜色的时间，恢复原始颜色\n        if (showingColor && Time.time > blinkCompleteTime) RevertColors();  // e\n    }\n\n    void OnCollisionEnter(Collision coll) {\n        if (ignoreOnCollisionEnter) return;\n        // 如果有BoundsCheck且对象不在屏幕内，跳过受击显示\n        if (bndCheck != null && !bndCheck.isOnScreen) {  // g\n            return;  // 当对象不在屏幕内时，不显示受击效果\n        }\n        // 检测与ProjectileHero的碰撞\n        ProjectileHero p = coll.gameObject.GetComponent<ProjectileHero>();\n        if (p != null) {  // 如果碰撞对象是ProjectileHero  // f\n\n            SetColors();  // 显示受击颜色\n        }\n    }\n\n    /// <summary>\n    /// 将所有材质的主颜色设置为闪烁颜色，并设置显示颜色的时间\n    /// </summary>\n    public void SetColors() {\n        foreach (Material m in materials) {\n            m.color = blinkColor;  // 将材质颜色设置为闪烁颜色\n        }\n        showingColor = true;  // 标记正在显示颜色\n        blinkCompleteTime = Time.time + blinkDuration;  // 设置颜色恢复的时间\n    }\n\n    /// <summary>\n    /// 恢复所有材质的原始颜色，并停止显示颜色\n    /// </summary>\n    public void RevertColors() {\n        for (int i = 0; i < materials.Length; i++) {\n            materials[i].color = originalColors[i];  // 恢复原始颜色\n        }\n        showingColor = false;  // 标记颜色显示结束\n    }\n}\n\n```\n\n## 无缝太空背景\n\n滚动数组思想.\n\n使用两块背景, 循环播放, 当一张移出屏幕后, 接替到另一张上面.\n\n![image.png](image%2016.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Parallax : MonoBehaviour {\n    [Header(\"Inscribed\")]\n    public Transform playerTrans; // The player ship (玩家飞船)\n    public Transform[] panels; // The scrolling foregrounds (滚动的前景面板)\n    [Tooltip(\"Speed at which the panels move in Y\")]\n    public float scrollSpeed = -30f; // 面板在Y轴上的滚动速度\n    [Tooltip(\"Controls how much panels react to player movement (Default 0.25)\")]\n    public float motionMult = 0.25f; // 控制面板对玩家移动的反应程度 (默认值 0.25)   // a\n\n    private float panelHt; // Height of each panel (每个面板的高度)\n    private float depth;   // Depth of panels (that is, pos.z) (面板的深度，即z轴位置)\n\n    void Start() {\n        panelHt = panels[0].localScale.y; // 获取第一个面板的高度\n        depth = panels[0].position.z; // 获取面板的深度（z轴位置）\n\n        // Set initial positions of panels (设置面板的初始位置)\n        panels[0].position = new Vector3(0, 0, depth); // 第一个面板位于起点\n        panels[1].position = new Vector3(0, panelHt, depth); // 第二个面板位于第一个面板上方\n    }\n\n    void Update() {\n        float tY, tX = 0; // 定义用于计算面板位置的变量\n        tY = Time.time * scrollSpeed % panelHt + (panelHt * 0.5f); // 随时间滚动并保证循环衔接   // b\n\n        if (playerTrans != null) {\n            tX = -playerTrans.transform.position.x * motionMult; // 根据玩家的x位置调整tX   // c\n                                                                 // tY += -poi.transform.position.y * motionMult; // 如果需要，也可以对Y轴进行调整\n        }\n\n        // Position panels[0] (设置第一个面板的位置)\n        panels[0].position = new Vector3(tX, tY, depth);\n        // Position panels[1] where needed to make a continuous starfield (根据需要设置第二个面板的位置，以实现连续的星空效果)  // d\n        if (tY >= 0) {\n            panels[1].position = new Vector3(tX, tY - panelHt, depth); // 第二个面板在第一个面板的上方\n        } else {\n            panels[1].position = new Vector3(tX, tY + panelHt, depth); // 第二个面板在第一个面板的下方\n        }\n    }\n}\n\n```\n\n# 扩展实践\n\n## Missile\n\n创建一种新的武器-导弹. 可以在发射后自动跟踪敌人.\n\n### 创建新的武器配置\n\n在Main.cs→WeaponDefinitions中创建Missile\n\n![image.png](image%2017.png)\n\n在Main.cs→PowerUPfrequency中创建Missile\n\n![image.png](image%2018.png)\n\n此时运行游戏\n\n敌人可掉落M道具\n\n![image.png](image%2019.png)\n\n拾取后也可正常装备\n\n![image.png](image%2020.png)\n\n但此时还没有发射功能\n\n### 添加发射功能\n\n修改Weapon类, 在射击方法中添加处理导弹类型的代码\n\n```csharp\n\n// 武器类\npublic class Weapon : MonoBehaviour {\n    // 触发射击\n    private void Fire() {\n        // 根据武器类型发射不同的投射物\n        switch (type) {\n            // 导弹类型\n            case eWeaponType.missile:\n                projectileHero = MakeProjectile();\n                projectileHero.vel = vel;\n                break;\n        }\n    }\n\n}\n\n```\n\n此时可以发生导弹类型的弹药, 由上一步配置为红色.\n\n![image.png](image%2021.png)\n\n### 实现目标检测\n\n实现思路\n\n给ProjectileHero创建一个球形碰撞箱来检测敌人\n\n通过向量差值获得指向敌人的向量来修改导弹的速度使其朝向敌人\n\nProjectileHero已经自身持有一个碰撞箱用来检测是否与敌人碰撞, 所以我们给Missile类型的ProjectileHero创建一个子对象detectionRange, 再在这个子对象detectionRange上添加SphereCollider.\n\n在ProjectileHero上新增代码\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class ProjectileHero : MonoBehaviour {\n\n    private Transform detectionRangeTrans;\n\n    public void SetType(eWeaponType eType) {\n    \n        // 如果类型是导弹类型，添加检测范围\n        if (_type == eWeaponType.missile) {\n            AddDetectionRange();\n        }\n    }\n\n    // 添加用于检测目标的球形碰撞体\n    private void AddDetectionRange() {\n        // 创建子对象\n        GameObject detectionRange = new GameObject(\"DetectionRange\");\n        detectionRangeTrans = detectionRange.transform;\n        // 设置为ProjectileHero的子对象\n        detectionRangeTrans.SetParent(this.transform);\n        // 确保位置和ProjectileHero一致\n        detectionRangeTrans.localPosition = Vector3.zero;\n        // 设置与ProjectileHero相同的Layer\n        detectionRangeTrans.gameObject.layer = gameObject.layer;\n        // 添加球形碰撞箱\n        SphereCollider sphereCollider = detectionRange.AddComponent<SphereCollider>();\n        sphereCollider.isTrigger = true; // 设置为触发器\n        // 设置碰撞体的半径，决定探测范围\n        sphereCollider.radius = 10f; // 可以根据需要调整半径的大小\n    }\n}\n\n```\n\n实现效果, 可见碰撞箱半径\n\n![image.png](image%2022.png)\n\n### 实现目标追踪\n\n为刚才创建的对象添加一个脚本, 专门用来处理追踪逻辑\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class ProjectileHero : MonoBehaviour {\n    // 添加用于检测目标的球形碰撞体\n    private void AddDetectionRange() {\n        // 添加一个额外的脚本，用于处理目标检测逻辑\n        detectionRange.AddComponent<MissileTargetDetector>();\n    }\n}\n\n```\n\n保存变量projectileHero, 用于修改其运动\n\n保存变量enemy 用于确认目标\n\n在OnTriggerEnter中设定目标\n\n在OnTriggerExit中放弃目标\n\n在Update使用线性插值修改速度方向追踪目标\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MissileTargetDetector : MonoBehaviour {\n    ProjectileHero projectileHero;\n    Enemy enemy = null;\n\n    void Awake() {\n        projectileHero = gameObject.GetComponentInParent<ProjectileHero>();\n    }\n\n    void Update() {\n        // 若目标存在且存活, 修正速度方向, 实现追踪功能\n        if (enemy != null && enemy.gameObject != null) {\n            Vector3 origin = projectileHero.rigid.velocity;\n            Vector3 direction = (enemy.transform.position - transform.position).normalized * origin.magnitude;\n            projectileHero.rigid.velocity = Vector3.Lerp(origin, direction, 0.2f);\n        } else {\n            enemy = null;\n        }\n    }\n\n    void OnTriggerEnter(Collider other) {\n        // Debug.LogWarning(\"Missile trigger Enter: \" + other.name);\n        // 若敌人进入范围, 且当前无其他目标, 将该敌人设定为目标\n        Enemy detectedEnemy = other.gameObject.GetComponent<Enemy>();\n        if (enemy == null && detectedEnemy != null) {\n            enemy = detectedEnemy;\n        }\n    }\n\n    void OnTriggerExit(Collider other) {\n        // Debug.LogWarning(\"Missile trigger Exit: \" + other.name);\n        // 若目标存在且脱离追踪范围, 放弃这个目标\n        if (enemy != null && other.gameObject == enemy.gameObject) {\n            enemy = null;\n        }\n    }\n}\n\n```\n\n实现效果, 当导弹靠近目标之后, 会指向目标\n\n![image.png](image%2023.png)\n\n发现Bug1, 当导弹跟踪的目标丢失以后会失去速度滞留在地图上\n\n![image.png](image%2024.png)\n\n修复: 使用线性插值直接修改速度会改变速度大小, 下文优化追踪方案\n\n发现Bug2, 导弹对Enemy_1没有追踪作用\n\n修复: Enemy_1没有碰撞箱, 添加碰撞箱后功能恢复\n\n![image.png](image%2025.png)\n\n### 优化目标追踪\n\n将原本的线性插值改变速度方向, 改为旋转导弹的方向, 更加平滑, 视觉表现也更好.\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MissileTargetDetector : MonoBehaviour {\n    public float rotationSpeed = 4.0f;  // 控制旋转速度\n    void Update() {\n        // 若目标存在且存活, 修正速度方向, 实现追踪功能\n        if (enemy != null && enemy.gameObject != null) {\n            // 计算导弹当前朝向与目标之间的旋转\n            Vector3 targetDirection = (enemy.transform.position - projectileHero.transform.position).normalized;\n            Quaternion targetRotation = Quaternion.LookRotation(Vector3.forward, targetDirection);\n            // 平滑地插值旋转到目标方向\n            projectileHero.transform.rotation = Quaternion.Slerp(\n                projectileHero.transform.rotation,\n                targetRotation,\n                Time.deltaTime * rotationSpeed\n            );\n            // 根据当前朝向更新导弹的速度\n            projectileHero.vel = projectileHero.transform.up * projectileHero.speed;\n        } else {\n            enemy = null;\n        }\n    }\n}\n\n```\n\n同时在ProjectileHero保存速度的大小, 修复了导弹静止的问题.\n\n```csharp\n\npublic class ProjectileHero : MonoBehaviour {\n    public float speed;\n    public void SetType(eWeaponType eType) {\n        speed = def.velocity;\n    }\n}\n\n```\n\n![image.png](image%2026.png)\n","source":"_posts/2024/10/Space SHMUP 拆解和拓展.md","raw":"---\ntitle: Space SHMUP 拆解和拓展\nmathjax: true\ndate: 2024-11-19 19:56:54\ntags:\n--- \n\n# 游戏内容分析\n\nSHMUP （Shoot 'em up），又称STG，即清版射击游戏, 是一种游戏类型，通常以玩家控制飞行器或角色为基础，目标是消灭敌人并躲避子弹和障碍物。SHMUP游戏通常具有快节奏的动作、丰富的视觉效果和多样化的武器系统。\n\n\n![image.png](image.png)\n\n本项目来自***Introduction to Game Design, Prototyping, and Development*** 的 Space SHMUP. 含有五种敌人角色和两种武器类型, 玩家需要操纵飞船躲避敌人, 攻击敌人, 当击败敌人时可以获得加成道具.\n\n## 玩家角色\n\n![image.png](image%201.png)\n<!--more-->\n### 玩家飞船的意义\n\n1. 当游戏开始时出现在地图中\n2. 当玩家飞船被消灭后游戏结束\n\n### 玩家飞船的能力\n\n1. 在地图上移动\n2. 控制武器开火\n\n### 玩家飞船与其他对象的交互\n\n1. 碰撞到敌人, 导致自生护盾减少, 当自身无护盾时被消灭\n2. 碰撞到加成道具, 导致武器系统发生变化\n\n## 敌人角色\n\n![image.png](image%202.png)\n\n敌人包括五种\n\n### 敌人飞船的意义\n\n1. 根据游戏时间进行, 敌人飞船会随机在地图中生成, 给玩家飞船的生存带来负面影响\n\n    [待扩展]将敌人生成预设为波次进攻模式, 根据关卡难度控制生成情况\n\n### 敌人飞船的能力\n\n1. 在地图中移动, 不同的飞船有各自不同的移动能力\n    1. Enemy_0从地图上侧随机处生成, 向地图最下端直线移动, 从下侧离开地图\n    2. Enemy_1从地图上侧随机处生成, 向地图最下端移动的同时左右摇摆, 从下侧离开地图\n    3. Enemy_2从地图左右侧随机生成, 横向进入地图, 来回穿越一回合后从另一侧离开地图\n    4. Enemy_3从地图上侧随机处生成, 纵向进入地图, 抵达路径最低处后从上侧离开地图\n    5. Enemy_4从地图上侧随机处生成, 每隔一段时间, 在地图的四个象限没移动, 不会离开地图\n2. 掉落武器系统加成道具\n3. [可扩展]获得武器并控制武器开火\n\n### 敌人飞船与其他对象的交互\n\n1. 承受玩家武器的攻击(碰撞到子弹), 减少生命值, 当生命值归零时, 自身销毁.\n    1. Enemy_4持有护盾, 当收到攻击时, 优先消耗护盾的生命值\n2. 碰撞到玩家飞船, 导致自身销毁.\n\n## 武器系统\n\n![image.png](image%203.png)\n\n玩家护盾虽与暂时玩家飞船绑定, 但可改造为武器系统的一部分\n\n### 武器系统的意义\n\n1. 为玩家飞船提供清理敌人飞船的能力, 使得玩家飞船在游戏中生存下来\n2. 含有5个武器挂载点位, 为玩家提供了武器的选择和升级空间, 使游戏更加有趣\n\n### 武器系统的能力\n\n1. 当玩家控制开火时, 武器可以以不同形式发射弹药, 而弹药可以攻击并消灭敌人\n    1. Blaster 每次开火向正前方发射一枚子弹, 子弹会向前移动直到地图边缘, 发射间隔较短\n    2. Spread 每次开火向前方扇形排布发射多枚子弹, , 子弹会向前移动直到地图边缘, 发射间隔较长\n    3. [待扩展]Missile 每次开火发射一枚导弹, 导弹可以自动跟踪敌人\n\n### 武器系统与其他对象的交互\n\n1. 武器本身不与敌人交互, 而是通过弹药来与敌人交互, 武器的职责是是生成弹药, 当弹药接触到敌人时, 给敌人造成伤害\n2. 武器系统会根据玩家接触到的加成道具进行改变\n    1. 玩家最多持有五个武器\n    2. 当玩家获得的加成和已持有的武器类型一致时, 武器系统得到强化\n    3. 当玩家获得的加成和已持有武器类型不一致时, 将玩家的武器替换为所加成的武器, 此时武器系统可能强化或弱化\n\n## 加成道具\n\n![image.png](image%204.png)\n\n### 加成道具的意义\n\n1. 加成道具可以为玩家提供武器系统的加成选项\n2. 加成道具可以让玩家提供一个选择, 是否需要穿越危险的交战区, 去获得加成道具, 使得游戏局面变得复杂有趣\n\n### 加成道具的能力\n\n1. 不同的加成道具可以给玩家提供不同的升级\n    1. Shield 增强玩家的护盾\n    2. Spread 给玩家添加Spread 武器\n    3. Blaster 给玩家添加Blaster 武器\n    4. [可扩展] 同步武器系统的武器类型, 提供加成\n    5. [可扩展] 对游戏局势产生重大效果, 如对所有敌人造成伤害\n\n### 加成道具与其他对象的交互\n\n1. 与玩家飞船碰撞, 导致自身被消耗, 对玩家飞船造成相应影响\n2. 当敌人被消灭时, 根据概率设定, 生成不同的加成道具\n3. [可扩展]与敌人飞船碰撞, 导致自身被销毁\n4. [可扩展]与敌人飞船碰撞, 对敌人飞船产生影响\n\n# 系统分析与实现\n\n## BoundsCheck\n\n一个通用组件, 用于判断游戏对象是否在屏幕中, 获取相对屏幕的位置.\n\n可以用来管理游戏对象, 包括玩家\\敌人\\子弹的移动范围限制和移出屏幕后销毁.\n\n使用了复合枚举来保存位置信息.\n\n为每一个游戏对象添加BoundsCheck 组件, 通过调用boundsCheck.isOnScreen()或boundsCheck.LocIs来获取信息.\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\npublic class BoundsCheck : MonoBehaviour {\n    [System.Flags]\n    public enum eScreenLocs {\n        onScreen = 0,\n        offRight = 1,\n        offLeft = 2,\n        offTop = 4,\n        offBottom = 8,\n    }\n    public enum eType { center, inset, outset }\n    [Header(\"Inscribed\")]\n    public eType boundsType = eType.center;\n    public float radius = 1f;\n    public bool keepOnScreen = true;\n\n    [Header(\"Dynamic\")]\n    public eScreenLocs screenLocs = eScreenLocs.onScreen;\n    public float camWidth;\n    public float camHeight;\n\n    void LateUpdate() {\n        //更新screenLocs \n    }\n    public bool isOnScreen {\n        get { return screenLocs == eScreenLocs.onScreen; }\n    }\n    public bool LocIs(eScreenLocs checkLoc) {\n        if (checkLoc == eScreenLocs.onScreen) {\n            return isOnScreen;\n        }\n        return (screenLocs & checkLoc) == checkLoc;\n    }\n}\n\n```\n\n## Enemy\n\n```mermaid\nclassDiagram\n    class Main {\n        - static Main S\n        - GameObject[] prefabEnemies\n        - float enemySpawnPerSecond\n        + Awake()\n        + SpawnEnemy()\n    }\n\n    class Enemy {\n        <<abstract>>\n        + float speed\n        + float health\n        + Vector3 pos\n        + Move()\n        + OnCollisionEnter(Collision coll)\n    }\n\n    class Enemy_1 {\n        + float waveFrequency\n        + float waveWidth\n        - float x0\n        - float birthTime\n        + Move()\n    }\n\n    class ProjectileHero {\n        + float damageOnHit\n    }\n\n    Main --> Enemy : \"生成\"\n    Main --> prefabEnemies : \"管理预制件\"\n    Enemy_1 --> Enemy : \"继承\"\n    Enemy --> ProjectileHero : \"检测碰撞\"\n\n```\n\n### Enemy生成\n\nEnemy的生成为全局管理, 由游戏唯一Main对象管理, Main为单例, 且保存所有Enemy的预制件.\n\n当Main对象被创建后, 每隔一段时间调用SpawnEnemy()方法, 由SpawnEnemy()生成一个Enemy, 在SpawnEnemy中选取要生成的具体Enemy可以要生成的具体坐标, 然后通过Invoke延时递归调用自身.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing Random = UnityEngine.Random;\n\npublic class Main : MonoBehaviour\n{\n    static private Main S;\n    public GameObject[] prefabEnemies;\n    public float enemySpawnPerSecond = 0.5f;\n\n    void Awake()\n    {\n        S = this;\n        Invoke(nameof(SpawnEnemy), 1f / enemySpawnPerSecond);\n    }\n\n    public void SpawnEnemy()\n    {\n        // 随机选取一个要生成的Enemy\n        int ndx = Random.Range(0, prefabEnemies.Length);\n        GameObject newEnemy = Instantiate<GameObject>(prefabEnemies[ndx]);\n        // 获取Enemy要生成的坐标\n        Vector3 pos = Vector3.zero;\n        newEnemy.transform.position = pos;\n        // 根据配置生成下一个Enemy\n        Invoke(nameof(SpawnEnemy), 1f / enemySpawnPerSecond);\n    }\n}\n```\n\n![image.png](image%205.png)\n\n### Enemy基类和扩展类\n\nEnemy预制件附带有对应的Enemy脚本, 控制对应Enemy的行为.\n\n![image.png](image%206.png)\n\n每一种Enemy的通用属性, 如移动速度, 血量, 可以定义在基类中\n\n![image.png](image%207.png)\n\n每一种Enemy的移动方式不同, 可以再基类中实现基本移动功能, 在具体类中实现扩展功能.\n\nEnemy基类, 实现基本向下移动\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class Enemy : MonoBehaviour {\n    [Header(\"Inscribed\")]\n    public float speed = 10f;\n    public float fireRate = 0.3f;\n    public float health = 10;\n    public int score = 100;\n    public Vector3 pos {\n        get {\n            return transform.position;\n        }\n        set {\n            transform.position = value;\n        }\n    }\n    void Update() {\n        Move();\n    }\n\n    public virtual void Move() {\n        Vector3 tempPos = pos;\n        tempPos.y -= speed * Time.deltaTime;\n        pos = tempPos;\n    }\n}\n\n```\n\n例如: Enemy_1子类, 重写Move方法, 实现带有摆动的移动.\n\n通过Sin函数和存货时间计算摆动横向偏移量, 而基础的向下移动功能, 又由Enemy基类完成.\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_1 : Enemy {\n    [Header(\"Enemy_1 Inscribed Fields\")]\n    [Tooltip(\"# of seconds for a full sine wave\")]\n    public float waveFrequency = 2;\n    [Tooltip(\"Sine wave width in meters\")]\n    public float waveWidth = 6;\n    private float x0;\n    private float birthTime;\n\n    void Start() {\n        x0 = pos.x;\n        birthTime = Time.time;\n    }\n\n    public override void Move() {\n        Vector3 tempPos = pos;\n        float age = Time.time - birthTime;\n        float theta = Mathf.PI * 2 * age / waveFrequency;\n        float sin = Mathf.Sin(theta);\n        tempPos.x = x0 + sin * waveWidth;\n        pos = tempPos;\n        \n        base.Move();\n    }\n}\n\n```\n\n### Enemy受击处理\n\nEnemy可以和弹药类ProjectileHero进行碰撞, 通过Layer设置是否可以碰撞, 然后在OnCollisionEnter中处理具体碰撞逻辑.\n\n弹药由武器生成, 弹药有伤害数值, 下文另谈.\n\n弹药游戏对象持有ProjectileHero组件, 可用来判断Enemy碰撞到的是否是弹药.\n\n当Enemy碰撞到弹药后, 销毁弹药. 同时扣除自身血量, 血量耗尽后销毁Enemy.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class Enemy : MonoBehaviour {\n\n    public float health = 10;\n    \n    void OnCollisionEnter(Collision coll) {\n        GameObject otherGO = coll.gameObject;\n        ProjectileHero projectileHero = otherGO.GetComponent<ProjectileHero>();\n        if (projectileHero != null) {\n            if (bndCheck.isOnScreen) {\n                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;\n                if (health < 0) {\n                    if (!calledShipDestroyed) {\n                        calledShipDestroyed = true;\n                        Main.SHIP_DESTROYED(this);\n                    }\n                    Destroy(gameObject);\n                }\n            }\n            Destroy(otherGO);\n        } else {\n            Debug.Log(\"Enemy hit by non-ProjectileHero: \" + otherGO.name);\n        }\n    }\n}\n\n```\n\n## Hero\n\n### Hero生成\n\n玩家飞船也为全局唯一对象, 使用单例模式, 使用Hero脚本控制行为.\n\n因为不会重复生成, 所以游戏开始时直接布置在场景Scene中.\n\n![image.png](image%208.png)\n\n### 玩家移动控制\n\n有参数最大速度. 根据帧间时间计算移动后所处位置, 直接改变.\n\n每帧读取移动虚拟轴输入, 实现平滑移动.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n\n    [Header(\"Inscribed\")]\n    public float maxSpeed = 30;\n\n    void Awake() {\n        if (S == null) {\n            S = this;\n        } else {\n            Debug.LogError(\"Hero.Awake() - Attempted to assign second Hero.S!\");\n        }\n    }\n\n    void Update() {\n        float hAxis = Input.GetAxis(\"Horizontal\");\n        float vAxis = Input.GetAxis(\"Vertical\");\n\n        Vector3 pos = transform.position;\n        pos.x += hAxis * maxSpeed * Time.deltaTime;\n        pos.y += vAxis * maxSpeed * Time.deltaTime;\n        transform.position = pos;\n\n    }\n}\n\n```\n\n### 玩家开火控制\n\n每帧读取开火虚拟轴输入, 触发开火事件. 具体开火实现见武器系统.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    public delegate void WeaponFireDelegate();\n    public event WeaponFireDelegate fireEvent;\n\n    void Update() {\n      if (Input.GetAxis(\"Jump\") == 1 && fireEvent != null) {\n            fireEven();\n        }\n    }\n\n}\n\n```\n\n## Weapon\n\n### Weapon配置管理和切换\n\n```mermaid\nclassDiagram\n    class Main {\n        - Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT\n        + WeaponDefinition[] weaponDefinitions\n        + WeaponDefinition GET_WEAPON_DEFINITION(eWeaponType wt)\n        + Awake()\n    }\n    \n    class Weapon {\n        - eWeaponType _type\n        - WeaponDefinition def\n        - float nextShotTime\n        - GameObject weaponModel\n        + SetType(eWeaponType type)\n    }\n\n    class WeaponDefinition {\n        + eWeaponType type\n        + GameObject weaponModelPrefab\n        + GameObject projectilePrefab\n        + float delayBetweenShots\n        + float velocity\n    }\n\n    class eWeaponType {\n        <<enumeration>>\n        none\n        blaster\n        spread\n    }\n\n    Main --> WeaponDefinition : \"管理\"\n    Weapon --> WeaponDefinition : \"获取和应用\"\n    Main --> eWeaponType : \"依赖\"\n    Weapon --> eWeaponType : \"依赖\"\n    WeaponDefinition --> eWeaponType : \"定义\"\n  WeaponDefinition --> weaponModelPrefab: \"管理预制件\"\n  WeaponDefinition --> projectilePrefab: \"管理预制件\"\n```\n\n在本系统中, 武器被实现为一个可以通过类型枚举来配置武器行为的对象. 武器对象是一直存在的, 会根据类型的切换改变表现的形态.\n\n武器的具体参数又保存在具体的武器定义类中. 不仅仅是数值参数, 还有模型预制体参数和子弹预制体参数.\n\n```csharp\n// 武器类型的枚举\npublic enum eWeaponType {\n    none,       // 无\n    blaster,    // 爆能枪\n    spread,     // 散射枪\n}\n\n// 武器定义类，描述每种武器的属性\n[System.Serializable]\npublic class WeaponDefinition {\n    public eWeaponType type = eWeaponType.none;  // 武器类型，默认无\n    [Tooltip(\"附加到玩家飞船上的武器模型预制件\")]  // 提示：武器模型的预制件\n    public GameObject weaponModelPrefab;\n    [Tooltip(\"发射的投射物预制件\")]  // 提示：发射的投射物的预制件\n    public GameObject projectilePrefab;\n    [Tooltip(\"每次射击之间的延迟秒数\")]  // 提示：射击间隔时间\n    public float delayBetweenShots = 0;\n    [Tooltip(\"单个投射物的速度\")]  // 提示：投射物速度\n    public float velocity = 50;\n}\n```\n\n所有的武器定义类被保存在Main对象中, 便于统一修改.\n\n使用一个列表weaponDefinitions来保存所有的武器定义类, 在Unity中进行修改.\n\n![image.png](image%209.png)\n\n然后在Main脚本激活时将weaponDefinitions中的参数保存到字典Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT中, 这样就可以通过GET_WEAPON_DEFINITION()方法, 在具体武器类想要获得具体武器参数是获得在Unity中写好的配置.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing Random = UnityEngine.Random;\n\n[RequireComponent(typeof(BoundsCheck))]\npublic class Main : MonoBehaviour {\n    static private Main S;\n    static private Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT;\n    public WeaponDefinition[] weaponDefinitions;\n    \n    void Awake() {\n        //单例模式\n        S = this;\n        bndCheck = GetComponent<BoundsCheck>();\n        Invoke(nameof(SpawnEnemy), 1f / enemySpawnPerSecond);\n        WEAP_DICT = new Dictionary<eWeaponType, WeaponDefinition>();\n        foreach (WeaponDefinition def in weaponDefinitions) { WEAP_DICT[def.type] = def; }\n    }\n\n    }\n    static public WeaponDefinition GET_WEAPON_DEFINITION(eWeaponType wt) {\n        if (WEAP_DICT.ContainsKey(wt)) return WEAP_DICT[wt];\n        return new WeaponDefinition();\n    }\n}\n\n```\n\n通过在具体武器类中保存武器类型定义类eWeaponType _type, 每次修改类型时, 武器对象通过Main.GET_WEAPON_DEFINITION(_type); 方法更新武器的定义, 从而加载不同的模型, 以及获取一些武器参数.\n\n```csharp\n// 武器类\npublic class Weapon : MonoBehaviour {\n    private eWeaponType _type = eWeaponType.none;  // 当前武器类型，默认无\n    public WeaponDefinition def;   // 武器定义\n    private GameObject weaponModel; // 武器模型\n\n    void Start() {\n        SetType(_type);  // 设置武器类型\n\n    }\n\n    // 武器类型的属性\n    public eWeaponType type {\n        get { return _type; }\n        set { SetType(value); }\n    }\n\n    // 设置武器类型\n    public void SetType(eWeaponType type) {\n        _type = type;\n\n        def = Main.GET_WEAPON_DEFINITION(_type);  // 获取武器的定义\n\n        // 如果已有武器模型，销毁它\n        if (weaponModel != null) Destroy(weaponModel);\n        // 实例化新的武器模型\n        weaponModel = Instantiate<GameObject>(def.weaponModelPrefab, transform);\n        weaponModel.transform.localPosition = Vector3.zero;\n        weaponModel.transform.localScale = Vector3.one;\n\n    }\n}\n```\n\n图示\n\n### Weapon对象载入\n\n```mermaid\nclassDiagram\n    class Weapon {\n        - eWeaponType _type\n        + SetType(eWeaponType type)\n    }\n    class Hero{\n      + Weapon[] weapons\n      + ClearWeapons()\n    }\n    class eWeaponType {\n        <<enumeration>>\n        none\n        blaster\n        spread\n    }\n    Weapon --> eWeaponType :依赖\n    Hero--> eWeaponType :依赖\n    Hero--> Weapon :管理\n    \n```\n\n武器的实际挂载对象是玩家飞船, 通过Hero脚本进行管理.\n\n在游戏场景的Hero游戏对象上, 有五个子游戏对象hardpoint, 每个绑定在玩家飞船的不同位置上, 然后在游戏对象hardpoint上有子游戏对象Weapon预制件实例, Weapon脚本作为Weapon预制件的组件, Hero脚本作为Hero游戏对象的组件. 在Hero脚本中有Weapon列表, 绑定这些Weapon预制件实例来进行管理.\n\n通过调用Weapon.SetType(eWeaponType), 就可以设置具体的Weapon预制件实例的类型.\n\nClearWeapons()方法可以将所有的Weapon预制件实例类型改为eWeaponType.none.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n    public Weapon[] weapons;\n\n    void Awake() {\n        if (S == null) {\n            S = this;\n        } else {\n            Debug.LogError(\"Hero.Awake() - Attempted to assign second Hero.S!\");\n        }\n        ClearWeapons();\n        weapons[0].SetType(eWeaponType.blaster);\n    }\n    public void ClearWeapons() {\n        foreach (Weapon w in weapons) {\n            w.SetType(eWeaponType.none);\n        }\n    }\n\n}\n\n```\n\n### Weapon开火\n\n```mermaid\nclassDiagram\n    class Weapon {\n        +WeaponDefinition def\n        +float nextShotTime\n        +Transform shotPointTrans\n        +Start()\n        +Fire()\n        +MakeProjectile()\n    }\n    \n    class ProjectileHero {\n        +Rigidbody rigid\n        +BoundsCheck boundsCheck\n        +Renderer rend\n        +eWeaponType type\n        +SetType(eWeaponType eType)\n        +Vector3 vel\n        +Awake()\n        +Update()\n    }\n\n    class WeaponDefinition {\n        +GameObject projectilePrefab\n        +float delayBetweenShots\n        +float velocity\n        +Color projectileColor\n    }\n\n    Weapon --> ProjectileHero : \"生成弹药实例\"\n    ProjectileHero --> WeaponDefinition : \"获取弹药定义\"\n    Weapon --> WeaponDefinition : \"根据武器类型获取参数\"\n    ProjectileHero --> Rigidbody : \"控制物理运动\"\n    ProjectileHero --> BoundsCheck : \"检测屏幕外销毁\"\n\n```\n\n对于每一个Weapon游戏对象实例, 由Weapon预制体的子对象ShotPoint提供射击点, 也就是弹药生成的位置.\n\nWeapon 脚本通过WeaponDefinition def上保存的武器定义, 来获取弹药的参数, 包括弹药预制体和弹药速度等.\n\nFire()方法作为Weapon的开火方法, 当被触发时, 根据保存的武器类型, 进行相对应的弹药生成方法. 例如blaster就生成一个弹药, spread就生成三个弹药. 弹药\n\n```csharp\n// 武器类\npublic class Weapon : MonoBehaviour {\n    public WeaponDefinition def;   // 武器定义\n    public float nextShotTime;     // 下一次射击的时间\n    private Transform shotPointTrans; // 射击点的Transform\n    \n  void Start() {\n        shotPointTrans = transform.GetChild(0);  // 获取子物体的Transform作为射击点\n    }\n    \n    // 触发射击\n    private void Fire() {\n        if (Time.time < nextShotTime) return;  // 如果还没到下一次射击时间，返回\n\n        ProjectileHero projectileHero;  // 投射物\n        Vector3 vel = Vector3.up * def.velocity;  // 投射物速度\n\n        // 根据武器类型发射不同的投射物\n        switch (type) {\n            case eWeaponType.blaster:  // 爆能枪\n                projectileHero = MakeProjectile();  // 创建投射物\n                projectileHero.vel = vel;  // 设置投射物速度\n                break;\n            case eWeaponType.spread:  // 散射武器\n                projectileHero = MakeProjectile();\n                projectileHero.vel = vel;\n\n                // 创建左侧散射投射物\n                projectileHero = MakeProjectile();\n                projectileHero.transform.rotation = Quaternion.AngleAxis(10, Vector3.back);\n                projectileHero.vel = projectileHero.transform.rotation * vel;\n\n                // 创建右侧散射投射物\n                projectileHero = MakeProjectile();\n                projectileHero.transform.rotation = Quaternion.AngleAxis(-10, Vector3.back);\n                projectileHero.vel = projectileHero.transform.rotation * vel;\n\n                break;\n        }\n    }\n\n    // 创建投射物实例\n    private ProjectileHero MakeProjectile() {\n        GameObject gameObject = Instantiate<GameObject>(def.projectilePrefab, PROJECTILE_ANCHOR);  // 实例化投射物\n        ProjectileHero projectileHero = gameObject.GetComponent<ProjectileHero>();  // 获取投射物组件\n\n        Vector3 pos = shotPointTrans.position;  // 获取射击点的位置\n        pos.z = 0;  // 设置Z轴为0\n        projectileHero.transform.position = pos;  // 设置投射物位置\n\n        projectileHero.type = type;  // 设置投射物类型\n        nextShotTime = Time.time + def.delayBetweenShots;  // 设置下一次射击的时间\n        return projectileHero;  // 返回投射物实例\n    }\n}\n\n```\n\n弹药ProjectileHero 实例由Weapon生成,\n\n由Weapon控制其速度, 由刚体组件控制其运动,\n\n由BoundsCheck组件提供是否飞出屏幕, 判断销毁,\n\n由Enemy判断碰撞逻辑销毁.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class ProjectileHero : MonoBehaviour {\n    private BoundsCheck boundsCheck;\n    private Renderer rend;\n    [Header(\"Dynamic\")]\n    public Rigidbody rigid;\n    private eWeaponType _type;\n    public eWeaponType type {\n        get { return _type; }\n        set { SetType(value); }\n    }\n    \n    public void SetType(eWeaponType eType) {\n        _type = eType;\n        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(_type);\n        rend.material.color = def.projectileColor;\n    }\n    public Vector3 vel {\n        get { return rigid.velocity; }\n        set { rigid.velocity = value; }\n    }\n\n    void Awake() {\n        boundsCheck = GetComponent<BoundsCheck>();\n        rend = GetComponent<Renderer>();\n        rigid = GetComponent<Rigidbody>();\n    }\n\n    void Update() {\n        if (boundsCheck.LocIs(BoundsCheck.eScreenLocs.offTop)) {\n            Destroy(gameObject);\n        }\n    }\n}\n\n```\n\n### Hero开火事件\n\n```mermaid\nclassDiagram\n    class Hero {\n        +delegate WeaponFireDelegate\n        +event WeaponFireDelegate fireEvent\n        +Update() \"检测开火输入\"\n    }\n    \n    class Weapon {\n        +Start()\n        +Fire()\"触发射击\"\n    }\n\n    Hero o-- Weapon : \"注册开火事件\"\n    Hero : +fireEvent()\n    Weapon --> Hero : \"fireEvent 事件触发\"\n\n```\n\nWeapon的开火事件由Hero控制触发.\n\n在Hero上保存有委托fireEvent, 每帧检测是否有开火控制型号, 然后触发fireEvent.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n\n    public delegate void WeaponFireDelegate();\n    public event WeaponFireDelegate fireEvent;\n\n    void Update() {\n        if (Input.GetAxis(\"Jump\") == 1 && fireEvent != null) {\n            fireEvent();\n        }\n    }\n\n}\n\n```\n\n在Weapon上注册事件, 将Weapon的Fire方法绑定到Hero的fireEvent上.\n\n这样当Hero触发开火时, 所有的Weapon都会开火.\n\n```csharp\n// 武器类\npublic class Weapon : MonoBehaviour {\n\n    void Start() {\n      // 如果该武器附加在玩家上，注册射击事件\n        Hero hero = GetComponentInParent<Hero>();\n        if (hero != null) hero.fireEvent += Fire;\n    }\n    \n    // 触发射击\n    private void Fire() {\n    \n    }\n\n}\n\n```\n\n## PowerUp\n\n升级道具由Enemy死亡掉落, 可以触发Weapon改变\n\n### PowerUp生成\n\n```mermaid\nclassDiagram\n    class Enemy {\n        +OnCollisionEnter(Collision coll)\n        +bool calledShipDestroyed\n    }\n    \n    class PowerUp {\n        +eWeaponType type\n        +SetType(eWeaponType wt)\n    }\n    \n    class Main {\n        +static Main S\n        +GameObject prefabPowerUp\n        +eWeaponType[] powerUpFrequency\n        +static void SHIP_DESTROYED(Enemy e)\n    }\n\n    Enemy --> Main : \"通知SHIP_DESTROYED\"\n    Main --> PowerUp : \"生成PowerUp\"\n    PowerUp : +SetType()\n\n```\n\nPowerUp有其类型, 对应武器类型.\n\n```csharp\npublic class PowerUp : MonoBehaviour {\n\n    [Header(\"Dynamic\")]\n    public eWeaponType _type;          // PowerUp 的类型\n    public float birthTime;     // PowerUp 实例化时的 Time.time\n\n    void Awake() {\n    \n        birthTime = Time.time; // 记录实例化时的时间\n    }\n\n    // PowerUp 类型的属性\n    public eWeaponType type { get { return _type; } set { SetType(value); } } // h\n\n    // 设置 PowerUp 类型\n    public void SetType(eWeaponType wt) {\n        // 从 Main 中获取武器定义\n        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(wt);\n        cubeMat.color = def.powerUpColor;  // 设置 PowerCube 的颜色\n        letter.text = def.letter;          // 设置显示的字母\n        _type = wt;                         // 最终设置类型\n    }\n\n}\n\n```\n\n为了使系统保持简洁, 也就是可以生成实例的类不要太多, 这里吧生成PowerUP的职责放在Main中.\n\n当Enemy被销毁时, 通知Main.  使用Main.SHIP_DESTROYED(this);\n\n```csharp\npublic class Enemy : MonoBehaviour {\n\n    void OnCollisionEnter(Collision coll) {\n        GameObject otherGO = coll.gameObject;\n        ProjectileHero projectileHero = otherGO.GetComponent<ProjectileHero>();\n        if (projectileHero != null) {\n            if (bndCheck.isOnScreen) {\n                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;\n                if (health < 0) {\n                    if (!calledShipDestroyed) {\n                        calledShipDestroyed = true;\n                        Main.SHIP_DESTROYED(this);\n                    }\n                    Destroy(gameObject);\n                }\n            }\n            Destroy(otherGO);\n        } else {\n            Debug.Log(\"Enemy hit by non-ProjectileHero: \" + otherGO.name);\n        }\n    }\n}\n\n```\n\nMain中保存有PowerUP预制体, 以及一个eWeaponType列表, 用来控制PowerUP生成类型的概率.\n\n当Main.SHIP_DESTROYED被触发时, 生成PowerUP并设定类型.\n\n```csharp\nusing Random = UnityEngine.Random;\n\npublic class Main : MonoBehaviour {\n    static private Main S;\n    \n    public GameObject prefabPowerUp;\n    public eWeaponType[] powerUpFrequency = new eWeaponType[]{\n        eWeaponType.blaster,\n        eWeaponType.blaster,\n        eWeaponType.spread,\n        eWeaponType.shield,\n    };\n    \n    static public void SHIP_DESTROYED(Enemy e) {\n        // 有可能生成一个PowerUp\n        if (Random.value <= e.powerUpDropChance) {  // 有一定几率生成 PowerUp\n            // 从powerUpFrequency数组中选择一个PowerUp类型\n            eWeaponType pUpType = S.powerUpFrequency[Random.Range(0, S.powerUpFrequency.Length)];  // 选择 PowerUp 类型\n\n            // 生成一个PowerUp对象\n            GameObject go = Instantiate<GameObject>(S.prefabPowerUp);  // 实例化 PowerUp 对象\n            PowerUp pUp = go.GetComponent<PowerUp>();  // 获取 PowerUp 脚本组件\n            // 设置生成的PowerUp为选定的武器类型\n            pUp.SetType(pUpType);  // 设置 PowerUp 的类型\n\n            // 设置 PowerUp 的位置为被摧毁的飞船的位置\n            pUp.transform.position = e.transform.position;\n        }\n    }\n\n}\n\n```\n\n### PowerUp触发\n\n```mermaid\nclassDiagram\n    class Hero {\n        +void OnTriggerEnter(Collider other)\n        +void AbsorbPowerUp(PowerUp powerUp)\n    }\n    \n    class PowerUp {\n        +eWeaponType type\n        +void AbsorbedBy(GameObject go) \n    }\n\n    class Weapon {\n        +void SetType(eWeaponType type)\n    }\n\n    Hero --> PowerUp : \"碰撞检测\"\n    Hero --> Weapon : \"改变武器类型\"\n    PowerUp --> Hero : \"触发PowerUp效果\"\n    PowerUp : +type \"PowerUp类型\"\n\n```\n\n当PowerUP被Hero碰撞后, 被消化使用. 在Hero中判断powerUp.type, 根据具体类型产生不同效果, 同时销毁powerUp.\n\n若powerUp.type为一种武器, 触发weapon.SetType(powerUp.type), 到Weapon类型被改变.\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n    private GameObject lastTriggerGo = null;\n\n    void OnTriggerEnter(Collider other) {\n        Transform rootT = other.gameObject.transform.root;\n        GameObject gameObject = rootT.gameObject;\n        if (gameObject == lastTriggerGo) return;\n        lastTriggerGo = gameObject;\n\n        Enemy enemy = gameObject.GetComponent<Enemy>();\n        PowerUp powerUp = gameObject.GetComponent<PowerUp>();\n\n        if (enemy != null) {\n            shieldLevel--;\n            Destroy(gameObject);\n        } else if (powerUp != null) {\n            AbsorbPowerUp(powerUp);\n        } else {\n            Debug.LogWarning(\"Shield trigger hit by non-Enemy: \" + gameObject.name);\n        }\n\n    }\n\n    public void AbsorbPowerUp(PowerUp powerUp) {\n        Debug.Log(\"Absorbed PowerUp: \" + powerUp.type);\n        switch (powerUp.type) {\n            case eWeaponType.shield:\n                shieldLevel++;\n                break;\n            default:\n                if (powerUp.type == weapons[0].type) {\n                    Weapon weapon = GetEmptyWeaponSlot();\n                    if (weapon != null) {\n                        weapon.SetType(powerUp.type);\n                    }\n                } else {\n                    ClearWeapons();\n                    weapons[0].SetType(powerUp.type);\n                }\n                break;\n        }\n        powerUp.AbsorbedBy(gameObject);\n    }\n\n}\n\n```\n\n当PowerUP被触发时, 销毁自己\n\n```csharp\npublic class PowerUp : MonoBehaviour {\n    public void AbsorbedBy(GameObject target) {\n        Destroy(this.gameObject);\n    }\n\n}\n\n```\n\n# 视觉效果\n\n## 飞船运动倾角\n\n### Hero中的应用\n\n移动时, 根据虚拟轴输入, 计算旋转角度\n\n![image.png](image%2010.png)\n\n![image.png](image%2011.png)\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Hero : MonoBehaviour {\n    static public Hero S { get; private set; }\n\n    [Header(\"Inscribed\")]\n    public float maxSpeed = 30;\n    public float rollMult = -45;\n    public float pitchMult = 30;\n\n    void Update() {\n        float hAxis = Input.GetAxis(\"Horizontal\");\n        float vAxis = Input.GetAxis(\"Vertical\");\n\n        transform.rotation = Quaternion.Euler(vAxis * pitchMult, hAxis * rollMult, 0);\n\n    }\n}\n\n```\n\n### Enemy_1中的应用\n\n移动时, 根据侧向偏移量, 计算旋转角度\n\n![image.png](image%2012.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_1 : Enemy {\n    [Header(\"Enemy_1 Inscribed Fields\")]\n    [Tooltip(\"# of seconds for a full sine wave\")]\n    public float waveFrequency = 2;\n    [Tooltip(\"Sine wave width in meters\")]\n    public float waveWidth = 6;\n    [Tooltip(\"Amount the ship will roll left and right with the sine wave\")]\n    public float waveRotY = 45;\n    private float x0;\n    private float birthTime;\n\n    void Start() {\n        x0 = pos.x;\n        birthTime = Time.time;\n    }\n\n    public override void Move() {\n        Vector3 tempPos = pos;\n        float age = Time.time - birthTime;\n        float theta = Mathf.PI * 2 * age / waveFrequency;\n        float sin = Mathf.Sin(theta);\n        tempPos.x = x0 + sin * waveWidth;\n        pos = tempPos;\n\n        Vector3 rot = new Vector3(0, sin * waveRotY, 0);\n        transform.rotation = Quaternion.Euler(rot);\n\n        base.Move();\n\n        // print(bndCheck.isOnScreen);\n    }\n}\n\n```\n\n### Enemy_2中的应用\n\n移动时, 根据AnimationCurve 曲线, 计算旋转角度\n\n![image.png](image%2013.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_2 : Enemy {\n    [Header(\"Enemy_2 Inscribed Field\")]\n    public float lifeTime = 10f;\n\n    [Tooltip(\"波幅控制\")]\n    public float sinEccentricity = 0.6f;\n    public AnimationCurve rotCurve;\n\n    [Header(\"Enemy_2 Private Fields\")]\n    [SerializeField] private float birthTime;\n    private Quaternion baseRotation;\n    [SerializeField] private Vector3 p0, p1;//插值控制点\n\n    void Start() {\n        p0 = Vector3.zero;\n        p0.x = -bndCheck.camWidth - bndCheck.radius;\n        p0.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);\n\n        p1 = Vector3.zero;\n        p1.x = bndCheck.camWidth + bndCheck.radius;\n        p1.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);\n\n        if (Random.value > 0.5f) {\n            p0.x *= -1;\n            p1.x *= -1;\n        }\n\n        birthTime = Time.time;\n\n        transform.position = p0;\n        transform.LookAt(p1, Vector3.back);\n        baseRotation = transform.rotation;\n    }\n\n    public override void Move() {\n        float u = (Time.time - birthTime) / birthTime;\n\n        if (u > 1) {\n            Destroy(gameObject);\n            return;\n        }\n\n        float shipRot = rotCurve.Evaluate(u) * 360;\n        transform.rotation = baseRotation * Quaternion.Euler(-shipRot, 0, 0);\n\n        u = u + sinEccentricity * Mathf.Sin(u * Mathf.PI * 2);\n\n        pos = (1 - u) * p0 + u * p1;\n\n    }\n}\n\n```\n\n## 平滑移动路径\n\n### 贝塞尔曲线\n\n```csharp\nusing System.Linq;\nusing UnityEngine;\n\npublic class Utils : MonoBehaviour {\n    /// <summary>\n    /// 递归计算任意数量控制点的 Bézier 曲线上的点\n    /// </summary>\n    /// <param name=\"t\">插值比例 [0..1]</param>\n    /// <param name=\"points\">控制点数组</param>\n    /// <returns>曲线上的插值点</returns>\n    static public Vector3 Bezier(float t, params Vector3[] points) {\n        // 当只有一个控制点时，返回该控制点\n        if (points.Length == 1) return points[0];\n\n        // 使用 LINQ 的 Select 和 Zip 进行插值计算\n        return Bezier(t, points.Take(points.Length - 1)\n                               .Zip(points.Skip(1), (p0, p1) => Vector3.LerpUnclamped(p0, p1, t))\n                               .ToArray());\n    }\n\n}\n\n```\n\n### Enemy_3中的应用\n\n![image.png](image%2014.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Enemy_3 : Enemy {            // Enemy_3 继承自 Enemy 类\n    [Header(\"Enemy_3 公共字段\")]\n    public float lifeTime = 5;            // 生命时长为5秒\n    public Vector2 midpointYRange = new Vector2(1.5f, 3);   // 中间点Y轴范围\n    [Tooltip(\"如果为true,则在Scene面板中绘制Bézier点和路径。\")]\n    public bool drawDebugInfo = true;     // 是否绘制调试信息\n\n    [Header(\"Enemy_3 私有字段\")]\n    [SerializeField]\n    private Vector3[] points;  // Bézier曲线的三个点\n    [SerializeField]\n    private float birthTime;   // 记录生成时间\n\n    // Start方法,因父类Enemy未使用,所以可以在此处使用\n    void Start() {\n        points = new Vector3[3];  // 初始化三个控制点\n\n        // 起始位置已经由 Main.SpawnEnemy() 设置\n        points[0] = pos;  // 第一个点是当前敌人的初始位置\n\n        // 设置x轴的最小和最大值,和Main.SpawnEnemy()方式一致\n        float xMin = -bndCheck.camWidth + bndCheck.radius;\n        float xMax = bndCheck.camWidth - bndCheck.radius;\n\n        // 随机选择屏幕下半部分的一个中间点\n        points[1] = Vector3.zero;  // 初始化第二个点\n        points[1].x = Random.Range(xMin, xMax);  // x轴随机范围\n        float midYMult = Random.Range(midpointYRange[0], midpointYRange[1]);  // 随机Y轴比例  // a\n        points[1].y = -bndCheck.camHeight * midYMult;  // 设置Y轴位置  // a\n\n        // 随机选择屏幕上方的一个最终点\n        points[2] = Vector3.zero;  // 初始化第三个点\n        points[2].y = pos.y;       // Y轴保持在初始位置上方\n        points[2].x = Random.Range(xMin, xMax);  // x轴随机范围\n\n        // 设置出生时间为当前时间\n        birthTime = Time.time;\n\n        // 如果需要绘制调试信息,则调用DrawDebug方法  // b\n        if (drawDebugInfo) DrawDebug();\n    }\n\n    public override void Move() {\n        // Bézier曲线基于u值,u的范围在0到1之间\n        float u = (Time.time - birthTime) / lifeTime;\n\n        if (u > 1) {\n            // 如果u超过1,表示该敌人生命周期已结束\n            Destroy(this.gameObject);  // 销毁游戏对象\n            return;\n        }\n\n        // 根据u值旋转对象  // c\n        transform.rotation = Quaternion.Euler(u * 180, 0, 0);\n\n        // 插值计算Bézier曲线上的三个点  // d\n        u = u - 0.1f * Mathf.Sin(u * Mathf.PI * 2);\n        pos = Utils.Bezier(u, points);\n\n        // Enemy_3 不调用父类的Move()\n    }\n\n    // 绘制调试信息,包括Bézier曲线和控制点  // e\n    void DrawDebug() {\n        // 绘制三个控制点之间的直线\n        Debug.DrawLine(points[0], points[1], Color.cyan, lifeTime);  // 绘制第1到第2个点的线  // f\n        Debug.DrawLine(points[1], points[2], Color.yellow, lifeTime); // 绘制第2到第3个点的线\n\n        // 绘制Bézier曲线\n        float numSections = 20;  // 曲线分为20段\n        Vector3 prevPoint = points[0];  // 上一个点,初始化为第一个控制点  // g\n        Color col;\n        Vector3 pt;\n        for (int i = 1; i < numSections; i++) {  // 绘制Bézier曲线的各段  // h\n            float u = i / numSections;  // u的值在0到1之间变化\n            pt = Utils.Bezier(u, points);  // 计算当前插值点\n            col = Color.Lerp(Color.cyan, Color.yellow, u);  // 根据u值插值颜色\n            Debug.DrawLine(prevPoint, pt, col, lifeTime);  // 绘制前一个点到当前点的线  // i\n            prevPoint = pt;  // 更新上一个点为当前点\n        }\n    }\n}\n\n```\n\n## 敌人受击反馈\n\n新建受击组件\n\n保存所有子对象材质\n\n检测碰撞, 当被子弹命中时改变材质, 产生效果.\n\n效果根据时间消失.\n\n![image.png](image%2015.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\n[DisallowMultipleComponent]  // 不允许在同一个GameObject上添加多个该组件  // a\npublic class BlinkColorOnHit : MonoBehaviour {\n    private static float blinkDuration = 0.1f;  // 闪烁颜色的持续时间（以秒为单位）  // b\n    private static Color blinkColor = Color.red;  // 受击时显示的颜色\n\n    [Header(\"动态参数\")]  // 在Inspector面板中分类显示动态参数\n    public bool showingColor = false;  // 是否正在显示闪烁颜色\n    public float blinkCompleteTime;    // 恢复原始颜色的时间\n    public bool ignoreOnCollisionEnter = false;\n\n    private Material[] materials;      // 当前GameObject及其子对象的所有材质\n    private Color[] originalColors;    // 材质的原始颜色数组\n    private BoundsCheck bndCheck;      // 用于检测对象是否在屏幕范围内的组件\n\n    void Awake() {\n        bndCheck = GetComponentInParent<BoundsCheck>();  // 获取父对象上的BoundsCheck组件  // c\n        // 获取该GameObject及其所有子对象的材质\n        materials = Utils.GetAllMaterials(gameObject);    // d\n        // 存储每个材质的原始颜色\n        originalColors = materials.Select(m => m.color).ToArray();\n    }\n\n    void Update() {\n        // 如果正在显示闪烁颜色且当前时间超过了恢复颜色的时间，恢复原始颜色\n        if (showingColor && Time.time > blinkCompleteTime) RevertColors();  // e\n    }\n\n    void OnCollisionEnter(Collision coll) {\n        if (ignoreOnCollisionEnter) return;\n        // 如果有BoundsCheck且对象不在屏幕内，跳过受击显示\n        if (bndCheck != null && !bndCheck.isOnScreen) {  // g\n            return;  // 当对象不在屏幕内时，不显示受击效果\n        }\n        // 检测与ProjectileHero的碰撞\n        ProjectileHero p = coll.gameObject.GetComponent<ProjectileHero>();\n        if (p != null) {  // 如果碰撞对象是ProjectileHero  // f\n\n            SetColors();  // 显示受击颜色\n        }\n    }\n\n    /// <summary>\n    /// 将所有材质的主颜色设置为闪烁颜色，并设置显示颜色的时间\n    /// </summary>\n    public void SetColors() {\n        foreach (Material m in materials) {\n            m.color = blinkColor;  // 将材质颜色设置为闪烁颜色\n        }\n        showingColor = true;  // 标记正在显示颜色\n        blinkCompleteTime = Time.time + blinkDuration;  // 设置颜色恢复的时间\n    }\n\n    /// <summary>\n    /// 恢复所有材质的原始颜色，并停止显示颜色\n    /// </summary>\n    public void RevertColors() {\n        for (int i = 0; i < materials.Length; i++) {\n            materials[i].color = originalColors[i];  // 恢复原始颜色\n        }\n        showingColor = false;  // 标记颜色显示结束\n    }\n}\n\n```\n\n## 无缝太空背景\n\n滚动数组思想.\n\n使用两块背景, 循环播放, 当一张移出屏幕后, 接替到另一张上面.\n\n![image.png](image%2016.png)\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Parallax : MonoBehaviour {\n    [Header(\"Inscribed\")]\n    public Transform playerTrans; // The player ship (玩家飞船)\n    public Transform[] panels; // The scrolling foregrounds (滚动的前景面板)\n    [Tooltip(\"Speed at which the panels move in Y\")]\n    public float scrollSpeed = -30f; // 面板在Y轴上的滚动速度\n    [Tooltip(\"Controls how much panels react to player movement (Default 0.25)\")]\n    public float motionMult = 0.25f; // 控制面板对玩家移动的反应程度 (默认值 0.25)   // a\n\n    private float panelHt; // Height of each panel (每个面板的高度)\n    private float depth;   // Depth of panels (that is, pos.z) (面板的深度，即z轴位置)\n\n    void Start() {\n        panelHt = panels[0].localScale.y; // 获取第一个面板的高度\n        depth = panels[0].position.z; // 获取面板的深度（z轴位置）\n\n        // Set initial positions of panels (设置面板的初始位置)\n        panels[0].position = new Vector3(0, 0, depth); // 第一个面板位于起点\n        panels[1].position = new Vector3(0, panelHt, depth); // 第二个面板位于第一个面板上方\n    }\n\n    void Update() {\n        float tY, tX = 0; // 定义用于计算面板位置的变量\n        tY = Time.time * scrollSpeed % panelHt + (panelHt * 0.5f); // 随时间滚动并保证循环衔接   // b\n\n        if (playerTrans != null) {\n            tX = -playerTrans.transform.position.x * motionMult; // 根据玩家的x位置调整tX   // c\n                                                                 // tY += -poi.transform.position.y * motionMult; // 如果需要，也可以对Y轴进行调整\n        }\n\n        // Position panels[0] (设置第一个面板的位置)\n        panels[0].position = new Vector3(tX, tY, depth);\n        // Position panels[1] where needed to make a continuous starfield (根据需要设置第二个面板的位置，以实现连续的星空效果)  // d\n        if (tY >= 0) {\n            panels[1].position = new Vector3(tX, tY - panelHt, depth); // 第二个面板在第一个面板的上方\n        } else {\n            panels[1].position = new Vector3(tX, tY + panelHt, depth); // 第二个面板在第一个面板的下方\n        }\n    }\n}\n\n```\n\n# 扩展实践\n\n## Missile\n\n创建一种新的武器-导弹. 可以在发射后自动跟踪敌人.\n\n### 创建新的武器配置\n\n在Main.cs→WeaponDefinitions中创建Missile\n\n![image.png](image%2017.png)\n\n在Main.cs→PowerUPfrequency中创建Missile\n\n![image.png](image%2018.png)\n\n此时运行游戏\n\n敌人可掉落M道具\n\n![image.png](image%2019.png)\n\n拾取后也可正常装备\n\n![image.png](image%2020.png)\n\n但此时还没有发射功能\n\n### 添加发射功能\n\n修改Weapon类, 在射击方法中添加处理导弹类型的代码\n\n```csharp\n\n// 武器类\npublic class Weapon : MonoBehaviour {\n    // 触发射击\n    private void Fire() {\n        // 根据武器类型发射不同的投射物\n        switch (type) {\n            // 导弹类型\n            case eWeaponType.missile:\n                projectileHero = MakeProjectile();\n                projectileHero.vel = vel;\n                break;\n        }\n    }\n\n}\n\n```\n\n此时可以发生导弹类型的弹药, 由上一步配置为红色.\n\n![image.png](image%2021.png)\n\n### 实现目标检测\n\n实现思路\n\n给ProjectileHero创建一个球形碰撞箱来检测敌人\n\n通过向量差值获得指向敌人的向量来修改导弹的速度使其朝向敌人\n\nProjectileHero已经自身持有一个碰撞箱用来检测是否与敌人碰撞, 所以我们给Missile类型的ProjectileHero创建一个子对象detectionRange, 再在这个子对象detectionRange上添加SphereCollider.\n\n在ProjectileHero上新增代码\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class ProjectileHero : MonoBehaviour {\n\n    private Transform detectionRangeTrans;\n\n    public void SetType(eWeaponType eType) {\n    \n        // 如果类型是导弹类型，添加检测范围\n        if (_type == eWeaponType.missile) {\n            AddDetectionRange();\n        }\n    }\n\n    // 添加用于检测目标的球形碰撞体\n    private void AddDetectionRange() {\n        // 创建子对象\n        GameObject detectionRange = new GameObject(\"DetectionRange\");\n        detectionRangeTrans = detectionRange.transform;\n        // 设置为ProjectileHero的子对象\n        detectionRangeTrans.SetParent(this.transform);\n        // 确保位置和ProjectileHero一致\n        detectionRangeTrans.localPosition = Vector3.zero;\n        // 设置与ProjectileHero相同的Layer\n        detectionRangeTrans.gameObject.layer = gameObject.layer;\n        // 添加球形碰撞箱\n        SphereCollider sphereCollider = detectionRange.AddComponent<SphereCollider>();\n        sphereCollider.isTrigger = true; // 设置为触发器\n        // 设置碰撞体的半径，决定探测范围\n        sphereCollider.radius = 10f; // 可以根据需要调整半径的大小\n    }\n}\n\n```\n\n实现效果, 可见碰撞箱半径\n\n![image.png](image%2022.png)\n\n### 实现目标追踪\n\n为刚才创建的对象添加一个脚本, 专门用来处理追踪逻辑\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n[RequireComponent(typeof(BoundsCheck))]\npublic class ProjectileHero : MonoBehaviour {\n    // 添加用于检测目标的球形碰撞体\n    private void AddDetectionRange() {\n        // 添加一个额外的脚本，用于处理目标检测逻辑\n        detectionRange.AddComponent<MissileTargetDetector>();\n    }\n}\n\n```\n\n保存变量projectileHero, 用于修改其运动\n\n保存变量enemy 用于确认目标\n\n在OnTriggerEnter中设定目标\n\n在OnTriggerExit中放弃目标\n\n在Update使用线性插值修改速度方向追踪目标\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MissileTargetDetector : MonoBehaviour {\n    ProjectileHero projectileHero;\n    Enemy enemy = null;\n\n    void Awake() {\n        projectileHero = gameObject.GetComponentInParent<ProjectileHero>();\n    }\n\n    void Update() {\n        // 若目标存在且存活, 修正速度方向, 实现追踪功能\n        if (enemy != null && enemy.gameObject != null) {\n            Vector3 origin = projectileHero.rigid.velocity;\n            Vector3 direction = (enemy.transform.position - transform.position).normalized * origin.magnitude;\n            projectileHero.rigid.velocity = Vector3.Lerp(origin, direction, 0.2f);\n        } else {\n            enemy = null;\n        }\n    }\n\n    void OnTriggerEnter(Collider other) {\n        // Debug.LogWarning(\"Missile trigger Enter: \" + other.name);\n        // 若敌人进入范围, 且当前无其他目标, 将该敌人设定为目标\n        Enemy detectedEnemy = other.gameObject.GetComponent<Enemy>();\n        if (enemy == null && detectedEnemy != null) {\n            enemy = detectedEnemy;\n        }\n    }\n\n    void OnTriggerExit(Collider other) {\n        // Debug.LogWarning(\"Missile trigger Exit: \" + other.name);\n        // 若目标存在且脱离追踪范围, 放弃这个目标\n        if (enemy != null && other.gameObject == enemy.gameObject) {\n            enemy = null;\n        }\n    }\n}\n\n```\n\n实现效果, 当导弹靠近目标之后, 会指向目标\n\n![image.png](image%2023.png)\n\n发现Bug1, 当导弹跟踪的目标丢失以后会失去速度滞留在地图上\n\n![image.png](image%2024.png)\n\n修复: 使用线性插值直接修改速度会改变速度大小, 下文优化追踪方案\n\n发现Bug2, 导弹对Enemy_1没有追踪作用\n\n修复: Enemy_1没有碰撞箱, 添加碰撞箱后功能恢复\n\n![image.png](image%2025.png)\n\n### 优化目标追踪\n\n将原本的线性插值改变速度方向, 改为旋转导弹的方向, 更加平滑, 视觉表现也更好.\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MissileTargetDetector : MonoBehaviour {\n    public float rotationSpeed = 4.0f;  // 控制旋转速度\n    void Update() {\n        // 若目标存在且存活, 修正速度方向, 实现追踪功能\n        if (enemy != null && enemy.gameObject != null) {\n            // 计算导弹当前朝向与目标之间的旋转\n            Vector3 targetDirection = (enemy.transform.position - projectileHero.transform.position).normalized;\n            Quaternion targetRotation = Quaternion.LookRotation(Vector3.forward, targetDirection);\n            // 平滑地插值旋转到目标方向\n            projectileHero.transform.rotation = Quaternion.Slerp(\n                projectileHero.transform.rotation,\n                targetRotation,\n                Time.deltaTime * rotationSpeed\n            );\n            // 根据当前朝向更新导弹的速度\n            projectileHero.vel = projectileHero.transform.up * projectileHero.speed;\n        } else {\n            enemy = null;\n        }\n    }\n}\n\n```\n\n同时在ProjectileHero保存速度的大小, 修复了导弹静止的问题.\n\n```csharp\n\npublic class ProjectileHero : MonoBehaviour {\n    public float speed;\n    public void SetType(eWeaponType eType) {\n        speed = def.velocity;\n    }\n}\n\n```\n\n![image.png](image%2026.png)\n","slug":"Space SHMUP 拆解和拓展","published":1,"updated":"2024-11-20T06:46:01.353Z","_id":"cm3pihexg000nn0umcn88bdl8","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"游戏内容分析\">游戏内容分析</h1>\r\n<p>SHMUP （Shoot 'em up），又称STG，即清版射击游戏,\r\n是一种游戏类型，通常以玩家控制飞行器或角色为基础，目标是消灭敌人并躲避子弹和障碍物。SHMUP游戏通常具有快节奏的动作、丰富的视觉效果和多样化的武器系统。</p>\r\n<figure>\r\n<img src=\"image.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>本项目来自<strong><em>Introduction to Game Design, Prototyping, and\r\nDevelopment</em></strong> 的 Space SHMUP.\r\n含有五种敌人角色和两种武器类型, 玩家需要操纵飞船躲避敌人, 攻击敌人,\r\n当击败敌人时可以获得加成道具.</p>\r\n<h2 id=\"玩家角色\">玩家角色</h2>\r\n<p><img src=\"image%201.png\" alt=\"image.png\" /> <span id=\"more\"></span> ###\r\n玩家飞船的意义</p>\r\n<ol type=\"1\">\r\n<li>当游戏开始时出现在地图中</li>\r\n<li>当玩家飞船被消灭后游戏结束</li>\r\n</ol>\r\n<h3 id=\"玩家飞船的能力\">玩家飞船的能力</h3>\r\n<ol type=\"1\">\r\n<li>在地图上移动</li>\r\n<li>控制武器开火</li>\r\n</ol>\r\n<h3 id=\"玩家飞船与其他对象的交互\">玩家飞船与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>碰撞到敌人, 导致自生护盾减少, 当自身无护盾时被消灭</li>\r\n<li>碰撞到加成道具, 导致武器系统发生变化</li>\r\n</ol>\r\n<h2 id=\"敌人角色\">敌人角色</h2>\r\n<figure>\r\n<img src=\"image%202.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>敌人包括五种</p>\r\n<h3 id=\"敌人飞船的意义\">敌人飞船的意义</h3>\r\n<ol type=\"1\">\r\n<li><p>根据游戏时间进行, 敌人飞船会随机在地图中生成,\r\n给玩家飞船的生存带来负面影响</p>\r\n<p>[待扩展]将敌人生成预设为波次进攻模式,\r\n根据关卡难度控制生成情况</p></li>\r\n</ol>\r\n<h3 id=\"敌人飞船的能力\">敌人飞船的能力</h3>\r\n<ol type=\"1\">\r\n<li>在地图中移动, 不同的飞船有各自不同的移动能力\r\n<ol type=\"1\">\r\n<li>Enemy_0从地图上侧随机处生成, 向地图最下端直线移动,\r\n从下侧离开地图</li>\r\n<li>Enemy_1从地图上侧随机处生成, 向地图最下端移动的同时左右摇摆,\r\n从下侧离开地图</li>\r\n<li>Enemy_2从地图左右侧随机生成, 横向进入地图,\r\n来回穿越一回合后从另一侧离开地图</li>\r\n<li>Enemy_3从地图上侧随机处生成, 纵向进入地图,\r\n抵达路径最低处后从上侧离开地图</li>\r\n<li>Enemy_4从地图上侧随机处生成, 每隔一段时间, 在地图的四个象限没移动,\r\n不会离开地图</li>\r\n</ol></li>\r\n<li>掉落武器系统加成道具</li>\r\n<li>[可扩展]获得武器并控制武器开火</li>\r\n</ol>\r\n<h3 id=\"敌人飞船与其他对象的交互\">敌人飞船与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>承受玩家武器的攻击(碰撞到子弹), 减少生命值, 当生命值归零时,\r\n自身销毁.\r\n<ol type=\"1\">\r\n<li>Enemy_4持有护盾, 当收到攻击时, 优先消耗护盾的生命值</li>\r\n</ol></li>\r\n<li>碰撞到玩家飞船, 导致自身销毁.</li>\r\n</ol>\r\n<h2 id=\"武器系统\">武器系统</h2>\r\n<figure>\r\n<img src=\"image%203.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>玩家护盾虽与暂时玩家飞船绑定, 但可改造为武器系统的一部分</p>\r\n<h3 id=\"武器系统的意义\">武器系统的意义</h3>\r\n<ol type=\"1\">\r\n<li>为玩家飞船提供清理敌人飞船的能力, 使得玩家飞船在游戏中生存下来</li>\r\n<li>含有5个武器挂载点位, 为玩家提供了武器的选择和升级空间,\r\n使游戏更加有趣</li>\r\n</ol>\r\n<h3 id=\"武器系统的能力\">武器系统的能力</h3>\r\n<ol type=\"1\">\r\n<li>当玩家控制开火时, 武器可以以不同形式发射弹药,\r\n而弹药可以攻击并消灭敌人\r\n<ol type=\"1\">\r\n<li>Blaster 每次开火向正前方发射一枚子弹, 子弹会向前移动直到地图边缘,\r\n发射间隔较短</li>\r\n<li>Spread 每次开火向前方扇形排布发射多枚子弹, ,\r\n子弹会向前移动直到地图边缘, 发射间隔较长</li>\r\n<li>[待扩展]Missile 每次开火发射一枚导弹, 导弹可以自动跟踪敌人</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"武器系统与其他对象的交互\">武器系统与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>武器本身不与敌人交互, 而是通过弹药来与敌人交互,\r\n武器的职责是是生成弹药, 当弹药接触到敌人时, 给敌人造成伤害</li>\r\n<li>武器系统会根据玩家接触到的加成道具进行改变\r\n<ol type=\"1\">\r\n<li>玩家最多持有五个武器</li>\r\n<li>当玩家获得的加成和已持有的武器类型一致时, 武器系统得到强化</li>\r\n<li>当玩家获得的加成和已持有武器类型不一致时,\r\n将玩家的武器替换为所加成的武器, 此时武器系统可能强化或弱化</li>\r\n</ol></li>\r\n</ol>\r\n<h2 id=\"加成道具\">加成道具</h2>\r\n<figure>\r\n<img src=\"image%204.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"加成道具的意义\">加成道具的意义</h3>\r\n<ol type=\"1\">\r\n<li>加成道具可以为玩家提供武器系统的加成选项</li>\r\n<li>加成道具可以让玩家提供一个选择, 是否需要穿越危险的交战区,\r\n去获得加成道具, 使得游戏局面变得复杂有趣</li>\r\n</ol>\r\n<h3 id=\"加成道具的能力\">加成道具的能力</h3>\r\n<ol type=\"1\">\r\n<li>不同的加成道具可以给玩家提供不同的升级\r\n<ol type=\"1\">\r\n<li>Shield 增强玩家的护盾</li>\r\n<li>Spread 给玩家添加Spread 武器</li>\r\n<li>Blaster 给玩家添加Blaster 武器</li>\r\n<li>[可扩展] 同步武器系统的武器类型, 提供加成</li>\r\n<li>[可扩展] 对游戏局势产生重大效果, 如对所有敌人造成伤害</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"加成道具与其他对象的交互\">加成道具与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>与玩家飞船碰撞, 导致自身被消耗, 对玩家飞船造成相应影响</li>\r\n<li>当敌人被消灭时, 根据概率设定, 生成不同的加成道具</li>\r\n<li>[可扩展]与敌人飞船碰撞, 导致自身被销毁</li>\r\n<li>[可扩展]与敌人飞船碰撞, 对敌人飞船产生影响</li>\r\n</ol>\r\n<h1 id=\"系统分析与实现\">系统分析与实现</h1>\r\n<h2 id=\"boundscheck\">BoundsCheck</h2>\r\n<p>一个通用组件, 用于判断游戏对象是否在屏幕中, 获取相对屏幕的位置.</p>\r\n<p>可以用来管理游戏对象, 包括玩家.</p>\r\n<p>使用了复合枚举来保存位置信息.</p>\r\n<p>为每一个游戏对象添加BoundsCheck 组件,\r\n通过调用boundsCheck.isOnScreen()或boundsCheck.LocIs来获取信息.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BoundsCheck</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">System.Flags</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> eScreenLocs &#123;</span><br><span class=\"line\">        onScreen = <span class=\"number\">0</span>,</span><br><span class=\"line\">        offRight = <span class=\"number\">1</span>,</span><br><span class=\"line\">        offLeft = <span class=\"number\">2</span>,</span><br><span class=\"line\">        offTop = <span class=\"number\">4</span>,</span><br><span class=\"line\">        offBottom = <span class=\"number\">8</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> eType &#123; center, inset, outset &#125;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eType boundsType = eType.center;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> radius = <span class=\"number\">1f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> keepOnScreen = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Dynamic&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eScreenLocs screenLocs = eScreenLocs.onScreen;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> camWidth;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> camHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LateUpdate</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//更新screenLocs </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> isOnScreen &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> screenLocs == eScreenLocs.onScreen; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">LocIs</span>(<span class=\"params\">eScreenLocs checkLoc</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkLoc == eScreenLocs.onScreen) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isOnScreen;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (screenLocs &amp; checkLoc) == checkLoc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"enemy\">Enemy</h2>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Main {\r\n        - static Main S\r\n        - GameObject[] prefabEnemies\r\n        - float enemySpawnPerSecond\r\n        + Awake()\r\n        + SpawnEnemy()\r\n    }\r\n\r\n    class Enemy {\r\n        <<abstract>>\r\n        + float speed\r\n        + float health\r\n        + Vector3 pos\r\n        + Move()\r\n        + OnCollisionEnter(Collision coll)\r\n    }\r\n\r\n    class Enemy_1 {\r\n        + float waveFrequency\r\n        + float waveWidth\r\n        - float x0\r\n        - float birthTime\r\n        + Move()\r\n    }\r\n\r\n    class ProjectileHero {\r\n        + float damageOnHit\r\n    }\r\n\r\n    Main --> Enemy : \"生成\"\r\n    Main --> prefabEnemies : \"管理预制件\"\r\n    Enemy_1 --> Enemy : \"继承\"\r\n    Enemy --> ProjectileHero : \"检测碰撞\"</pre>\r\n<h3 id=\"enemy生成\">Enemy生成</h3>\r\n<p>Enemy的生成为全局管理, 由游戏唯一Main对象管理, Main为单例,\r\n且保存所有Enemy的预制件.</p>\r\n<p>当Main对象被创建后, 每隔一段时间调用SpawnEnemy()方法,\r\n由SpawnEnemy()生成一个Enemy,\r\n在SpawnEnemy中选取要生成的具体Enemy可以要生成的具体坐标,\r\n然后通过Invoke延时递归调用自身.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine.SceneManagement;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Random = UnityEngine.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Main</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Main S;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject[] prefabEnemies;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> enemySpawnPerSecond = <span class=\"number\">0.5f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        Invoke(<span class=\"keyword\">nameof</span>(SpawnEnemy), <span class=\"number\">1f</span> / enemySpawnPerSecond);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SpawnEnemy</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 随机选取一个要生成的Enemy</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> ndx = Random.Range(<span class=\"number\">0</span>, prefabEnemies.Length);</span><br><span class=\"line\">        GameObject newEnemy = Instantiate&lt;GameObject&gt;(prefabEnemies[ndx]);</span><br><span class=\"line\">        <span class=\"comment\">// 获取Enemy要生成的坐标</span></span><br><span class=\"line\">        Vector3 pos = Vector3.zero;</span><br><span class=\"line\">        newEnemy.transform.position = pos;</span><br><span class=\"line\">        <span class=\"comment\">// 根据配置生成下一个Enemy</span></span><br><span class=\"line\">        Invoke(<span class=\"keyword\">nameof</span>(SpawnEnemy), <span class=\"number\">1f</span> / enemySpawnPerSecond);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"image%205.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"enemy基类和扩展类\">Enemy基类和扩展类</h3>\r\n<p>Enemy预制件附带有对应的Enemy脚本, 控制对应Enemy的行为.</p>\r\n<figure>\r\n<img src=\"image%206.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>每一种Enemy的通用属性, 如移动速度, 血量, 可以定义在基类中</p>\r\n<figure>\r\n<img src=\"image%207.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>每一种Enemy的移动方式不同, 可以再基类中实现基本移动功能,\r\n在具体类中实现扩展功能.</p>\r\n<p>Enemy基类, 实现基本向下移动</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> speed = <span class=\"number\">10f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> fireRate = <span class=\"number\">0.3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> health = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> score = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector3 pos &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transform.position;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            transform.position = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        Move();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        Vector3 tempPos = pos;</span><br><span class=\"line\">        tempPos.y -= speed * Time.deltaTime;</span><br><span class=\"line\">        pos = tempPos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>例如: Enemy_1子类, 重写Move方法, 实现带有摆动的移动.</p>\r\n<p>通过Sin函数和存货时间计算摆动横向偏移量, 而基础的向下移动功能,\r\n又由Enemy基类完成.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_1</span> : <span class=\"title\">Enemy</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_1 Inscribed Fields&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;# of seconds for a full sine wave&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveFrequency = <span class=\"number\">2</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Sine wave width in meters&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveWidth = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> x0;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        x0 = pos.x;</span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        Vector3 tempPos = pos;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> age = Time.time - birthTime;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> theta = Mathf.PI * <span class=\"number\">2</span> * age / waveFrequency;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> sin = Mathf.Sin(theta);</span><br><span class=\"line\">        tempPos.x = x0 + sin * waveWidth;</span><br><span class=\"line\">        pos = tempPos;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">base</span>.Move();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy受击处理\">Enemy受击处理</h3>\r\n<p>Enemy可以和弹药类ProjectileHero进行碰撞, 通过Layer设置是否可以碰撞,\r\n然后在OnCollisionEnter中处理具体碰撞逻辑.</p>\r\n<p>弹药由武器生成, 弹药有伤害数值, 下文另谈.</p>\r\n<p>弹药游戏对象持有ProjectileHero组件,\r\n可用来判断Enemy碰撞到的是否是弹药.</p>\r\n<p>当Enemy碰撞到弹药后, 销毁弹药. 同时扣除自身血量,\r\n血量耗尽后销毁Enemy.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> health = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnCollisionEnter</span>(<span class=\"params\">Collision coll</span>)</span> &#123;</span><br><span class=\"line\">        GameObject otherGO = coll.gameObject;</span><br><span class=\"line\">        ProjectileHero projectileHero = otherGO.GetComponent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (projectileHero != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bndCheck.isOnScreen) &#123;</span><br><span class=\"line\">                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (health &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!calledShipDestroyed) &#123;</span><br><span class=\"line\">                        calledShipDestroyed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        Main.SHIP_DESTROYED(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Destroy(gameObject);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Destroy(otherGO);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.Log(<span class=\"string\">&quot;Enemy hit by non-ProjectileHero: &quot;</span> + otherGO.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"hero\">Hero</h2>\r\n<h3 id=\"hero生成\">Hero生成</h3>\r\n<p>玩家飞船也为全局唯一对象, 使用单例模式, 使用Hero脚本控制行为.</p>\r\n<p>因为不会重复生成, 所以游戏开始时直接布置在场景Scene中.</p>\r\n<figure>\r\n<img src=\"image%208.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"玩家移动控制\">玩家移动控制</h3>\r\n<p>有参数最大速度. 根据帧间时间计算移动后所处位置, 直接改变.</p>\r\n<p>每帧读取移动虚拟轴输入, 实现平滑移动.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> maxSpeed = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (S == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;Hero.Awake() - Attempted to assign second Hero.S!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> hAxis = Input.GetAxis(<span class=\"string\">&quot;Horizontal&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">float</span> vAxis = Input.GetAxis(<span class=\"string\">&quot;Vertical&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 pos = transform.position;</span><br><span class=\"line\">        pos.x += hAxis * maxSpeed * Time.deltaTime;</span><br><span class=\"line\">        pos.y += vAxis * maxSpeed * Time.deltaTime;</span><br><span class=\"line\">        transform.position = pos;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"玩家开火控制\">玩家开火控制</h3>\r\n<p>每帧读取开火虚拟轴输入, 触发开火事件. 具体开火实现见武器系统.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">WeaponFireDelegate</span>()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> WeaponFireDelegate fireEvent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Input.GetAxis(<span class=\"string\">&quot;Jump&quot;</span>) == <span class=\"number\">1</span> &amp;&amp; fireEvent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            fireEven();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"weapon\">Weapon</h2>\r\n<h3 id=\"weapon配置管理和切换\">Weapon配置管理和切换</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Main {\r\n        - Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT\r\n        + WeaponDefinition[] weaponDefinitions\r\n        + WeaponDefinition GET_WEAPON_DEFINITION(eWeaponType wt)\r\n        + Awake()\r\n    }\r\n    \r\n    class Weapon {\r\n        - eWeaponType _type\r\n        - WeaponDefinition def\r\n        - float nextShotTime\r\n        - GameObject weaponModel\r\n        + SetType(eWeaponType type)\r\n    }\r\n\r\n    class WeaponDefinition {\r\n        + eWeaponType type\r\n        + GameObject weaponModelPrefab\r\n        + GameObject projectilePrefab\r\n        + float delayBetweenShots\r\n        + float velocity\r\n    }\r\n\r\n    class eWeaponType {\r\n        <<enumeration>>\r\n        none\r\n        blaster\r\n        spread\r\n    }\r\n\r\n    Main --> WeaponDefinition : \"管理\"\r\n    Weapon --> WeaponDefinition : \"获取和应用\"\r\n    Main --> eWeaponType : \"依赖\"\r\n    Weapon --> eWeaponType : \"依赖\"\r\n    WeaponDefinition --> eWeaponType : \"定义\"\r\n  WeaponDefinition --> weaponModelPrefab: \"管理预制件\"\r\n  WeaponDefinition --> projectilePrefab: \"管理预制件\"</pre>\r\n<p>在本系统中, 武器被实现为一个可以通过类型枚举来配置武器行为的对象.\r\n武器对象是一直存在的, 会根据类型的切换改变表现的形态.</p>\r\n<p>武器的具体参数又保存在具体的武器定义类中. 不仅仅是数值参数,\r\n还有模型预制体参数和子弹预制体参数.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类型的枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> eWeaponType &#123;</span><br><span class=\"line\">    none,       <span class=\"comment\">// 无</span></span><br><span class=\"line\">    blaster,    <span class=\"comment\">// 爆能枪</span></span><br><span class=\"line\">    spread,     <span class=\"comment\">// 散射枪</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 武器定义类，描述每种武器的属性</span></span><br><span class=\"line\">[<span class=\"meta\">System.Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">WeaponDefinition</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type = eWeaponType.none;  <span class=\"comment\">// 武器类型，默认无</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;附加到玩家飞船上的武器模型预制件&quot;</span>)</span>]  <span class=\"comment\">// 提示：武器模型的预制件</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject weaponModelPrefab;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;发射的投射物预制件&quot;</span>)</span>]  <span class=\"comment\">// 提示：发射的投射物的预制件</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject projectilePrefab;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;每次射击之间的延迟秒数&quot;</span>)</span>]  <span class=\"comment\">// 提示：射击间隔时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> delayBetweenShots = <span class=\"number\">0</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;单个投射物的速度&quot;</span>)</span>]  <span class=\"comment\">// 提示：投射物速度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> velocity = <span class=\"number\">50</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>所有的武器定义类被保存在Main对象中, 便于统一修改.</p>\r\n<p>使用一个列表weaponDefinitions来保存所有的武器定义类,\r\n在Unity中进行修改.</p>\r\n<figure>\r\n<img src=\"image%209.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>然后在Main脚本激活时将weaponDefinitions中的参数保存到字典Dictionary&lt;eWeaponType,\r\nWeaponDefinition&gt; WEAP_DICT中,\r\n这样就可以通过GET_WEAPON_DEFINITION()方法,\r\n在具体武器类想要获得具体武器参数是获得在Unity中写好的配置.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine.SceneManagement;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Random = UnityEngine.Random;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Main</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Main S;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Dictionary&lt;eWeaponType, WeaponDefinition&gt; WEAP_DICT;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> WeaponDefinition[] weaponDefinitions;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//单例模式</span></span><br><span class=\"line\">        S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        bndCheck = GetComponent&lt;BoundsCheck&gt;();</span><br><span class=\"line\">        Invoke(<span class=\"keyword\">nameof</span>(SpawnEnemy), <span class=\"number\">1f</span> / enemySpawnPerSecond);</span><br><span class=\"line\">        WEAP_DICT = <span class=\"keyword\">new</span> Dictionary&lt;eWeaponType, WeaponDefinition&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (WeaponDefinition def <span class=\"keyword\">in</span> weaponDefinitions) &#123; WEAP_DICT[def.type] = def; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> WeaponDefinition <span class=\"title\">GET_WEAPON_DEFINITION</span>(<span class=\"params\">eWeaponType wt</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (WEAP_DICT.ContainsKey(wt)) <span class=\"keyword\">return</span> WEAP_DICT[wt];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WeaponDefinition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>通过在具体武器类中保存武器类型定义类eWeaponType _type,\r\n每次修改类型时, 武器对象通过Main.GET_WEAPON_DEFINITION(_type);\r\n方法更新武器的定义, 从而加载不同的模型, 以及获取一些武器参数.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> eWeaponType _type = eWeaponType.none;  <span class=\"comment\">// 当前武器类型，默认无</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> WeaponDefinition def;   <span class=\"comment\">// 武器定义</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> GameObject weaponModel; <span class=\"comment\">// 武器模型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        SetType(_type);  <span class=\"comment\">// 设置武器类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 武器类型的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> _type; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; SetType(<span class=\"keyword\">value</span>); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置武器类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType type</span>)</span> &#123;</span><br><span class=\"line\">        _type = type;</span><br><span class=\"line\"></span><br><span class=\"line\">        def = Main.GET_WEAPON_DEFINITION(_type);  <span class=\"comment\">// 获取武器的定义</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果已有武器模型，销毁它</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (weaponModel != <span class=\"literal\">null</span>) Destroy(weaponModel);</span><br><span class=\"line\">        <span class=\"comment\">// 实例化新的武器模型</span></span><br><span class=\"line\">        weaponModel = Instantiate&lt;GameObject&gt;(def.weaponModelPrefab, transform);</span><br><span class=\"line\">        weaponModel.transform.localPosition = Vector3.zero;</span><br><span class=\"line\">        weaponModel.transform.localScale = Vector3.one;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>图示</p>\r\n<h3 id=\"weapon对象载入\">Weapon对象载入</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Weapon {\r\n        - eWeaponType _type\r\n        + SetType(eWeaponType type)\r\n    }\r\n    class Hero{\r\n      + Weapon[] weapons\r\n      + ClearWeapons()\r\n    }\r\n    class eWeaponType {\r\n        <<enumeration>>\r\n        none\r\n        blaster\r\n        spread\r\n    }\r\n    Weapon --> eWeaponType :依赖\r\n    Hero--> eWeaponType :依赖\r\n    Hero--> Weapon :管理</pre>\r\n<p>武器的实际挂载对象是玩家飞船, 通过Hero脚本进行管理.</p>\r\n<p>在游戏场景的Hero游戏对象上, 有五个子游戏对象hardpoint,\r\n每个绑定在玩家飞船的不同位置上,\r\n然后在游戏对象hardpoint上有子游戏对象Weapon预制件实例,\r\nWeapon脚本作为Weapon预制件的组件, Hero脚本作为Hero游戏对象的组件.\r\n在Hero脚本中有Weapon列表, 绑定这些Weapon预制件实例来进行管理.</p>\r\n<p>通过调用Weapon.SetType(eWeaponType),\r\n就可以设置具体的Weapon预制件实例的类型.</p>\r\n<p>ClearWeapons()方法可以将所有的Weapon预制件实例类型改为eWeaponType.none.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Weapon[] weapons;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (S == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;Hero.Awake() - Attempted to assign second Hero.S!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ClearWeapons();</span><br><span class=\"line\">        weapons[<span class=\"number\">0</span>].SetType(eWeaponType.blaster);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ClearWeapons</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Weapon w <span class=\"keyword\">in</span> weapons) &#123;</span><br><span class=\"line\">            w.SetType(eWeaponType.none);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"weapon开火\">Weapon开火</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Weapon {\r\n        +WeaponDefinition def\r\n        +float nextShotTime\r\n        +Transform shotPointTrans\r\n        +Start()\r\n        +Fire()\r\n        +MakeProjectile()\r\n    }\r\n    \r\n    class ProjectileHero {\r\n        +Rigidbody rigid\r\n        +BoundsCheck boundsCheck\r\n        +Renderer rend\r\n        +eWeaponType type\r\n        +SetType(eWeaponType eType)\r\n        +Vector3 vel\r\n        +Awake()\r\n        +Update()\r\n    }\r\n\r\n    class WeaponDefinition {\r\n        +GameObject projectilePrefab\r\n        +float delayBetweenShots\r\n        +float velocity\r\n        +Color projectileColor\r\n    }\r\n\r\n    Weapon --> ProjectileHero : \"生成弹药实例\"\r\n    ProjectileHero --> WeaponDefinition : \"获取弹药定义\"\r\n    Weapon --> WeaponDefinition : \"根据武器类型获取参数\"\r\n    ProjectileHero --> Rigidbody : \"控制物理运动\"\r\n    ProjectileHero --> BoundsCheck : \"检测屏幕外销毁\"</pre>\r\n<p>对于每一个Weapon游戏对象实例,\r\n由Weapon预制体的子对象ShotPoint提供射击点, 也就是弹药生成的位置.</p>\r\n<p>Weapon 脚本通过WeaponDefinition def上保存的武器定义,\r\n来获取弹药的参数, 包括弹药预制体和弹药速度等.</p>\r\n<p>Fire()方法作为Weapon的开火方法, 当被触发时, 根据保存的武器类型,\r\n进行相对应的弹药生成方法. 例如blaster就生成一个弹药,\r\nspread就生成三个弹药. 弹药</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> WeaponDefinition def;   <span class=\"comment\">// 武器定义</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> nextShotTime;     <span class=\"comment\">// 下一次射击的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Transform shotPointTrans; <span class=\"comment\">// 射击点的Transform</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        shotPointTrans = transform.GetChild(<span class=\"number\">0</span>);  <span class=\"comment\">// 获取子物体的Transform作为射击点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 触发射击</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Fire</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Time.time &lt; nextShotTime) <span class=\"keyword\">return</span>;  <span class=\"comment\">// 如果还没到下一次射击时间，返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ProjectileHero projectileHero;  <span class=\"comment\">// 投射物</span></span><br><span class=\"line\">        Vector3 vel = Vector3.up * def.velocity;  <span class=\"comment\">// 投射物速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据武器类型发射不同的投射物</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.blaster:  <span class=\"comment\">// 爆能枪</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();  <span class=\"comment\">// 创建投射物</span></span><br><span class=\"line\">                projectileHero.vel = vel;  <span class=\"comment\">// 设置投射物速度</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.spread:  <span class=\"comment\">// 散射武器</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.vel = vel;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 创建左侧散射投射物</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.transform.rotation = Quaternion.AngleAxis(<span class=\"number\">10</span>, Vector3.back);</span><br><span class=\"line\">                projectileHero.vel = projectileHero.transform.rotation * vel;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 创建右侧散射投射物</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.transform.rotation = Quaternion.AngleAxis(<span class=\"number\">-10</span>, Vector3.back);</span><br><span class=\"line\">                projectileHero.vel = projectileHero.transform.rotation * vel;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建投射物实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ProjectileHero <span class=\"title\">MakeProjectile</span>()</span> &#123;</span><br><span class=\"line\">        GameObject gameObject = Instantiate&lt;GameObject&gt;(def.projectilePrefab, PROJECTILE_ANCHOR);  <span class=\"comment\">// 实例化投射物</span></span><br><span class=\"line\">        ProjectileHero projectileHero = gameObject.GetComponent&lt;ProjectileHero&gt;();  <span class=\"comment\">// 获取投射物组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 pos = shotPointTrans.position;  <span class=\"comment\">// 获取射击点的位置</span></span><br><span class=\"line\">        pos.z = <span class=\"number\">0</span>;  <span class=\"comment\">// 设置Z轴为0</span></span><br><span class=\"line\">        projectileHero.transform.position = pos;  <span class=\"comment\">// 设置投射物位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        projectileHero.type = type;  <span class=\"comment\">// 设置投射物类型</span></span><br><span class=\"line\">        nextShotTime = Time.time + def.delayBetweenShots;  <span class=\"comment\">// 设置下一次射击的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> projectileHero;  <span class=\"comment\">// 返回投射物实例</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>弹药ProjectileHero 实例由Weapon生成,</p>\r\n<p>由Weapon控制其速度, 由刚体组件控制其运动,</p>\r\n<p>由BoundsCheck组件提供是否飞出屏幕, 判断销毁,</p>\r\n<p>由Enemy判断碰撞逻辑销毁.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BoundsCheck boundsCheck;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Renderer rend;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Dynamic&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Rigidbody rigid;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> eWeaponType _type;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> _type; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; SetType(<span class=\"keyword\">value</span>); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType eType</span>)</span> &#123;</span><br><span class=\"line\">        _type = eType;</span><br><span class=\"line\">        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(_type);</span><br><span class=\"line\">        rend.material.color = def.projectileColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector3 vel &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> rigid.velocity; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; rigid.velocity = <span class=\"keyword\">value</span>; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        boundsCheck = GetComponent&lt;BoundsCheck&gt;();</span><br><span class=\"line\">        rend = GetComponent&lt;Renderer&gt;();</span><br><span class=\"line\">        rigid = GetComponent&lt;Rigidbody&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boundsCheck.LocIs(BoundsCheck.eScreenLocs.offTop)) &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"hero开火事件\">Hero开火事件</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Hero {\r\n        +delegate WeaponFireDelegate\r\n        +event WeaponFireDelegate fireEvent\r\n        +Update() \"检测开火输入\"\r\n    }\r\n    \r\n    class Weapon {\r\n        +Start()\r\n        +Fire()\"触发射击\"\r\n    }\r\n\r\n    Hero o-- Weapon : \"注册开火事件\"\r\n    Hero : +fireEvent()\r\n    Weapon --> Hero : \"fireEvent 事件触发\"</pre>\r\n<p>Weapon的开火事件由Hero控制触发.</p>\r\n<p>在Hero上保存有委托fireEvent, 每帧检测是否有开火控制型号,\r\n然后触发fireEvent.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">WeaponFireDelegate</span>()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> WeaponFireDelegate fireEvent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Input.GetAxis(<span class=\"string\">&quot;Jump&quot;</span>) == <span class=\"number\">1</span> &amp;&amp; fireEvent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            fireEvent();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>在Weapon上注册事件, 将Weapon的Fire方法绑定到Hero的fireEvent上.</p>\r\n<p>这样当Hero触发开火时, 所有的Weapon都会开火.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果该武器附加在玩家上，注册射击事件</span></span><br><span class=\"line\">        Hero hero = GetComponentInParent&lt;Hero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hero != <span class=\"literal\">null</span>) hero.fireEvent += Fire;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 触发射击</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Fire</span>()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"powerup\">PowerUp</h2>\r\n<p>升级道具由Enemy死亡掉落, 可以触发Weapon改变</p>\r\n<h3 id=\"powerup生成\">PowerUp生成</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Enemy {\r\n        +OnCollisionEnter(Collision coll)\r\n        +bool calledShipDestroyed\r\n    }\r\n    \r\n    class PowerUp {\r\n        +eWeaponType type\r\n        +SetType(eWeaponType wt)\r\n    }\r\n    \r\n    class Main {\r\n        +static Main S\r\n        +GameObject prefabPowerUp\r\n        +eWeaponType[] powerUpFrequency\r\n        +static void SHIP_DESTROYED(Enemy e)\r\n    }\r\n\r\n    Enemy --> Main : \"通知SHIP_DESTROYED\"\r\n    Main --> PowerUp : \"生成PowerUp\"\r\n    PowerUp : +SetType()</pre>\r\n<p>PowerUp有其类型, 对应武器类型.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PowerUp</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Dynamic&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType _type;          <span class=\"comment\">// PowerUp 的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> birthTime;     <span class=\"comment\">// PowerUp 实例化时的 Time.time</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        birthTime = Time.time; <span class=\"comment\">// 记录实例化时的时间</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// PowerUp 类型的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type &#123; <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> _type; &#125; <span class=\"keyword\">set</span> &#123; SetType(<span class=\"keyword\">value</span>); &#125; &#125; <span class=\"comment\">// h</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置 PowerUp 类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType wt</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 Main 中获取武器定义</span></span><br><span class=\"line\">        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(wt);</span><br><span class=\"line\">        cubeMat.color = def.powerUpColor;  <span class=\"comment\">// 设置 PowerCube 的颜色</span></span><br><span class=\"line\">        letter.text = def.letter;          <span class=\"comment\">// 设置显示的字母</span></span><br><span class=\"line\">        _type = wt;                         <span class=\"comment\">// 最终设置类型</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>为了使系统保持简洁, 也就是可以生成实例的类不要太多,\r\n这里吧生成PowerUP的职责放在Main中.</p>\r\n<p>当Enemy被销毁时, 通知Main. 使用Main.SHIP_DESTROYED(this);</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnCollisionEnter</span>(<span class=\"params\">Collision coll</span>)</span> &#123;</span><br><span class=\"line\">        GameObject otherGO = coll.gameObject;</span><br><span class=\"line\">        ProjectileHero projectileHero = otherGO.GetComponent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (projectileHero != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bndCheck.isOnScreen) &#123;</span><br><span class=\"line\">                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (health &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!calledShipDestroyed) &#123;</span><br><span class=\"line\">                        calledShipDestroyed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        Main.SHIP_DESTROYED(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Destroy(gameObject);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Destroy(otherGO);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.Log(<span class=\"string\">&quot;Enemy hit by non-ProjectileHero: &quot;</span> + otherGO.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>Main中保存有PowerUP预制体, 以及一个eWeaponType列表,\r\n用来控制PowerUP生成类型的概率.</p>\r\n<p>当Main.SHIP_DESTROYED被触发时, 生成PowerUP并设定类型.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Random = UnityEngine.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Main</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Main S;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject prefabPowerUp;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType[] powerUpFrequency = <span class=\"keyword\">new</span> eWeaponType[]&#123;</span><br><span class=\"line\">        eWeaponType.blaster,</span><br><span class=\"line\">        eWeaponType.blaster,</span><br><span class=\"line\">        eWeaponType.spread,</span><br><span class=\"line\">        eWeaponType.shield,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SHIP_DESTROYED</span>(<span class=\"params\">Enemy e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 有可能生成一个PowerUp</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Random.<span class=\"keyword\">value</span> &lt;= e.powerUpDropChance) &#123;  <span class=\"comment\">// 有一定几率生成 PowerUp</span></span><br><span class=\"line\">            <span class=\"comment\">// 从powerUpFrequency数组中选择一个PowerUp类型</span></span><br><span class=\"line\">            eWeaponType pUpType = S.powerUpFrequency[Random.Range(<span class=\"number\">0</span>, S.powerUpFrequency.Length)];  <span class=\"comment\">// 选择 PowerUp 类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 生成一个PowerUp对象</span></span><br><span class=\"line\">            GameObject go = Instantiate&lt;GameObject&gt;(S.prefabPowerUp);  <span class=\"comment\">// 实例化 PowerUp 对象</span></span><br><span class=\"line\">            PowerUp pUp = go.GetComponent&lt;PowerUp&gt;();  <span class=\"comment\">// 获取 PowerUp 脚本组件</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置生成的PowerUp为选定的武器类型</span></span><br><span class=\"line\">            pUp.SetType(pUpType);  <span class=\"comment\">// 设置 PowerUp 的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 设置 PowerUp 的位置为被摧毁的飞船的位置</span></span><br><span class=\"line\">            pUp.transform.position = e.transform.position;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"powerup触发\">PowerUp触发</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Hero {\r\n        +void OnTriggerEnter(Collider other)\r\n        +void AbsorbPowerUp(PowerUp powerUp)\r\n    }\r\n    \r\n    class PowerUp {\r\n        +eWeaponType type\r\n        +void AbsorbedBy(GameObject go) \r\n    }\r\n\r\n    class Weapon {\r\n        +void SetType(eWeaponType type)\r\n    }\r\n\r\n    Hero --> PowerUp : \"碰撞检测\"\r\n    Hero --> Weapon : \"改变武器类型\"\r\n    PowerUp --> Hero : \"触发PowerUp效果\"\r\n    PowerUp : +type \"PowerUp类型\"</pre>\r\n<p>当PowerUP被Hero碰撞后, 被消化使用. 在Hero中判断powerUp.type,\r\n根据具体类型产生不同效果, 同时销毁powerUp.</p>\r\n<p>若powerUp.type为一种武器, 触发weapon.SetType(powerUp.type),\r\n到Weapon类型被改变.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> GameObject lastTriggerGo = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnTriggerEnter</span>(<span class=\"params\">Collider other</span>)</span> &#123;</span><br><span class=\"line\">        Transform rootT = other.gameObject.transform.root;</span><br><span class=\"line\">        GameObject gameObject = rootT.gameObject;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (gameObject == lastTriggerGo) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        lastTriggerGo = gameObject;</span><br><span class=\"line\"></span><br><span class=\"line\">        Enemy enemy = gameObject.GetComponent&lt;Enemy&gt;();</span><br><span class=\"line\">        PowerUp powerUp = gameObject.GetComponent&lt;PowerUp&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            shieldLevel--;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (powerUp != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            AbsorbPowerUp(powerUp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">&quot;Shield trigger hit by non-Enemy: &quot;</span> + gameObject.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AbsorbPowerUp</span>(<span class=\"params\">PowerUp powerUp</span>)</span> &#123;</span><br><span class=\"line\">        Debug.Log(<span class=\"string\">&quot;Absorbed PowerUp: &quot;</span> + powerUp.type);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (powerUp.type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.shield:</span><br><span class=\"line\">                shieldLevel++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"literal\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (powerUp.type == weapons[<span class=\"number\">0</span>].type) &#123;</span><br><span class=\"line\">                    Weapon weapon = GetEmptyWeaponSlot();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (weapon != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        weapon.SetType(powerUp.type);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ClearWeapons();</span><br><span class=\"line\">                    weapons[<span class=\"number\">0</span>].SetType(powerUp.type);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        powerUp.AbsorbedBy(gameObject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>当PowerUP被触发时, 销毁自己</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PowerUp</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AbsorbedBy</span>(<span class=\"params\">GameObject target</span>)</span> &#123;</span><br><span class=\"line\">        Destroy(<span class=\"keyword\">this</span>.gameObject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"视觉效果\">视觉效果</h1>\r\n<h2 id=\"飞船运动倾角\">飞船运动倾角</h2>\r\n<h3 id=\"hero中的应用\">Hero中的应用</h3>\r\n<p>移动时, 根据虚拟轴输入, 计算旋转角度</p>\r\n<figure>\r\n<img src=\"image%2010.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"image%2011.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> maxSpeed = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> rollMult = <span class=\"number\">-45</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> pitchMult = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> hAxis = Input.GetAxis(<span class=\"string\">&quot;Horizontal&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">float</span> vAxis = Input.GetAxis(<span class=\"string\">&quot;Vertical&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        transform.rotation = Quaternion.Euler(vAxis * pitchMult, hAxis * rollMult, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy_1中的应用\">Enemy_1中的应用</h3>\r\n<p>移动时, 根据侧向偏移量, 计算旋转角度</p>\r\n<figure>\r\n<img src=\"image%2012.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_1</span> : <span class=\"title\">Enemy</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_1 Inscribed Fields&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;# of seconds for a full sine wave&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveFrequency = <span class=\"number\">2</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Sine wave width in meters&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveWidth = <span class=\"number\">6</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Amount the ship will roll left and right with the sine wave&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveRotY = <span class=\"number\">45</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> x0;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        x0 = pos.x;</span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        Vector3 tempPos = pos;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> age = Time.time - birthTime;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> theta = Mathf.PI * <span class=\"number\">2</span> * age / waveFrequency;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> sin = Mathf.Sin(theta);</span><br><span class=\"line\">        tempPos.x = x0 + sin * waveWidth;</span><br><span class=\"line\">        pos = tempPos;</span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 rot = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, sin * waveRotY, <span class=\"number\">0</span>);</span><br><span class=\"line\">        transform.rotation = Quaternion.Euler(rot);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">base</span>.Move();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// print(bndCheck.isOnScreen);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy_2中的应用\">Enemy_2中的应用</h3>\r\n<p>移动时, 根据AnimationCurve 曲线, 计算旋转角度</p>\r\n<figure>\r\n<img src=\"image%2013.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_2</span> : <span class=\"title\">Enemy</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_2 Inscribed Field&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> lifeTime = <span class=\"number\">10f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;波幅控制&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> sinEccentricity = <span class=\"number\">0.6f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AnimationCurve rotCurve;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_2 Private Fields&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Quaternion baseRotation;</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> Vector3 p0, p1;<span class=\"comment\">//插值控制点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        p0 = Vector3.zero;</span><br><span class=\"line\">        p0.x = -bndCheck.camWidth - bndCheck.radius;</span><br><span class=\"line\">        p0.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">        p1 = Vector3.zero;</span><br><span class=\"line\">        p1.x = bndCheck.camWidth + bndCheck.radius;</span><br><span class=\"line\">        p1.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Random.<span class=\"keyword\">value</span> &gt; <span class=\"number\">0.5f</span>) &#123;</span><br><span class=\"line\">            p0.x *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">            p1.x *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\"></span><br><span class=\"line\">        transform.position = p0;</span><br><span class=\"line\">        transform.LookAt(p1, Vector3.back);</span><br><span class=\"line\">        baseRotation = transform.rotation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> u = (Time.time - birthTime) / birthTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> shipRot = rotCurve.Evaluate(u) * <span class=\"number\">360</span>;</span><br><span class=\"line\">        transform.rotation = baseRotation * Quaternion.Euler(-shipRot, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        u = u + sinEccentricity * Mathf.Sin(u * Mathf.PI * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pos = (<span class=\"number\">1</span> - u) * p0 + u * p1;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"平滑移动路径\">平滑移动路径</h2>\r\n<h3 id=\"贝塞尔曲线\">贝塞尔曲线</h3>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Utils</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 递归计算任意数量控制点的 Bézier 曲线上的点</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=&quot;t&quot;&gt;</span>插值比例 [0..1]<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=&quot;points&quot;&gt;</span>控制点数组<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span>曲线上的插值点<span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Vector3 <span class=\"title\">Bezier</span>(<span class=\"params\"><span class=\"built_in\">float</span> t, <span class=\"keyword\">params</span> Vector3[] points</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当只有一个控制点时，返回该控制点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (points.Length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> points[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 LINQ 的 Select 和 Zip 进行插值计算</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bezier(t, points.Take(points.Length - <span class=\"number\">1</span>)</span><br><span class=\"line\">                               .Zip(points.Skip(<span class=\"number\">1</span>), (p0, p1) =&gt; Vector3.LerpUnclamped(p0, p1, t))</span><br><span class=\"line\">                               .ToArray());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy_3中的应用\">Enemy_3中的应用</h3>\r\n<figure>\r\n<img src=\"image%2014.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_3</span> : <span class=\"title\">Enemy</span> &#123;            <span class=\"comment\">// Enemy_3 继承自 Enemy 类</span></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_3 公共字段&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> lifeTime = <span class=\"number\">5</span>;            <span class=\"comment\">// 生命时长为5秒</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector2 midpointYRange = <span class=\"keyword\">new</span> Vector2(<span class=\"number\">1.5f</span>, <span class=\"number\">3</span>);   <span class=\"comment\">// 中间点Y轴范围</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;如果为true,则在Scene面板中绘制Bézier点和路径。&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> drawDebugInfo = <span class=\"literal\">true</span>;     <span class=\"comment\">// 是否绘制调试信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_3 私有字段&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Vector3[] points;  <span class=\"comment\">// Bézier曲线的三个点</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;   <span class=\"comment\">// 记录生成时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Start方法,因父类Enemy未使用,所以可以在此处使用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        points = <span class=\"keyword\">new</span> Vector3[<span class=\"number\">3</span>];  <span class=\"comment\">// 初始化三个控制点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 起始位置已经由 Main.SpawnEnemy() 设置</span></span><br><span class=\"line\">        points[<span class=\"number\">0</span>] = pos;  <span class=\"comment\">// 第一个点是当前敌人的初始位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置x轴的最小和最大值,和Main.SpawnEnemy()方式一致</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> xMin = -bndCheck.camWidth + bndCheck.radius;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> xMax = bndCheck.camWidth - bndCheck.radius;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 随机选择屏幕下半部分的一个中间点</span></span><br><span class=\"line\">        points[<span class=\"number\">1</span>] = Vector3.zero;  <span class=\"comment\">// 初始化第二个点</span></span><br><span class=\"line\">        points[<span class=\"number\">1</span>].x = Random.Range(xMin, xMax);  <span class=\"comment\">// x轴随机范围</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> midYMult = Random.Range(midpointYRange[<span class=\"number\">0</span>], midpointYRange[<span class=\"number\">1</span>]);  <span class=\"comment\">// 随机Y轴比例  // a</span></span><br><span class=\"line\">        points[<span class=\"number\">1</span>].y = -bndCheck.camHeight * midYMult;  <span class=\"comment\">// 设置Y轴位置  // a</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 随机选择屏幕上方的一个最终点</span></span><br><span class=\"line\">        points[<span class=\"number\">2</span>] = Vector3.zero;  <span class=\"comment\">// 初始化第三个点</span></span><br><span class=\"line\">        points[<span class=\"number\">2</span>].y = pos.y;       <span class=\"comment\">// Y轴保持在初始位置上方</span></span><br><span class=\"line\">        points[<span class=\"number\">2</span>].x = Random.Range(xMin, xMax);  <span class=\"comment\">// x轴随机范围</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置出生时间为当前时间</span></span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果需要绘制调试信息,则调用DrawDebug方法  // b</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (drawDebugInfo) DrawDebug();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Bézier曲线基于u值,u的范围在0到1之间</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> u = (Time.time - birthTime) / lifeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果u超过1,表示该敌人生命周期已结束</span></span><br><span class=\"line\">            Destroy(<span class=\"keyword\">this</span>.gameObject);  <span class=\"comment\">// 销毁游戏对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据u值旋转对象  // c</span></span><br><span class=\"line\">        transform.rotation = Quaternion.Euler(u * <span class=\"number\">180</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 插值计算Bézier曲线上的三个点  // d</span></span><br><span class=\"line\">        u = u - <span class=\"number\">0.1f</span> * Mathf.Sin(u * Mathf.PI * <span class=\"number\">2</span>);</span><br><span class=\"line\">        pos = Utils.Bezier(u, points);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Enemy_3 不调用父类的Move()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制调试信息,包括Bézier曲线和控制点  // e</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DrawDebug</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 绘制三个控制点之间的直线</span></span><br><span class=\"line\">        Debug.DrawLine(points[<span class=\"number\">0</span>], points[<span class=\"number\">1</span>], Color.cyan, lifeTime);  <span class=\"comment\">// 绘制第1到第2个点的线  // f</span></span><br><span class=\"line\">        Debug.DrawLine(points[<span class=\"number\">1</span>], points[<span class=\"number\">2</span>], Color.yellow, lifeTime); <span class=\"comment\">// 绘制第2到第3个点的线</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绘制Bézier曲线</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> numSections = <span class=\"number\">20</span>;  <span class=\"comment\">// 曲线分为20段</span></span><br><span class=\"line\">        Vector3 prevPoint = points[<span class=\"number\">0</span>];  <span class=\"comment\">// 上一个点,初始化为第一个控制点  // g</span></span><br><span class=\"line\">        Color col;</span><br><span class=\"line\">        Vector3 pt;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt; numSections; i++) &#123;  <span class=\"comment\">// 绘制Bézier曲线的各段  // h</span></span><br><span class=\"line\">            <span class=\"built_in\">float</span> u = i / numSections;  <span class=\"comment\">// u的值在0到1之间变化</span></span><br><span class=\"line\">            pt = Utils.Bezier(u, points);  <span class=\"comment\">// 计算当前插值点</span></span><br><span class=\"line\">            col = Color.Lerp(Color.cyan, Color.yellow, u);  <span class=\"comment\">// 根据u值插值颜色</span></span><br><span class=\"line\">            Debug.DrawLine(prevPoint, pt, col, lifeTime);  <span class=\"comment\">// 绘制前一个点到当前点的线  // i</span></span><br><span class=\"line\">            prevPoint = pt;  <span class=\"comment\">// 更新上一个点为当前点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"敌人受击反馈\">敌人受击反馈</h2>\r\n<p>新建受击组件</p>\r\n<p>保存所有子对象材质</p>\r\n<p>检测碰撞, 当被子弹命中时改变材质, 产生效果.</p>\r\n<p>效果根据时间消失.</p>\r\n<figure>\r\n<img src=\"image%2015.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">DisallowMultipleComponent</span>]  <span class=\"comment\">// 不允许在同一个GameObject上添加多个该组件  // a</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BlinkColorOnHit</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"built_in\">float</span> blinkDuration = <span class=\"number\">0.1f</span>;  <span class=\"comment\">// 闪烁颜色的持续时间（以秒为单位）  // b</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Color blinkColor = Color.red;  <span class=\"comment\">// 受击时显示的颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;动态参数&quot;</span>)</span>]  <span class=\"comment\">// 在Inspector面板中分类显示动态参数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> showingColor = <span class=\"literal\">false</span>;  <span class=\"comment\">// 是否正在显示闪烁颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> blinkCompleteTime;    <span class=\"comment\">// 恢复原始颜色的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> ignoreOnCollisionEnter = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Material[] materials;      <span class=\"comment\">// 当前GameObject及其子对象的所有材质</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Color[] originalColors;    <span class=\"comment\">// 材质的原始颜色数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BoundsCheck bndCheck;      <span class=\"comment\">// 用于检测对象是否在屏幕范围内的组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        bndCheck = GetComponentInParent&lt;BoundsCheck&gt;();  <span class=\"comment\">// 获取父对象上的BoundsCheck组件  // c</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取该GameObject及其所有子对象的材质</span></span><br><span class=\"line\">        materials = Utils.GetAllMaterials(gameObject);    <span class=\"comment\">// d</span></span><br><span class=\"line\">        <span class=\"comment\">// 存储每个材质的原始颜色</span></span><br><span class=\"line\">        originalColors = materials.Select(m =&gt; m.color).ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在显示闪烁颜色且当前时间超过了恢复颜色的时间，恢复原始颜色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (showingColor &amp;&amp; Time.time &gt; blinkCompleteTime) RevertColors();  <span class=\"comment\">// e</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnCollisionEnter</span>(<span class=\"params\">Collision coll</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreOnCollisionEnter) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有BoundsCheck且对象不在屏幕内，跳过受击显示</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bndCheck != <span class=\"literal\">null</span> &amp;&amp; !bndCheck.isOnScreen) &#123;  <span class=\"comment\">// g</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  <span class=\"comment\">// 当对象不在屏幕内时，不显示受击效果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 检测与ProjectileHero的碰撞</span></span><br><span class=\"line\">        ProjectileHero p = coll.gameObject.GetComponent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p != <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 如果碰撞对象是ProjectileHero  // f</span></span><br><span class=\"line\"></span><br><span class=\"line\">            SetColors();  <span class=\"comment\">// 显示受击颜色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 将所有材质的主颜色设置为闪烁颜色，并设置显示颜色的时间</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetColors</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Material m <span class=\"keyword\">in</span> materials) &#123;</span><br><span class=\"line\">            m.color = blinkColor;  <span class=\"comment\">// 将材质颜色设置为闪烁颜色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        showingColor = <span class=\"literal\">true</span>;  <span class=\"comment\">// 标记正在显示颜色</span></span><br><span class=\"line\">        blinkCompleteTime = Time.time + blinkDuration;  <span class=\"comment\">// 设置颜色恢复的时间</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 恢复所有材质的原始颜色，并停止显示颜色</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RevertColors</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; materials.Length; i++) &#123;</span><br><span class=\"line\">            materials[i].color = originalColors[i];  <span class=\"comment\">// 恢复原始颜色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        showingColor = <span class=\"literal\">false</span>;  <span class=\"comment\">// 标记颜色显示结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"无缝太空背景\">无缝太空背景</h2>\r\n<p>滚动数组思想.</p>\r\n<p>使用两块背景, 循环播放, 当一张移出屏幕后, 接替到另一张上面.</p>\r\n<figure>\r\n<img src=\"image%2016.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Parallax</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform playerTrans; <span class=\"comment\">// The player ship (玩家飞船)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform[] panels; <span class=\"comment\">// The scrolling foregrounds (滚动的前景面板)</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Speed at which the panels move in Y&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> scrollSpeed = <span class=\"number\">-30f</span>; <span class=\"comment\">// 面板在Y轴上的滚动速度</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Controls how much panels react to player movement (Default 0.25)&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> motionMult = <span class=\"number\">0.25f</span>; <span class=\"comment\">// 控制面板对玩家移动的反应程度 (默认值 0.25)   // a</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> panelHt; <span class=\"comment\">// Height of each panel (每个面板的高度)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> depth;   <span class=\"comment\">// Depth of panels (that is, pos.z) (面板的深度，即z轴位置)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        panelHt = panels[<span class=\"number\">0</span>].localScale.y; <span class=\"comment\">// 获取第一个面板的高度</span></span><br><span class=\"line\">        depth = panels[<span class=\"number\">0</span>].position.z; <span class=\"comment\">// 获取面板的深度（z轴位置）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set initial positions of panels (设置面板的初始位置)</span></span><br><span class=\"line\">        panels[<span class=\"number\">0</span>].position = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, depth); <span class=\"comment\">// 第一个面板位于起点</span></span><br><span class=\"line\">        panels[<span class=\"number\">1</span>].position = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, panelHt, depth); <span class=\"comment\">// 第二个面板位于第一个面板上方</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> tY, tX = <span class=\"number\">0</span>; <span class=\"comment\">// 定义用于计算面板位置的变量</span></span><br><span class=\"line\">        tY = Time.time * scrollSpeed % panelHt + (panelHt * <span class=\"number\">0.5f</span>); <span class=\"comment\">// 随时间滚动并保证循环衔接   // b</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (playerTrans != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            tX = -playerTrans.transform.position.x * motionMult; <span class=\"comment\">// 根据玩家的x位置调整tX   // c</span></span><br><span class=\"line\">                                                                 <span class=\"comment\">// tY += -poi.transform.position.y * motionMult; // 如果需要，也可以对Y轴进行调整</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Position panels[0] (设置第一个面板的位置)</span></span><br><span class=\"line\">        panels[<span class=\"number\">0</span>].position = <span class=\"keyword\">new</span> Vector3(tX, tY, depth);</span><br><span class=\"line\">        <span class=\"comment\">// Position panels[1] where needed to make a continuous starfield (根据需要设置第二个面板的位置，以实现连续的星空效果)  // d</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tY &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            panels[<span class=\"number\">1</span>].position = <span class=\"keyword\">new</span> Vector3(tX, tY - panelHt, depth); <span class=\"comment\">// 第二个面板在第一个面板的上方</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            panels[<span class=\"number\">1</span>].position = <span class=\"keyword\">new</span> Vector3(tX, tY + panelHt, depth); <span class=\"comment\">// 第二个面板在第一个面板的下方</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"扩展实践\">扩展实践</h1>\r\n<h2 id=\"missile\">Missile</h2>\r\n<p>创建一种新的武器-导弹. 可以在发射后自动跟踪敌人.</p>\r\n<h3 id=\"创建新的武器配置\">创建新的武器配置</h3>\r\n<p>在Main.cs→WeaponDefinitions中创建Missile</p>\r\n<figure>\r\n<img src=\"image%2017.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>在Main.cs→PowerUPfrequency中创建Missile</p>\r\n<figure>\r\n<img src=\"image%2018.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>此时运行游戏</p>\r\n<p>敌人可掉落M道具</p>\r\n<figure>\r\n<img src=\"image%2019.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>拾取后也可正常装备</p>\r\n<figure>\r\n<img src=\"image%2020.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>但此时还没有发射功能</p>\r\n<h3 id=\"添加发射功能\">添加发射功能</h3>\r\n<p>修改Weapon类, 在射击方法中添加处理导弹类型的代码</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 触发射击</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Fire</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据武器类型发射不同的投射物</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 导弹类型</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.missile:</span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.vel = vel;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>此时可以发生导弹类型的弹药, 由上一步配置为红色.</p>\r\n<figure>\r\n<img src=\"image%2021.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"实现目标检测\">实现目标检测</h3>\r\n<p>实现思路</p>\r\n<p>给ProjectileHero创建一个球形碰撞箱来检测敌人</p>\r\n<p>通过向量差值获得指向敌人的向量来修改导弹的速度使其朝向敌人</p>\r\n<p>ProjectileHero已经自身持有一个碰撞箱用来检测是否与敌人碰撞,\r\n所以我们给Missile类型的ProjectileHero创建一个子对象detectionRange,\r\n再在这个子对象detectionRange上添加SphereCollider.</p>\r\n<p>在ProjectileHero上新增代码</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Transform detectionRangeTrans;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType eType</span>)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 如果类型是导弹类型，添加检测范围</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_type == eWeaponType.missile) &#123;</span><br><span class=\"line\">            AddDetectionRange();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加用于检测目标的球形碰撞体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddDetectionRange</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建子对象</span></span><br><span class=\"line\">        GameObject detectionRange = <span class=\"keyword\">new</span> GameObject(<span class=\"string\">&quot;DetectionRange&quot;</span>);</span><br><span class=\"line\">        detectionRangeTrans = detectionRange.transform;</span><br><span class=\"line\">        <span class=\"comment\">// 设置为ProjectileHero的子对象</span></span><br><span class=\"line\">        detectionRangeTrans.SetParent(<span class=\"keyword\">this</span>.transform);</span><br><span class=\"line\">        <span class=\"comment\">// 确保位置和ProjectileHero一致</span></span><br><span class=\"line\">        detectionRangeTrans.localPosition = Vector3.zero;</span><br><span class=\"line\">        <span class=\"comment\">// 设置与ProjectileHero相同的Layer</span></span><br><span class=\"line\">        detectionRangeTrans.gameObject.layer = gameObject.layer;</span><br><span class=\"line\">        <span class=\"comment\">// 添加球形碰撞箱</span></span><br><span class=\"line\">        SphereCollider sphereCollider = detectionRange.AddComponent&lt;SphereCollider&gt;();</span><br><span class=\"line\">        sphereCollider.isTrigger = <span class=\"literal\">true</span>; <span class=\"comment\">// 设置为触发器</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置碰撞体的半径，决定探测范围</span></span><br><span class=\"line\">        sphereCollider.radius = <span class=\"number\">10f</span>; <span class=\"comment\">// 可以根据需要调整半径的大小</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>实现效果, 可见碰撞箱半径</p>\r\n<figure>\r\n<img src=\"image%2022.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"实现目标追踪\">实现目标追踪</h3>\r\n<p>为刚才创建的对象添加一个脚本, 专门用来处理追踪逻辑</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加用于检测目标的球形碰撞体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddDetectionRange</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加一个额外的脚本，用于处理目标检测逻辑</span></span><br><span class=\"line\">        detectionRange.AddComponent&lt;MissileTargetDetector&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>保存变量projectileHero, 用于修改其运动</p>\r\n<p>保存变量enemy 用于确认目标</p>\r\n<p>在OnTriggerEnter中设定目标</p>\r\n<p>在OnTriggerExit中放弃目标</p>\r\n<p>在Update使用线性插值修改速度方向追踪目标</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MissileTargetDetector</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    ProjectileHero projectileHero;</span><br><span class=\"line\">    Enemy enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        projectileHero = gameObject.GetComponentInParent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若目标存在且存活, 修正速度方向, 实现追踪功能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span> &amp;&amp; enemy.gameObject != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            Vector3 origin = projectileHero.rigid.velocity;</span><br><span class=\"line\">            Vector3 direction = (enemy.transform.position - transform.position).normalized * origin.magnitude;</span><br><span class=\"line\">            projectileHero.rigid.velocity = Vector3.Lerp(origin, direction, <span class=\"number\">0.2f</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnTriggerEnter</span>(<span class=\"params\">Collider other</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Debug.LogWarning(&quot;Missile trigger Enter: &quot; + other.name);</span></span><br><span class=\"line\">        <span class=\"comment\">// 若敌人进入范围, 且当前无其他目标, 将该敌人设定为目标</span></span><br><span class=\"line\">        Enemy detectedEnemy = other.gameObject.GetComponent&lt;Enemy&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy == <span class=\"literal\">null</span> &amp;&amp; detectedEnemy != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            enemy = detectedEnemy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnTriggerExit</span>(<span class=\"params\">Collider other</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Debug.LogWarning(&quot;Missile trigger Exit: &quot; + other.name);</span></span><br><span class=\"line\">        <span class=\"comment\">// 若目标存在且脱离追踪范围, 放弃这个目标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span> &amp;&amp; other.gameObject == enemy.gameObject) &#123;</span><br><span class=\"line\">            enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>实现效果, 当导弹靠近目标之后, 会指向目标</p>\r\n<figure>\r\n<img src=\"image%2023.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>发现Bug1, 当导弹跟踪的目标丢失以后会失去速度滞留在地图上</p>\r\n<figure>\r\n<img src=\"image%2024.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>修复: 使用线性插值直接修改速度会改变速度大小, 下文优化追踪方案</p>\r\n<p>发现Bug2, 导弹对Enemy_1没有追踪作用</p>\r\n<p>修复: Enemy_1没有碰撞箱, 添加碰撞箱后功能恢复</p>\r\n<figure>\r\n<img src=\"image%2025.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"优化目标追踪\">优化目标追踪</h3>\r\n<p>将原本的线性插值改变速度方向, 改为旋转导弹的方向, 更加平滑,\r\n视觉表现也更好.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MissileTargetDetector</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> rotationSpeed = <span class=\"number\">4.0f</span>;  <span class=\"comment\">// 控制旋转速度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若目标存在且存活, 修正速度方向, 实现追踪功能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span> &amp;&amp; enemy.gameObject != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算导弹当前朝向与目标之间的旋转</span></span><br><span class=\"line\">            Vector3 targetDirection = (enemy.transform.position - projectileHero.transform.position).normalized;</span><br><span class=\"line\">            Quaternion targetRotation = Quaternion.LookRotation(Vector3.forward, targetDirection);</span><br><span class=\"line\">            <span class=\"comment\">// 平滑地插值旋转到目标方向</span></span><br><span class=\"line\">            projectileHero.transform.rotation = Quaternion.Slerp(</span><br><span class=\"line\">                projectileHero.transform.rotation,</span><br><span class=\"line\">                targetRotation,</span><br><span class=\"line\">                Time.deltaTime * rotationSpeed</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"comment\">// 根据当前朝向更新导弹的速度</span></span><br><span class=\"line\">            projectileHero.vel = projectileHero.transform.up * projectileHero.speed;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>同时在ProjectileHero保存速度的大小, 修复了导弹静止的问题.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> speed;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType eType</span>)</span> &#123;</span><br><span class=\"line\">        speed = def.velocity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"image%2026.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n","excerpt":"<h1 id=\"游戏内容分析\">游戏内容分析</h1>\r\n<p>SHMUP （Shoot 'em up），又称STG，即清版射击游戏,\r\n是一种游戏类型，通常以玩家控制飞行器或角色为基础，目标是消灭敌人并躲避子弹和障碍物。SHMUP游戏通常具有快节奏的动作、丰富的视觉效果和多样化的武器系统。</p>\r\n<figure>\r\n<img src=\"image.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>本项目来自<strong><em>Introduction to Game Design, Prototyping, and\r\nDevelopment</em></strong> 的 Space SHMUP.\r\n含有五种敌人角色和两种武器类型, 玩家需要操纵飞船躲避敌人, 攻击敌人,\r\n当击败敌人时可以获得加成道具.</p>\r\n<h2 id=\"玩家角色\">玩家角色</h2>\r\n<p><img src=\"image%201.png\" alt=\"image.png\" />","more":"###\r\n玩家飞船的意义</p>\r\n<ol type=\"1\">\r\n<li>当游戏开始时出现在地图中</li>\r\n<li>当玩家飞船被消灭后游戏结束</li>\r\n</ol>\r\n<h3 id=\"玩家飞船的能力\">玩家飞船的能力</h3>\r\n<ol type=\"1\">\r\n<li>在地图上移动</li>\r\n<li>控制武器开火</li>\r\n</ol>\r\n<h3 id=\"玩家飞船与其他对象的交互\">玩家飞船与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>碰撞到敌人, 导致自生护盾减少, 当自身无护盾时被消灭</li>\r\n<li>碰撞到加成道具, 导致武器系统发生变化</li>\r\n</ol>\r\n<h2 id=\"敌人角色\">敌人角色</h2>\r\n<figure>\r\n<img src=\"image%202.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>敌人包括五种</p>\r\n<h3 id=\"敌人飞船的意义\">敌人飞船的意义</h3>\r\n<ol type=\"1\">\r\n<li><p>根据游戏时间进行, 敌人飞船会随机在地图中生成,\r\n给玩家飞船的生存带来负面影响</p>\r\n<p>[待扩展]将敌人生成预设为波次进攻模式,\r\n根据关卡难度控制生成情况</p></li>\r\n</ol>\r\n<h3 id=\"敌人飞船的能力\">敌人飞船的能力</h3>\r\n<ol type=\"1\">\r\n<li>在地图中移动, 不同的飞船有各自不同的移动能力\r\n<ol type=\"1\">\r\n<li>Enemy_0从地图上侧随机处生成, 向地图最下端直线移动,\r\n从下侧离开地图</li>\r\n<li>Enemy_1从地图上侧随机处生成, 向地图最下端移动的同时左右摇摆,\r\n从下侧离开地图</li>\r\n<li>Enemy_2从地图左右侧随机生成, 横向进入地图,\r\n来回穿越一回合后从另一侧离开地图</li>\r\n<li>Enemy_3从地图上侧随机处生成, 纵向进入地图,\r\n抵达路径最低处后从上侧离开地图</li>\r\n<li>Enemy_4从地图上侧随机处生成, 每隔一段时间, 在地图的四个象限没移动,\r\n不会离开地图</li>\r\n</ol></li>\r\n<li>掉落武器系统加成道具</li>\r\n<li>[可扩展]获得武器并控制武器开火</li>\r\n</ol>\r\n<h3 id=\"敌人飞船与其他对象的交互\">敌人飞船与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>承受玩家武器的攻击(碰撞到子弹), 减少生命值, 当生命值归零时,\r\n自身销毁.\r\n<ol type=\"1\">\r\n<li>Enemy_4持有护盾, 当收到攻击时, 优先消耗护盾的生命值</li>\r\n</ol></li>\r\n<li>碰撞到玩家飞船, 导致自身销毁.</li>\r\n</ol>\r\n<h2 id=\"武器系统\">武器系统</h2>\r\n<figure>\r\n<img src=\"image%203.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>玩家护盾虽与暂时玩家飞船绑定, 但可改造为武器系统的一部分</p>\r\n<h3 id=\"武器系统的意义\">武器系统的意义</h3>\r\n<ol type=\"1\">\r\n<li>为玩家飞船提供清理敌人飞船的能力, 使得玩家飞船在游戏中生存下来</li>\r\n<li>含有5个武器挂载点位, 为玩家提供了武器的选择和升级空间,\r\n使游戏更加有趣</li>\r\n</ol>\r\n<h3 id=\"武器系统的能力\">武器系统的能力</h3>\r\n<ol type=\"1\">\r\n<li>当玩家控制开火时, 武器可以以不同形式发射弹药,\r\n而弹药可以攻击并消灭敌人\r\n<ol type=\"1\">\r\n<li>Blaster 每次开火向正前方发射一枚子弹, 子弹会向前移动直到地图边缘,\r\n发射间隔较短</li>\r\n<li>Spread 每次开火向前方扇形排布发射多枚子弹, ,\r\n子弹会向前移动直到地图边缘, 发射间隔较长</li>\r\n<li>[待扩展]Missile 每次开火发射一枚导弹, 导弹可以自动跟踪敌人</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"武器系统与其他对象的交互\">武器系统与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>武器本身不与敌人交互, 而是通过弹药来与敌人交互,\r\n武器的职责是是生成弹药, 当弹药接触到敌人时, 给敌人造成伤害</li>\r\n<li>武器系统会根据玩家接触到的加成道具进行改变\r\n<ol type=\"1\">\r\n<li>玩家最多持有五个武器</li>\r\n<li>当玩家获得的加成和已持有的武器类型一致时, 武器系统得到强化</li>\r\n<li>当玩家获得的加成和已持有武器类型不一致时,\r\n将玩家的武器替换为所加成的武器, 此时武器系统可能强化或弱化</li>\r\n</ol></li>\r\n</ol>\r\n<h2 id=\"加成道具\">加成道具</h2>\r\n<figure>\r\n<img src=\"image%204.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"加成道具的意义\">加成道具的意义</h3>\r\n<ol type=\"1\">\r\n<li>加成道具可以为玩家提供武器系统的加成选项</li>\r\n<li>加成道具可以让玩家提供一个选择, 是否需要穿越危险的交战区,\r\n去获得加成道具, 使得游戏局面变得复杂有趣</li>\r\n</ol>\r\n<h3 id=\"加成道具的能力\">加成道具的能力</h3>\r\n<ol type=\"1\">\r\n<li>不同的加成道具可以给玩家提供不同的升级\r\n<ol type=\"1\">\r\n<li>Shield 增强玩家的护盾</li>\r\n<li>Spread 给玩家添加Spread 武器</li>\r\n<li>Blaster 给玩家添加Blaster 武器</li>\r\n<li>[可扩展] 同步武器系统的武器类型, 提供加成</li>\r\n<li>[可扩展] 对游戏局势产生重大效果, 如对所有敌人造成伤害</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"加成道具与其他对象的交互\">加成道具与其他对象的交互</h3>\r\n<ol type=\"1\">\r\n<li>与玩家飞船碰撞, 导致自身被消耗, 对玩家飞船造成相应影响</li>\r\n<li>当敌人被消灭时, 根据概率设定, 生成不同的加成道具</li>\r\n<li>[可扩展]与敌人飞船碰撞, 导致自身被销毁</li>\r\n<li>[可扩展]与敌人飞船碰撞, 对敌人飞船产生影响</li>\r\n</ol>\r\n<h1 id=\"系统分析与实现\">系统分析与实现</h1>\r\n<h2 id=\"boundscheck\">BoundsCheck</h2>\r\n<p>一个通用组件, 用于判断游戏对象是否在屏幕中, 获取相对屏幕的位置.</p>\r\n<p>可以用来管理游戏对象, 包括玩家.</p>\r\n<p>使用了复合枚举来保存位置信息.</p>\r\n<p>为每一个游戏对象添加BoundsCheck 组件,\r\n通过调用boundsCheck.isOnScreen()或boundsCheck.LocIs来获取信息.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BoundsCheck</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">System.Flags</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> eScreenLocs &#123;</span><br><span class=\"line\">        onScreen = <span class=\"number\">0</span>,</span><br><span class=\"line\">        offRight = <span class=\"number\">1</span>,</span><br><span class=\"line\">        offLeft = <span class=\"number\">2</span>,</span><br><span class=\"line\">        offTop = <span class=\"number\">4</span>,</span><br><span class=\"line\">        offBottom = <span class=\"number\">8</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> eType &#123; center, inset, outset &#125;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eType boundsType = eType.center;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> radius = <span class=\"number\">1f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> keepOnScreen = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Dynamic&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eScreenLocs screenLocs = eScreenLocs.onScreen;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> camWidth;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> camHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LateUpdate</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//更新screenLocs </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> isOnScreen &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> screenLocs == eScreenLocs.onScreen; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">LocIs</span>(<span class=\"params\">eScreenLocs checkLoc</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkLoc == eScreenLocs.onScreen) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isOnScreen;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (screenLocs &amp; checkLoc) == checkLoc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"enemy\">Enemy</h2>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Main {\r\n        - static Main S\r\n        - GameObject[] prefabEnemies\r\n        - float enemySpawnPerSecond\r\n        + Awake()\r\n        + SpawnEnemy()\r\n    }\r\n\r\n    class Enemy {\r\n        <<abstract>>\r\n        + float speed\r\n        + float health\r\n        + Vector3 pos\r\n        + Move()\r\n        + OnCollisionEnter(Collision coll)\r\n    }\r\n\r\n    class Enemy_1 {\r\n        + float waveFrequency\r\n        + float waveWidth\r\n        - float x0\r\n        - float birthTime\r\n        + Move()\r\n    }\r\n\r\n    class ProjectileHero {\r\n        + float damageOnHit\r\n    }\r\n\r\n    Main --> Enemy : \"生成\"\r\n    Main --> prefabEnemies : \"管理预制件\"\r\n    Enemy_1 --> Enemy : \"继承\"\r\n    Enemy --> ProjectileHero : \"检测碰撞\"</pre>\r\n<h3 id=\"enemy生成\">Enemy生成</h3>\r\n<p>Enemy的生成为全局管理, 由游戏唯一Main对象管理, Main为单例,\r\n且保存所有Enemy的预制件.</p>\r\n<p>当Main对象被创建后, 每隔一段时间调用SpawnEnemy()方法,\r\n由SpawnEnemy()生成一个Enemy,\r\n在SpawnEnemy中选取要生成的具体Enemy可以要生成的具体坐标,\r\n然后通过Invoke延时递归调用自身.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine.SceneManagement;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Random = UnityEngine.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Main</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Main S;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject[] prefabEnemies;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> enemySpawnPerSecond = <span class=\"number\">0.5f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        Invoke(<span class=\"keyword\">nameof</span>(SpawnEnemy), <span class=\"number\">1f</span> / enemySpawnPerSecond);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SpawnEnemy</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 随机选取一个要生成的Enemy</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> ndx = Random.Range(<span class=\"number\">0</span>, prefabEnemies.Length);</span><br><span class=\"line\">        GameObject newEnemy = Instantiate&lt;GameObject&gt;(prefabEnemies[ndx]);</span><br><span class=\"line\">        <span class=\"comment\">// 获取Enemy要生成的坐标</span></span><br><span class=\"line\">        Vector3 pos = Vector3.zero;</span><br><span class=\"line\">        newEnemy.transform.position = pos;</span><br><span class=\"line\">        <span class=\"comment\">// 根据配置生成下一个Enemy</span></span><br><span class=\"line\">        Invoke(<span class=\"keyword\">nameof</span>(SpawnEnemy), <span class=\"number\">1f</span> / enemySpawnPerSecond);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"image%205.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"enemy基类和扩展类\">Enemy基类和扩展类</h3>\r\n<p>Enemy预制件附带有对应的Enemy脚本, 控制对应Enemy的行为.</p>\r\n<figure>\r\n<img src=\"image%206.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>每一种Enemy的通用属性, 如移动速度, 血量, 可以定义在基类中</p>\r\n<figure>\r\n<img src=\"image%207.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>每一种Enemy的移动方式不同, 可以再基类中实现基本移动功能,\r\n在具体类中实现扩展功能.</p>\r\n<p>Enemy基类, 实现基本向下移动</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> speed = <span class=\"number\">10f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> fireRate = <span class=\"number\">0.3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> health = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> score = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector3 pos &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> transform.position;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            transform.position = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        Move();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        Vector3 tempPos = pos;</span><br><span class=\"line\">        tempPos.y -= speed * Time.deltaTime;</span><br><span class=\"line\">        pos = tempPos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>例如: Enemy_1子类, 重写Move方法, 实现带有摆动的移动.</p>\r\n<p>通过Sin函数和存货时间计算摆动横向偏移量, 而基础的向下移动功能,\r\n又由Enemy基类完成.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_1</span> : <span class=\"title\">Enemy</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_1 Inscribed Fields&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;# of seconds for a full sine wave&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveFrequency = <span class=\"number\">2</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Sine wave width in meters&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveWidth = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> x0;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        x0 = pos.x;</span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        Vector3 tempPos = pos;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> age = Time.time - birthTime;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> theta = Mathf.PI * <span class=\"number\">2</span> * age / waveFrequency;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> sin = Mathf.Sin(theta);</span><br><span class=\"line\">        tempPos.x = x0 + sin * waveWidth;</span><br><span class=\"line\">        pos = tempPos;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">base</span>.Move();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy受击处理\">Enemy受击处理</h3>\r\n<p>Enemy可以和弹药类ProjectileHero进行碰撞, 通过Layer设置是否可以碰撞,\r\n然后在OnCollisionEnter中处理具体碰撞逻辑.</p>\r\n<p>弹药由武器生成, 弹药有伤害数值, 下文另谈.</p>\r\n<p>弹药游戏对象持有ProjectileHero组件,\r\n可用来判断Enemy碰撞到的是否是弹药.</p>\r\n<p>当Enemy碰撞到弹药后, 销毁弹药. 同时扣除自身血量,\r\n血量耗尽后销毁Enemy.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> health = <span class=\"number\">10</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnCollisionEnter</span>(<span class=\"params\">Collision coll</span>)</span> &#123;</span><br><span class=\"line\">        GameObject otherGO = coll.gameObject;</span><br><span class=\"line\">        ProjectileHero projectileHero = otherGO.GetComponent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (projectileHero != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bndCheck.isOnScreen) &#123;</span><br><span class=\"line\">                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (health &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!calledShipDestroyed) &#123;</span><br><span class=\"line\">                        calledShipDestroyed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        Main.SHIP_DESTROYED(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Destroy(gameObject);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Destroy(otherGO);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.Log(<span class=\"string\">&quot;Enemy hit by non-ProjectileHero: &quot;</span> + otherGO.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"hero\">Hero</h2>\r\n<h3 id=\"hero生成\">Hero生成</h3>\r\n<p>玩家飞船也为全局唯一对象, 使用单例模式, 使用Hero脚本控制行为.</p>\r\n<p>因为不会重复生成, 所以游戏开始时直接布置在场景Scene中.</p>\r\n<figure>\r\n<img src=\"image%208.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"玩家移动控制\">玩家移动控制</h3>\r\n<p>有参数最大速度. 根据帧间时间计算移动后所处位置, 直接改变.</p>\r\n<p>每帧读取移动虚拟轴输入, 实现平滑移动.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> maxSpeed = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (S == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;Hero.Awake() - Attempted to assign second Hero.S!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> hAxis = Input.GetAxis(<span class=\"string\">&quot;Horizontal&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">float</span> vAxis = Input.GetAxis(<span class=\"string\">&quot;Vertical&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 pos = transform.position;</span><br><span class=\"line\">        pos.x += hAxis * maxSpeed * Time.deltaTime;</span><br><span class=\"line\">        pos.y += vAxis * maxSpeed * Time.deltaTime;</span><br><span class=\"line\">        transform.position = pos;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"玩家开火控制\">玩家开火控制</h3>\r\n<p>每帧读取开火虚拟轴输入, 触发开火事件. 具体开火实现见武器系统.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">WeaponFireDelegate</span>()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> WeaponFireDelegate fireEvent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Input.GetAxis(<span class=\"string\">&quot;Jump&quot;</span>) == <span class=\"number\">1</span> &amp;&amp; fireEvent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            fireEven();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"weapon\">Weapon</h2>\r\n<h3 id=\"weapon配置管理和切换\">Weapon配置管理和切换</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Main {\r\n        - Dictionary<eWeaponType, WeaponDefinition> WEAP_DICT\r\n        + WeaponDefinition[] weaponDefinitions\r\n        + WeaponDefinition GET_WEAPON_DEFINITION(eWeaponType wt)\r\n        + Awake()\r\n    }\r\n    \r\n    class Weapon {\r\n        - eWeaponType _type\r\n        - WeaponDefinition def\r\n        - float nextShotTime\r\n        - GameObject weaponModel\r\n        + SetType(eWeaponType type)\r\n    }\r\n\r\n    class WeaponDefinition {\r\n        + eWeaponType type\r\n        + GameObject weaponModelPrefab\r\n        + GameObject projectilePrefab\r\n        + float delayBetweenShots\r\n        + float velocity\r\n    }\r\n\r\n    class eWeaponType {\r\n        <<enumeration>>\r\n        none\r\n        blaster\r\n        spread\r\n    }\r\n\r\n    Main --> WeaponDefinition : \"管理\"\r\n    Weapon --> WeaponDefinition : \"获取和应用\"\r\n    Main --> eWeaponType : \"依赖\"\r\n    Weapon --> eWeaponType : \"依赖\"\r\n    WeaponDefinition --> eWeaponType : \"定义\"\r\n  WeaponDefinition --> weaponModelPrefab: \"管理预制件\"\r\n  WeaponDefinition --> projectilePrefab: \"管理预制件\"</pre>\r\n<p>在本系统中, 武器被实现为一个可以通过类型枚举来配置武器行为的对象.\r\n武器对象是一直存在的, 会根据类型的切换改变表现的形态.</p>\r\n<p>武器的具体参数又保存在具体的武器定义类中. 不仅仅是数值参数,\r\n还有模型预制体参数和子弹预制体参数.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类型的枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> eWeaponType &#123;</span><br><span class=\"line\">    none,       <span class=\"comment\">// 无</span></span><br><span class=\"line\">    blaster,    <span class=\"comment\">// 爆能枪</span></span><br><span class=\"line\">    spread,     <span class=\"comment\">// 散射枪</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 武器定义类，描述每种武器的属性</span></span><br><span class=\"line\">[<span class=\"meta\">System.Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">WeaponDefinition</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type = eWeaponType.none;  <span class=\"comment\">// 武器类型，默认无</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;附加到玩家飞船上的武器模型预制件&quot;</span>)</span>]  <span class=\"comment\">// 提示：武器模型的预制件</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject weaponModelPrefab;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;发射的投射物预制件&quot;</span>)</span>]  <span class=\"comment\">// 提示：发射的投射物的预制件</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject projectilePrefab;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;每次射击之间的延迟秒数&quot;</span>)</span>]  <span class=\"comment\">// 提示：射击间隔时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> delayBetweenShots = <span class=\"number\">0</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;单个投射物的速度&quot;</span>)</span>]  <span class=\"comment\">// 提示：投射物速度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> velocity = <span class=\"number\">50</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>所有的武器定义类被保存在Main对象中, 便于统一修改.</p>\r\n<p>使用一个列表weaponDefinitions来保存所有的武器定义类,\r\n在Unity中进行修改.</p>\r\n<figure>\r\n<img src=\"image%209.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>然后在Main脚本激活时将weaponDefinitions中的参数保存到字典Dictionary&lt;eWeaponType,\r\nWeaponDefinition&gt; WEAP_DICT中,\r\n这样就可以通过GET_WEAPON_DEFINITION()方法,\r\n在具体武器类想要获得具体武器参数是获得在Unity中写好的配置.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine.SceneManagement;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Random = UnityEngine.Random;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Main</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Main S;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Dictionary&lt;eWeaponType, WeaponDefinition&gt; WEAP_DICT;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> WeaponDefinition[] weaponDefinitions;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//单例模式</span></span><br><span class=\"line\">        S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        bndCheck = GetComponent&lt;BoundsCheck&gt;();</span><br><span class=\"line\">        Invoke(<span class=\"keyword\">nameof</span>(SpawnEnemy), <span class=\"number\">1f</span> / enemySpawnPerSecond);</span><br><span class=\"line\">        WEAP_DICT = <span class=\"keyword\">new</span> Dictionary&lt;eWeaponType, WeaponDefinition&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (WeaponDefinition def <span class=\"keyword\">in</span> weaponDefinitions) &#123; WEAP_DICT[def.type] = def; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> WeaponDefinition <span class=\"title\">GET_WEAPON_DEFINITION</span>(<span class=\"params\">eWeaponType wt</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (WEAP_DICT.ContainsKey(wt)) <span class=\"keyword\">return</span> WEAP_DICT[wt];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WeaponDefinition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>通过在具体武器类中保存武器类型定义类eWeaponType _type,\r\n每次修改类型时, 武器对象通过Main.GET_WEAPON_DEFINITION(_type);\r\n方法更新武器的定义, 从而加载不同的模型, 以及获取一些武器参数.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> eWeaponType _type = eWeaponType.none;  <span class=\"comment\">// 当前武器类型，默认无</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> WeaponDefinition def;   <span class=\"comment\">// 武器定义</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> GameObject weaponModel; <span class=\"comment\">// 武器模型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        SetType(_type);  <span class=\"comment\">// 设置武器类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 武器类型的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> _type; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; SetType(<span class=\"keyword\">value</span>); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置武器类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType type</span>)</span> &#123;</span><br><span class=\"line\">        _type = type;</span><br><span class=\"line\"></span><br><span class=\"line\">        def = Main.GET_WEAPON_DEFINITION(_type);  <span class=\"comment\">// 获取武器的定义</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果已有武器模型，销毁它</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (weaponModel != <span class=\"literal\">null</span>) Destroy(weaponModel);</span><br><span class=\"line\">        <span class=\"comment\">// 实例化新的武器模型</span></span><br><span class=\"line\">        weaponModel = Instantiate&lt;GameObject&gt;(def.weaponModelPrefab, transform);</span><br><span class=\"line\">        weaponModel.transform.localPosition = Vector3.zero;</span><br><span class=\"line\">        weaponModel.transform.localScale = Vector3.one;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>图示</p>\r\n<h3 id=\"weapon对象载入\">Weapon对象载入</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Weapon {\r\n        - eWeaponType _type\r\n        + SetType(eWeaponType type)\r\n    }\r\n    class Hero{\r\n      + Weapon[] weapons\r\n      + ClearWeapons()\r\n    }\r\n    class eWeaponType {\r\n        <<enumeration>>\r\n        none\r\n        blaster\r\n        spread\r\n    }\r\n    Weapon --> eWeaponType :依赖\r\n    Hero--> eWeaponType :依赖\r\n    Hero--> Weapon :管理</pre>\r\n<p>武器的实际挂载对象是玩家飞船, 通过Hero脚本进行管理.</p>\r\n<p>在游戏场景的Hero游戏对象上, 有五个子游戏对象hardpoint,\r\n每个绑定在玩家飞船的不同位置上,\r\n然后在游戏对象hardpoint上有子游戏对象Weapon预制件实例,\r\nWeapon脚本作为Weapon预制件的组件, Hero脚本作为Hero游戏对象的组件.\r\n在Hero脚本中有Weapon列表, 绑定这些Weapon预制件实例来进行管理.</p>\r\n<p>通过调用Weapon.SetType(eWeaponType),\r\n就可以设置具体的Weapon预制件实例的类型.</p>\r\n<p>ClearWeapons()方法可以将所有的Weapon预制件实例类型改为eWeaponType.none.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Weapon[] weapons;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (S == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            S = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.LogError(<span class=\"string\">&quot;Hero.Awake() - Attempted to assign second Hero.S!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ClearWeapons();</span><br><span class=\"line\">        weapons[<span class=\"number\">0</span>].SetType(eWeaponType.blaster);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ClearWeapons</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Weapon w <span class=\"keyword\">in</span> weapons) &#123;</span><br><span class=\"line\">            w.SetType(eWeaponType.none);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"weapon开火\">Weapon开火</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Weapon {\r\n        +WeaponDefinition def\r\n        +float nextShotTime\r\n        +Transform shotPointTrans\r\n        +Start()\r\n        +Fire()\r\n        +MakeProjectile()\r\n    }\r\n    \r\n    class ProjectileHero {\r\n        +Rigidbody rigid\r\n        +BoundsCheck boundsCheck\r\n        +Renderer rend\r\n        +eWeaponType type\r\n        +SetType(eWeaponType eType)\r\n        +Vector3 vel\r\n        +Awake()\r\n        +Update()\r\n    }\r\n\r\n    class WeaponDefinition {\r\n        +GameObject projectilePrefab\r\n        +float delayBetweenShots\r\n        +float velocity\r\n        +Color projectileColor\r\n    }\r\n\r\n    Weapon --> ProjectileHero : \"生成弹药实例\"\r\n    ProjectileHero --> WeaponDefinition : \"获取弹药定义\"\r\n    Weapon --> WeaponDefinition : \"根据武器类型获取参数\"\r\n    ProjectileHero --> Rigidbody : \"控制物理运动\"\r\n    ProjectileHero --> BoundsCheck : \"检测屏幕外销毁\"</pre>\r\n<p>对于每一个Weapon游戏对象实例,\r\n由Weapon预制体的子对象ShotPoint提供射击点, 也就是弹药生成的位置.</p>\r\n<p>Weapon 脚本通过WeaponDefinition def上保存的武器定义,\r\n来获取弹药的参数, 包括弹药预制体和弹药速度等.</p>\r\n<p>Fire()方法作为Weapon的开火方法, 当被触发时, 根据保存的武器类型,\r\n进行相对应的弹药生成方法. 例如blaster就生成一个弹药,\r\nspread就生成三个弹药. 弹药</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> WeaponDefinition def;   <span class=\"comment\">// 武器定义</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> nextShotTime;     <span class=\"comment\">// 下一次射击的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Transform shotPointTrans; <span class=\"comment\">// 射击点的Transform</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        shotPointTrans = transform.GetChild(<span class=\"number\">0</span>);  <span class=\"comment\">// 获取子物体的Transform作为射击点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 触发射击</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Fire</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Time.time &lt; nextShotTime) <span class=\"keyword\">return</span>;  <span class=\"comment\">// 如果还没到下一次射击时间，返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ProjectileHero projectileHero;  <span class=\"comment\">// 投射物</span></span><br><span class=\"line\">        Vector3 vel = Vector3.up * def.velocity;  <span class=\"comment\">// 投射物速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据武器类型发射不同的投射物</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.blaster:  <span class=\"comment\">// 爆能枪</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();  <span class=\"comment\">// 创建投射物</span></span><br><span class=\"line\">                projectileHero.vel = vel;  <span class=\"comment\">// 设置投射物速度</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.spread:  <span class=\"comment\">// 散射武器</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.vel = vel;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 创建左侧散射投射物</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.transform.rotation = Quaternion.AngleAxis(<span class=\"number\">10</span>, Vector3.back);</span><br><span class=\"line\">                projectileHero.vel = projectileHero.transform.rotation * vel;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 创建右侧散射投射物</span></span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.transform.rotation = Quaternion.AngleAxis(<span class=\"number\">-10</span>, Vector3.back);</span><br><span class=\"line\">                projectileHero.vel = projectileHero.transform.rotation * vel;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建投射物实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ProjectileHero <span class=\"title\">MakeProjectile</span>()</span> &#123;</span><br><span class=\"line\">        GameObject gameObject = Instantiate&lt;GameObject&gt;(def.projectilePrefab, PROJECTILE_ANCHOR);  <span class=\"comment\">// 实例化投射物</span></span><br><span class=\"line\">        ProjectileHero projectileHero = gameObject.GetComponent&lt;ProjectileHero&gt;();  <span class=\"comment\">// 获取投射物组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 pos = shotPointTrans.position;  <span class=\"comment\">// 获取射击点的位置</span></span><br><span class=\"line\">        pos.z = <span class=\"number\">0</span>;  <span class=\"comment\">// 设置Z轴为0</span></span><br><span class=\"line\">        projectileHero.transform.position = pos;  <span class=\"comment\">// 设置投射物位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        projectileHero.type = type;  <span class=\"comment\">// 设置投射物类型</span></span><br><span class=\"line\">        nextShotTime = Time.time + def.delayBetweenShots;  <span class=\"comment\">// 设置下一次射击的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> projectileHero;  <span class=\"comment\">// 返回投射物实例</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>弹药ProjectileHero 实例由Weapon生成,</p>\r\n<p>由Weapon控制其速度, 由刚体组件控制其运动,</p>\r\n<p>由BoundsCheck组件提供是否飞出屏幕, 判断销毁,</p>\r\n<p>由Enemy判断碰撞逻辑销毁.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BoundsCheck boundsCheck;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Renderer rend;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Dynamic&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Rigidbody rigid;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> eWeaponType _type;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> _type; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; SetType(<span class=\"keyword\">value</span>); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType eType</span>)</span> &#123;</span><br><span class=\"line\">        _type = eType;</span><br><span class=\"line\">        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(_type);</span><br><span class=\"line\">        rend.material.color = def.projectileColor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector3 vel &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> rigid.velocity; &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; rigid.velocity = <span class=\"keyword\">value</span>; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        boundsCheck = GetComponent&lt;BoundsCheck&gt;();</span><br><span class=\"line\">        rend = GetComponent&lt;Renderer&gt;();</span><br><span class=\"line\">        rigid = GetComponent&lt;Rigidbody&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (boundsCheck.LocIs(BoundsCheck.eScreenLocs.offTop)) &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"hero开火事件\">Hero开火事件</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Hero {\r\n        +delegate WeaponFireDelegate\r\n        +event WeaponFireDelegate fireEvent\r\n        +Update() \"检测开火输入\"\r\n    }\r\n    \r\n    class Weapon {\r\n        +Start()\r\n        +Fire()\"触发射击\"\r\n    }\r\n\r\n    Hero o-- Weapon : \"注册开火事件\"\r\n    Hero : +fireEvent()\r\n    Weapon --> Hero : \"fireEvent 事件触发\"</pre>\r\n<p>Weapon的开火事件由Hero控制触发.</p>\r\n<p>在Hero上保存有委托fireEvent, 每帧检测是否有开火控制型号,\r\n然后触发fireEvent.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">WeaponFireDelegate</span>()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> WeaponFireDelegate fireEvent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Input.GetAxis(<span class=\"string\">&quot;Jump&quot;</span>) == <span class=\"number\">1</span> &amp;&amp; fireEvent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            fireEvent();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>在Weapon上注册事件, 将Weapon的Fire方法绑定到Hero的fireEvent上.</p>\r\n<p>这样当Hero触发开火时, 所有的Weapon都会开火.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果该武器附加在玩家上，注册射击事件</span></span><br><span class=\"line\">        Hero hero = GetComponentInParent&lt;Hero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hero != <span class=\"literal\">null</span>) hero.fireEvent += Fire;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 触发射击</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Fire</span>()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"powerup\">PowerUp</h2>\r\n<p>升级道具由Enemy死亡掉落, 可以触发Weapon改变</p>\r\n<h3 id=\"powerup生成\">PowerUp生成</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Enemy {\r\n        +OnCollisionEnter(Collision coll)\r\n        +bool calledShipDestroyed\r\n    }\r\n    \r\n    class PowerUp {\r\n        +eWeaponType type\r\n        +SetType(eWeaponType wt)\r\n    }\r\n    \r\n    class Main {\r\n        +static Main S\r\n        +GameObject prefabPowerUp\r\n        +eWeaponType[] powerUpFrequency\r\n        +static void SHIP_DESTROYED(Enemy e)\r\n    }\r\n\r\n    Enemy --> Main : \"通知SHIP_DESTROYED\"\r\n    Main --> PowerUp : \"生成PowerUp\"\r\n    PowerUp : +SetType()</pre>\r\n<p>PowerUp有其类型, 对应武器类型.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PowerUp</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Dynamic&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType _type;          <span class=\"comment\">// PowerUp 的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> birthTime;     <span class=\"comment\">// PowerUp 实例化时的 Time.time</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        birthTime = Time.time; <span class=\"comment\">// 记录实例化时的时间</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// PowerUp 类型的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType type &#123; <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> _type; &#125; <span class=\"keyword\">set</span> &#123; SetType(<span class=\"keyword\">value</span>); &#125; &#125; <span class=\"comment\">// h</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置 PowerUp 类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType wt</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从 Main 中获取武器定义</span></span><br><span class=\"line\">        WeaponDefinition def = Main.GET_WEAPON_DEFINITION(wt);</span><br><span class=\"line\">        cubeMat.color = def.powerUpColor;  <span class=\"comment\">// 设置 PowerCube 的颜色</span></span><br><span class=\"line\">        letter.text = def.letter;          <span class=\"comment\">// 设置显示的字母</span></span><br><span class=\"line\">        _type = wt;                         <span class=\"comment\">// 最终设置类型</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>为了使系统保持简洁, 也就是可以生成实例的类不要太多,\r\n这里吧生成PowerUP的职责放在Main中.</p>\r\n<p>当Enemy被销毁时, 通知Main. 使用Main.SHIP_DESTROYED(this);</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnCollisionEnter</span>(<span class=\"params\">Collision coll</span>)</span> &#123;</span><br><span class=\"line\">        GameObject otherGO = coll.gameObject;</span><br><span class=\"line\">        ProjectileHero projectileHero = otherGO.GetComponent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (projectileHero != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bndCheck.isOnScreen) &#123;</span><br><span class=\"line\">                health -= Main.GET_WEAPON_DEFINITION(projectileHero.type).damageOnHit;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (health &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!calledShipDestroyed) &#123;</span><br><span class=\"line\">                        calledShipDestroyed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        Main.SHIP_DESTROYED(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Destroy(gameObject);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Destroy(otherGO);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.Log(<span class=\"string\">&quot;Enemy hit by non-ProjectileHero: &quot;</span> + otherGO.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>Main中保存有PowerUP预制体, 以及一个eWeaponType列表,\r\n用来控制PowerUP生成类型的概率.</p>\r\n<p>当Main.SHIP_DESTROYED被触发时, 生成PowerUP并设定类型.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Random = UnityEngine.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Main</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> Main S;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> GameObject prefabPowerUp;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> eWeaponType[] powerUpFrequency = <span class=\"keyword\">new</span> eWeaponType[]&#123;</span><br><span class=\"line\">        eWeaponType.blaster,</span><br><span class=\"line\">        eWeaponType.blaster,</span><br><span class=\"line\">        eWeaponType.spread,</span><br><span class=\"line\">        eWeaponType.shield,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SHIP_DESTROYED</span>(<span class=\"params\">Enemy e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 有可能生成一个PowerUp</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Random.<span class=\"keyword\">value</span> &lt;= e.powerUpDropChance) &#123;  <span class=\"comment\">// 有一定几率生成 PowerUp</span></span><br><span class=\"line\">            <span class=\"comment\">// 从powerUpFrequency数组中选择一个PowerUp类型</span></span><br><span class=\"line\">            eWeaponType pUpType = S.powerUpFrequency[Random.Range(<span class=\"number\">0</span>, S.powerUpFrequency.Length)];  <span class=\"comment\">// 选择 PowerUp 类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 生成一个PowerUp对象</span></span><br><span class=\"line\">            GameObject go = Instantiate&lt;GameObject&gt;(S.prefabPowerUp);  <span class=\"comment\">// 实例化 PowerUp 对象</span></span><br><span class=\"line\">            PowerUp pUp = go.GetComponent&lt;PowerUp&gt;();  <span class=\"comment\">// 获取 PowerUp 脚本组件</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置生成的PowerUp为选定的武器类型</span></span><br><span class=\"line\">            pUp.SetType(pUpType);  <span class=\"comment\">// 设置 PowerUp 的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 设置 PowerUp 的位置为被摧毁的飞船的位置</span></span><br><span class=\"line\">            pUp.transform.position = e.transform.position;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"powerup触发\">PowerUp触发</h3>\r\n<pre class=\"mermaid\">classDiagram\r\n    class Hero {\r\n        +void OnTriggerEnter(Collider other)\r\n        +void AbsorbPowerUp(PowerUp powerUp)\r\n    }\r\n    \r\n    class PowerUp {\r\n        +eWeaponType type\r\n        +void AbsorbedBy(GameObject go) \r\n    }\r\n\r\n    class Weapon {\r\n        +void SetType(eWeaponType type)\r\n    }\r\n\r\n    Hero --> PowerUp : \"碰撞检测\"\r\n    Hero --> Weapon : \"改变武器类型\"\r\n    PowerUp --> Hero : \"触发PowerUp效果\"\r\n    PowerUp : +type \"PowerUp类型\"</pre>\r\n<p>当PowerUP被Hero碰撞后, 被消化使用. 在Hero中判断powerUp.type,\r\n根据具体类型产生不同效果, 同时销毁powerUp.</p>\r\n<p>若powerUp.type为一种武器, 触发weapon.SetType(powerUp.type),\r\n到Weapon类型被改变.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> GameObject lastTriggerGo = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnTriggerEnter</span>(<span class=\"params\">Collider other</span>)</span> &#123;</span><br><span class=\"line\">        Transform rootT = other.gameObject.transform.root;</span><br><span class=\"line\">        GameObject gameObject = rootT.gameObject;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (gameObject == lastTriggerGo) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        lastTriggerGo = gameObject;</span><br><span class=\"line\"></span><br><span class=\"line\">        Enemy enemy = gameObject.GetComponent&lt;Enemy&gt;();</span><br><span class=\"line\">        PowerUp powerUp = gameObject.GetComponent&lt;PowerUp&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            shieldLevel--;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (powerUp != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            AbsorbPowerUp(powerUp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Debug.LogWarning(<span class=\"string\">&quot;Shield trigger hit by non-Enemy: &quot;</span> + gameObject.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AbsorbPowerUp</span>(<span class=\"params\">PowerUp powerUp</span>)</span> &#123;</span><br><span class=\"line\">        Debug.Log(<span class=\"string\">&quot;Absorbed PowerUp: &quot;</span> + powerUp.type);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (powerUp.type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.shield:</span><br><span class=\"line\">                shieldLevel++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"literal\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (powerUp.type == weapons[<span class=\"number\">0</span>].type) &#123;</span><br><span class=\"line\">                    Weapon weapon = GetEmptyWeaponSlot();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (weapon != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        weapon.SetType(powerUp.type);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ClearWeapons();</span><br><span class=\"line\">                    weapons[<span class=\"number\">0</span>].SetType(powerUp.type);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        powerUp.AbsorbedBy(gameObject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>当PowerUP被触发时, 销毁自己</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PowerUp</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AbsorbedBy</span>(<span class=\"params\">GameObject target</span>)</span> &#123;</span><br><span class=\"line\">        Destroy(<span class=\"keyword\">this</span>.gameObject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"视觉效果\">视觉效果</h1>\r\n<h2 id=\"飞船运动倾角\">飞船运动倾角</h2>\r\n<h3 id=\"hero中的应用\">Hero中的应用</h3>\r\n<p>移动时, 根据虚拟轴输入, 计算旋转角度</p>\r\n<figure>\r\n<img src=\"image%2010.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"image%2011.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Hero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Hero S &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> maxSpeed = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> rollMult = <span class=\"number\">-45</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> pitchMult = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> hAxis = Input.GetAxis(<span class=\"string\">&quot;Horizontal&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">float</span> vAxis = Input.GetAxis(<span class=\"string\">&quot;Vertical&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        transform.rotation = Quaternion.Euler(vAxis * pitchMult, hAxis * rollMult, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy_1中的应用\">Enemy_1中的应用</h3>\r\n<p>移动时, 根据侧向偏移量, 计算旋转角度</p>\r\n<figure>\r\n<img src=\"image%2012.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_1</span> : <span class=\"title\">Enemy</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_1 Inscribed Fields&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;# of seconds for a full sine wave&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveFrequency = <span class=\"number\">2</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Sine wave width in meters&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveWidth = <span class=\"number\">6</span>;</span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Amount the ship will roll left and right with the sine wave&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> waveRotY = <span class=\"number\">45</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> x0;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        x0 = pos.x;</span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        Vector3 tempPos = pos;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> age = Time.time - birthTime;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> theta = Mathf.PI * <span class=\"number\">2</span> * age / waveFrequency;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> sin = Mathf.Sin(theta);</span><br><span class=\"line\">        tempPos.x = x0 + sin * waveWidth;</span><br><span class=\"line\">        pos = tempPos;</span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 rot = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, sin * waveRotY, <span class=\"number\">0</span>);</span><br><span class=\"line\">        transform.rotation = Quaternion.Euler(rot);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">base</span>.Move();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// print(bndCheck.isOnScreen);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy_2中的应用\">Enemy_2中的应用</h3>\r\n<p>移动时, 根据AnimationCurve 曲线, 计算旋转角度</p>\r\n<figure>\r\n<img src=\"image%2013.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_2</span> : <span class=\"title\">Enemy</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_2 Inscribed Field&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> lifeTime = <span class=\"number\">10f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;波幅控制&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> sinEccentricity = <span class=\"number\">0.6f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AnimationCurve rotCurve;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_2 Private Fields&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Quaternion baseRotation;</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>] <span class=\"keyword\">private</span> Vector3 p0, p1;<span class=\"comment\">//插值控制点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        p0 = Vector3.zero;</span><br><span class=\"line\">        p0.x = -bndCheck.camWidth - bndCheck.radius;</span><br><span class=\"line\">        p0.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">        p1 = Vector3.zero;</span><br><span class=\"line\">        p1.x = bndCheck.camWidth + bndCheck.radius;</span><br><span class=\"line\">        p1.y = Random.Range(-bndCheck.camHeight, bndCheck.camHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Random.<span class=\"keyword\">value</span> &gt; <span class=\"number\">0.5f</span>) &#123;</span><br><span class=\"line\">            p0.x *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">            p1.x *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\"></span><br><span class=\"line\">        transform.position = p0;</span><br><span class=\"line\">        transform.LookAt(p1, Vector3.back);</span><br><span class=\"line\">        baseRotation = transform.rotation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> u = (Time.time - birthTime) / birthTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">float</span> shipRot = rotCurve.Evaluate(u) * <span class=\"number\">360</span>;</span><br><span class=\"line\">        transform.rotation = baseRotation * Quaternion.Euler(-shipRot, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        u = u + sinEccentricity * Mathf.Sin(u * Mathf.PI * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pos = (<span class=\"number\">1</span> - u) * p0 + u * p1;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"平滑移动路径\">平滑移动路径</h2>\r\n<h3 id=\"贝塞尔曲线\">贝塞尔曲线</h3>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Utils</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 递归计算任意数量控制点的 Bézier 曲线上的点</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=&quot;t&quot;&gt;</span>插值比例 [0..1]<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=&quot;points&quot;&gt;</span>控制点数组<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span>曲线上的插值点<span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> Vector3 <span class=\"title\">Bezier</span>(<span class=\"params\"><span class=\"built_in\">float</span> t, <span class=\"keyword\">params</span> Vector3[] points</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当只有一个控制点时，返回该控制点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (points.Length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> points[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 LINQ 的 Select 和 Zip 进行插值计算</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bezier(t, points.Take(points.Length - <span class=\"number\">1</span>)</span><br><span class=\"line\">                               .Zip(points.Skip(<span class=\"number\">1</span>), (p0, p1) =&gt; Vector3.LerpUnclamped(p0, p1, t))</span><br><span class=\"line\">                               .ToArray());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"enemy_3中的应用\">Enemy_3中的应用</h3>\r\n<figure>\r\n<img src=\"image%2014.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Enemy_3</span> : <span class=\"title\">Enemy</span> &#123;            <span class=\"comment\">// Enemy_3 继承自 Enemy 类</span></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_3 公共字段&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> lifeTime = <span class=\"number\">5</span>;            <span class=\"comment\">// 生命时长为5秒</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Vector2 midpointYRange = <span class=\"keyword\">new</span> Vector2(<span class=\"number\">1.5f</span>, <span class=\"number\">3</span>);   <span class=\"comment\">// 中间点Y轴范围</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;如果为true,则在Scene面板中绘制Bézier点和路径。&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> drawDebugInfo = <span class=\"literal\">true</span>;     <span class=\"comment\">// 是否绘制调试信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Enemy_3 私有字段&quot;</span>)</span>]</span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Vector3[] points;  <span class=\"comment\">// Bézier曲线的三个点</span></span><br><span class=\"line\">    [<span class=\"meta\">SerializeField</span>]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> birthTime;   <span class=\"comment\">// 记录生成时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Start方法,因父类Enemy未使用,所以可以在此处使用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        points = <span class=\"keyword\">new</span> Vector3[<span class=\"number\">3</span>];  <span class=\"comment\">// 初始化三个控制点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 起始位置已经由 Main.SpawnEnemy() 设置</span></span><br><span class=\"line\">        points[<span class=\"number\">0</span>] = pos;  <span class=\"comment\">// 第一个点是当前敌人的初始位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置x轴的最小和最大值,和Main.SpawnEnemy()方式一致</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> xMin = -bndCheck.camWidth + bndCheck.radius;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> xMax = bndCheck.camWidth - bndCheck.radius;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 随机选择屏幕下半部分的一个中间点</span></span><br><span class=\"line\">        points[<span class=\"number\">1</span>] = Vector3.zero;  <span class=\"comment\">// 初始化第二个点</span></span><br><span class=\"line\">        points[<span class=\"number\">1</span>].x = Random.Range(xMin, xMax);  <span class=\"comment\">// x轴随机范围</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> midYMult = Random.Range(midpointYRange[<span class=\"number\">0</span>], midpointYRange[<span class=\"number\">1</span>]);  <span class=\"comment\">// 随机Y轴比例  // a</span></span><br><span class=\"line\">        points[<span class=\"number\">1</span>].y = -bndCheck.camHeight * midYMult;  <span class=\"comment\">// 设置Y轴位置  // a</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 随机选择屏幕上方的一个最终点</span></span><br><span class=\"line\">        points[<span class=\"number\">2</span>] = Vector3.zero;  <span class=\"comment\">// 初始化第三个点</span></span><br><span class=\"line\">        points[<span class=\"number\">2</span>].y = pos.y;       <span class=\"comment\">// Y轴保持在初始位置上方</span></span><br><span class=\"line\">        points[<span class=\"number\">2</span>].x = Random.Range(xMin, xMax);  <span class=\"comment\">// x轴随机范围</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置出生时间为当前时间</span></span><br><span class=\"line\">        birthTime = Time.time;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果需要绘制调试信息,则调用DrawDebug方法  // b</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (drawDebugInfo) DrawDebug();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Move</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Bézier曲线基于u值,u的范围在0到1之间</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> u = (Time.time - birthTime) / lifeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果u超过1,表示该敌人生命周期已结束</span></span><br><span class=\"line\">            Destroy(<span class=\"keyword\">this</span>.gameObject);  <span class=\"comment\">// 销毁游戏对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据u值旋转对象  // c</span></span><br><span class=\"line\">        transform.rotation = Quaternion.Euler(u * <span class=\"number\">180</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 插值计算Bézier曲线上的三个点  // d</span></span><br><span class=\"line\">        u = u - <span class=\"number\">0.1f</span> * Mathf.Sin(u * Mathf.PI * <span class=\"number\">2</span>);</span><br><span class=\"line\">        pos = Utils.Bezier(u, points);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Enemy_3 不调用父类的Move()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绘制调试信息,包括Bézier曲线和控制点  // e</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DrawDebug</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 绘制三个控制点之间的直线</span></span><br><span class=\"line\">        Debug.DrawLine(points[<span class=\"number\">0</span>], points[<span class=\"number\">1</span>], Color.cyan, lifeTime);  <span class=\"comment\">// 绘制第1到第2个点的线  // f</span></span><br><span class=\"line\">        Debug.DrawLine(points[<span class=\"number\">1</span>], points[<span class=\"number\">2</span>], Color.yellow, lifeTime); <span class=\"comment\">// 绘制第2到第3个点的线</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绘制Bézier曲线</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> numSections = <span class=\"number\">20</span>;  <span class=\"comment\">// 曲线分为20段</span></span><br><span class=\"line\">        Vector3 prevPoint = points[<span class=\"number\">0</span>];  <span class=\"comment\">// 上一个点,初始化为第一个控制点  // g</span></span><br><span class=\"line\">        Color col;</span><br><span class=\"line\">        Vector3 pt;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt; numSections; i++) &#123;  <span class=\"comment\">// 绘制Bézier曲线的各段  // h</span></span><br><span class=\"line\">            <span class=\"built_in\">float</span> u = i / numSections;  <span class=\"comment\">// u的值在0到1之间变化</span></span><br><span class=\"line\">            pt = Utils.Bezier(u, points);  <span class=\"comment\">// 计算当前插值点</span></span><br><span class=\"line\">            col = Color.Lerp(Color.cyan, Color.yellow, u);  <span class=\"comment\">// 根据u值插值颜色</span></span><br><span class=\"line\">            Debug.DrawLine(prevPoint, pt, col, lifeTime);  <span class=\"comment\">// 绘制前一个点到当前点的线  // i</span></span><br><span class=\"line\">            prevPoint = pt;  <span class=\"comment\">// 更新上一个点为当前点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"敌人受击反馈\">敌人受击反馈</h2>\r\n<p>新建受击组件</p>\r\n<p>保存所有子对象材质</p>\r\n<p>检测碰撞, 当被子弹命中时改变材质, 产生效果.</p>\r\n<p>效果根据时间消失.</p>\r\n<figure>\r\n<img src=\"image%2015.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">DisallowMultipleComponent</span>]  <span class=\"comment\">// 不允许在同一个GameObject上添加多个该组件  // a</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BlinkColorOnHit</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"built_in\">float</span> blinkDuration = <span class=\"number\">0.1f</span>;  <span class=\"comment\">// 闪烁颜色的持续时间（以秒为单位）  // b</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Color blinkColor = Color.red;  <span class=\"comment\">// 受击时显示的颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;动态参数&quot;</span>)</span>]  <span class=\"comment\">// 在Inspector面板中分类显示动态参数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> showingColor = <span class=\"literal\">false</span>;  <span class=\"comment\">// 是否正在显示闪烁颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> blinkCompleteTime;    <span class=\"comment\">// 恢复原始颜色的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> ignoreOnCollisionEnter = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Material[] materials;      <span class=\"comment\">// 当前GameObject及其子对象的所有材质</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Color[] originalColors;    <span class=\"comment\">// 材质的原始颜色数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BoundsCheck bndCheck;      <span class=\"comment\">// 用于检测对象是否在屏幕范围内的组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        bndCheck = GetComponentInParent&lt;BoundsCheck&gt;();  <span class=\"comment\">// 获取父对象上的BoundsCheck组件  // c</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取该GameObject及其所有子对象的材质</span></span><br><span class=\"line\">        materials = Utils.GetAllMaterials(gameObject);    <span class=\"comment\">// d</span></span><br><span class=\"line\">        <span class=\"comment\">// 存储每个材质的原始颜色</span></span><br><span class=\"line\">        originalColors = materials.Select(m =&gt; m.color).ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在显示闪烁颜色且当前时间超过了恢复颜色的时间，恢复原始颜色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (showingColor &amp;&amp; Time.time &gt; blinkCompleteTime) RevertColors();  <span class=\"comment\">// e</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnCollisionEnter</span>(<span class=\"params\">Collision coll</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreOnCollisionEnter) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有BoundsCheck且对象不在屏幕内，跳过受击显示</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bndCheck != <span class=\"literal\">null</span> &amp;&amp; !bndCheck.isOnScreen) &#123;  <span class=\"comment\">// g</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  <span class=\"comment\">// 当对象不在屏幕内时，不显示受击效果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 检测与ProjectileHero的碰撞</span></span><br><span class=\"line\">        ProjectileHero p = coll.gameObject.GetComponent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p != <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 如果碰撞对象是ProjectileHero  // f</span></span><br><span class=\"line\"></span><br><span class=\"line\">            SetColors();  <span class=\"comment\">// 显示受击颜色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 将所有材质的主颜色设置为闪烁颜色，并设置显示颜色的时间</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetColors</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Material m <span class=\"keyword\">in</span> materials) &#123;</span><br><span class=\"line\">            m.color = blinkColor;  <span class=\"comment\">// 将材质颜色设置为闪烁颜色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        showingColor = <span class=\"literal\">true</span>;  <span class=\"comment\">// 标记正在显示颜色</span></span><br><span class=\"line\">        blinkCompleteTime = Time.time + blinkDuration;  <span class=\"comment\">// 设置颜色恢复的时间</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 恢复所有材质的原始颜色，并停止显示颜色</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RevertColors</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; materials.Length; i++) &#123;</span><br><span class=\"line\">            materials[i].color = originalColors[i];  <span class=\"comment\">// 恢复原始颜色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        showingColor = <span class=\"literal\">false</span>;  <span class=\"comment\">// 标记颜色显示结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"无缝太空背景\">无缝太空背景</h2>\r\n<p>滚动数组思想.</p>\r\n<p>使用两块背景, 循环播放, 当一张移出屏幕后, 接替到另一张上面.</p>\r\n<figure>\r\n<img src=\"image%2016.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Parallax</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    [<span class=\"meta\">Header(<span class=\"string\">&quot;Inscribed&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform playerTrans; <span class=\"comment\">// The player ship (玩家飞船)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform[] panels; <span class=\"comment\">// The scrolling foregrounds (滚动的前景面板)</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Speed at which the panels move in Y&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> scrollSpeed = <span class=\"number\">-30f</span>; <span class=\"comment\">// 面板在Y轴上的滚动速度</span></span><br><span class=\"line\">    [<span class=\"meta\">Tooltip(<span class=\"string\">&quot;Controls how much panels react to player movement (Default 0.25)&quot;</span>)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> motionMult = <span class=\"number\">0.25f</span>; <span class=\"comment\">// 控制面板对玩家移动的反应程度 (默认值 0.25)   // a</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> panelHt; <span class=\"comment\">// Height of each panel (每个面板的高度)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> depth;   <span class=\"comment\">// Depth of panels (that is, pos.z) (面板的深度，即z轴位置)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span> &#123;</span><br><span class=\"line\">        panelHt = panels[<span class=\"number\">0</span>].localScale.y; <span class=\"comment\">// 获取第一个面板的高度</span></span><br><span class=\"line\">        depth = panels[<span class=\"number\">0</span>].position.z; <span class=\"comment\">// 获取面板的深度（z轴位置）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Set initial positions of panels (设置面板的初始位置)</span></span><br><span class=\"line\">        panels[<span class=\"number\">0</span>].position = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, <span class=\"number\">0</span>, depth); <span class=\"comment\">// 第一个面板位于起点</span></span><br><span class=\"line\">        panels[<span class=\"number\">1</span>].position = <span class=\"keyword\">new</span> Vector3(<span class=\"number\">0</span>, panelHt, depth); <span class=\"comment\">// 第二个面板位于第一个面板上方</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> tY, tX = <span class=\"number\">0</span>; <span class=\"comment\">// 定义用于计算面板位置的变量</span></span><br><span class=\"line\">        tY = Time.time * scrollSpeed % panelHt + (panelHt * <span class=\"number\">0.5f</span>); <span class=\"comment\">// 随时间滚动并保证循环衔接   // b</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (playerTrans != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            tX = -playerTrans.transform.position.x * motionMult; <span class=\"comment\">// 根据玩家的x位置调整tX   // c</span></span><br><span class=\"line\">                                                                 <span class=\"comment\">// tY += -poi.transform.position.y * motionMult; // 如果需要，也可以对Y轴进行调整</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Position panels[0] (设置第一个面板的位置)</span></span><br><span class=\"line\">        panels[<span class=\"number\">0</span>].position = <span class=\"keyword\">new</span> Vector3(tX, tY, depth);</span><br><span class=\"line\">        <span class=\"comment\">// Position panels[1] where needed to make a continuous starfield (根据需要设置第二个面板的位置，以实现连续的星空效果)  // d</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tY &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            panels[<span class=\"number\">1</span>].position = <span class=\"keyword\">new</span> Vector3(tX, tY - panelHt, depth); <span class=\"comment\">// 第二个面板在第一个面板的上方</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            panels[<span class=\"number\">1</span>].position = <span class=\"keyword\">new</span> Vector3(tX, tY + panelHt, depth); <span class=\"comment\">// 第二个面板在第一个面板的下方</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"扩展实践\">扩展实践</h1>\r\n<h2 id=\"missile\">Missile</h2>\r\n<p>创建一种新的武器-导弹. 可以在发射后自动跟踪敌人.</p>\r\n<h3 id=\"创建新的武器配置\">创建新的武器配置</h3>\r\n<p>在Main.cs→WeaponDefinitions中创建Missile</p>\r\n<figure>\r\n<img src=\"image%2017.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>在Main.cs→PowerUPfrequency中创建Missile</p>\r\n<figure>\r\n<img src=\"image%2018.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>此时运行游戏</p>\r\n<p>敌人可掉落M道具</p>\r\n<figure>\r\n<img src=\"image%2019.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>拾取后也可正常装备</p>\r\n<figure>\r\n<img src=\"image%2020.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>但此时还没有发射功能</p>\r\n<h3 id=\"添加发射功能\">添加发射功能</h3>\r\n<p>修改Weapon类, 在射击方法中添加处理导弹类型的代码</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 武器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Weapon</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 触发射击</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Fire</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据武器类型发射不同的投射物</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 导弹类型</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> eWeaponType.missile:</span><br><span class=\"line\">                projectileHero = MakeProjectile();</span><br><span class=\"line\">                projectileHero.vel = vel;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>此时可以发生导弹类型的弹药, 由上一步配置为红色.</p>\r\n<figure>\r\n<img src=\"image%2021.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"实现目标检测\">实现目标检测</h3>\r\n<p>实现思路</p>\r\n<p>给ProjectileHero创建一个球形碰撞箱来检测敌人</p>\r\n<p>通过向量差值获得指向敌人的向量来修改导弹的速度使其朝向敌人</p>\r\n<p>ProjectileHero已经自身持有一个碰撞箱用来检测是否与敌人碰撞,\r\n所以我们给Missile类型的ProjectileHero创建一个子对象detectionRange,\r\n再在这个子对象detectionRange上添加SphereCollider.</p>\r\n<p>在ProjectileHero上新增代码</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Transform detectionRangeTrans;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType eType</span>)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 如果类型是导弹类型，添加检测范围</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_type == eWeaponType.missile) &#123;</span><br><span class=\"line\">            AddDetectionRange();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加用于检测目标的球形碰撞体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddDetectionRange</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建子对象</span></span><br><span class=\"line\">        GameObject detectionRange = <span class=\"keyword\">new</span> GameObject(<span class=\"string\">&quot;DetectionRange&quot;</span>);</span><br><span class=\"line\">        detectionRangeTrans = detectionRange.transform;</span><br><span class=\"line\">        <span class=\"comment\">// 设置为ProjectileHero的子对象</span></span><br><span class=\"line\">        detectionRangeTrans.SetParent(<span class=\"keyword\">this</span>.transform);</span><br><span class=\"line\">        <span class=\"comment\">// 确保位置和ProjectileHero一致</span></span><br><span class=\"line\">        detectionRangeTrans.localPosition = Vector3.zero;</span><br><span class=\"line\">        <span class=\"comment\">// 设置与ProjectileHero相同的Layer</span></span><br><span class=\"line\">        detectionRangeTrans.gameObject.layer = gameObject.layer;</span><br><span class=\"line\">        <span class=\"comment\">// 添加球形碰撞箱</span></span><br><span class=\"line\">        SphereCollider sphereCollider = detectionRange.AddComponent&lt;SphereCollider&gt;();</span><br><span class=\"line\">        sphereCollider.isTrigger = <span class=\"literal\">true</span>; <span class=\"comment\">// 设置为触发器</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置碰撞体的半径，决定探测范围</span></span><br><span class=\"line\">        sphereCollider.radius = <span class=\"number\">10f</span>; <span class=\"comment\">// 可以根据需要调整半径的大小</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>实现效果, 可见碰撞箱半径</p>\r\n<figure>\r\n<img src=\"image%2022.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"实现目标追踪\">实现目标追踪</h3>\r\n<p>为刚才创建的对象添加一个脚本, 专门用来处理追踪逻辑</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\">[<span class=\"meta\">RequireComponent(typeof(BoundsCheck))</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加用于检测目标的球形碰撞体</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddDetectionRange</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加一个额外的脚本，用于处理目标检测逻辑</span></span><br><span class=\"line\">        detectionRange.AddComponent&lt;MissileTargetDetector&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>保存变量projectileHero, 用于修改其运动</p>\r\n<p>保存变量enemy 用于确认目标</p>\r\n<p>在OnTriggerEnter中设定目标</p>\r\n<p>在OnTriggerExit中放弃目标</p>\r\n<p>在Update使用线性插值修改速度方向追踪目标</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MissileTargetDetector</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    ProjectileHero projectileHero;</span><br><span class=\"line\">    Enemy enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Awake</span>()</span> &#123;</span><br><span class=\"line\">        projectileHero = gameObject.GetComponentInParent&lt;ProjectileHero&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若目标存在且存活, 修正速度方向, 实现追踪功能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span> &amp;&amp; enemy.gameObject != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            Vector3 origin = projectileHero.rigid.velocity;</span><br><span class=\"line\">            Vector3 direction = (enemy.transform.position - transform.position).normalized * origin.magnitude;</span><br><span class=\"line\">            projectileHero.rigid.velocity = Vector3.Lerp(origin, direction, <span class=\"number\">0.2f</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnTriggerEnter</span>(<span class=\"params\">Collider other</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Debug.LogWarning(&quot;Missile trigger Enter: &quot; + other.name);</span></span><br><span class=\"line\">        <span class=\"comment\">// 若敌人进入范围, 且当前无其他目标, 将该敌人设定为目标</span></span><br><span class=\"line\">        Enemy detectedEnemy = other.gameObject.GetComponent&lt;Enemy&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy == <span class=\"literal\">null</span> &amp;&amp; detectedEnemy != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            enemy = detectedEnemy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnTriggerExit</span>(<span class=\"params\">Collider other</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Debug.LogWarning(&quot;Missile trigger Exit: &quot; + other.name);</span></span><br><span class=\"line\">        <span class=\"comment\">// 若目标存在且脱离追踪范围, 放弃这个目标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span> &amp;&amp; other.gameObject == enemy.gameObject) &#123;</span><br><span class=\"line\">            enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>实现效果, 当导弹靠近目标之后, 会指向目标</p>\r\n<figure>\r\n<img src=\"image%2023.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>发现Bug1, 当导弹跟踪的目标丢失以后会失去速度滞留在地图上</p>\r\n<figure>\r\n<img src=\"image%2024.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<p>修复: 使用线性插值直接修改速度会改变速度大小, 下文优化追踪方案</p>\r\n<p>发现Bug2, 导弹对Enemy_1没有追踪作用</p>\r\n<p>修复: Enemy_1没有碰撞箱, 添加碰撞箱后功能恢复</p>\r\n<figure>\r\n<img src=\"image%2025.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>\r\n<h3 id=\"优化目标追踪\">优化目标追踪</h3>\r\n<p>将原本的线性插值改变速度方向, 改为旋转导弹的方向, 更加平滑,\r\n视觉表现也更好.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MissileTargetDetector</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> rotationSpeed = <span class=\"number\">4.0f</span>;  <span class=\"comment\">// 控制旋转速度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若目标存在且存活, 修正速度方向, 实现追踪功能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (enemy != <span class=\"literal\">null</span> &amp;&amp; enemy.gameObject != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算导弹当前朝向与目标之间的旋转</span></span><br><span class=\"line\">            Vector3 targetDirection = (enemy.transform.position - projectileHero.transform.position).normalized;</span><br><span class=\"line\">            Quaternion targetRotation = Quaternion.LookRotation(Vector3.forward, targetDirection);</span><br><span class=\"line\">            <span class=\"comment\">// 平滑地插值旋转到目标方向</span></span><br><span class=\"line\">            projectileHero.transform.rotation = Quaternion.Slerp(</span><br><span class=\"line\">                projectileHero.transform.rotation,</span><br><span class=\"line\">                targetRotation,</span><br><span class=\"line\">                Time.deltaTime * rotationSpeed</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"comment\">// 根据当前朝向更新导弹的速度</span></span><br><span class=\"line\">            projectileHero.vel = projectileHero.transform.up * projectileHero.speed;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            enemy = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>同时在ProjectileHero保存速度的大小, 修复了导弹静止的问题.</p>\r\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectileHero</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> speed;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetType</span>(<span class=\"params\">eWeaponType eType</span>)</span> &#123;</span><br><span class=\"line\">        speed = def.velocity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<figure>\r\n<img src=\"image%2026.png\" alt=\"image.png\" />\r\n<figcaption aria-hidden=\"true\">image.png</figcaption>\r\n</figure>"}],"PostAsset":[{"_id":"source/_posts/2022/11/再见了-青马易战/Untitled 1.png","slug":"Untitled 1.png","post":"cm3pihexg000mn0umfswr6pmd","modified":0,"renderable":0},{"_id":"source/_posts/2022/11/再见了-青马易战/Untitled.png","slug":"Untitled.png","post":"cm3pihexg000mn0umfswr6pmd","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 1.png","slug":"image 1.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 10.png","slug":"image 10.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 11.png","slug":"image 11.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 12.png","slug":"image 12.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 13.png","slug":"image 13.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 14.png","slug":"image 14.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 15.png","slug":"image 15.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 16.png","slug":"image 16.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 17.png","slug":"image 17.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 18.png","slug":"image 18.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 19.png","slug":"image 19.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 2.png","slug":"image 2.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 20.png","slug":"image 20.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 21.png","slug":"image 21.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 22.png","slug":"image 22.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 23.png","slug":"image 23.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 24.png","slug":"image 24.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 25.png","slug":"image 25.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 26.png","slug":"image 26.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 3.png","slug":"image 3.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 4.png","slug":"image 4.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 5.png","slug":"image 5.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 6.png","slug":"image 6.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 7.png","slug":"image 7.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 8.png","slug":"image 8.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image 9.png","slug":"image 9.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0},{"_id":"source/_posts/2024/10/Space SHMUP 拆解和拓展/image.png","slug":"image.png","post":"cm3pihexg000nn0umcn88bdl8","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}